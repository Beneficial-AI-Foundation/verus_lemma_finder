{
  "version": "1.0",
  "repo_root": "/home/lacra/git_repos/baif/curve25519-dalek/curve25519-dalek",
  "lemmas": [
    {
      "name": "spec_as_bytes",
      "file_path": "src/specs/field_specs_u64.rs",
      "line_number": 176,
      "documentation": "",
      "signature": "pub fn spec_as_bytes(limbs: [u64; 5]) -> [u8; 32]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_as_bytes().",
      "source": "project"
    },
    {
      "name": "lemma_group_order_bound",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1591,
      "documentation": "Proof that the group order is less than 2^255",
      "signature": "pub fn lemma_group_order_bound()",
      "requires_clauses": [],
      "ensures_clauses": [
        "group_order () < pow2 (255)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_bound().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_strictly_increases",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that if `e1 < e2` then `2^e1 < 2^e2`.",
      "signature": "pub fn lemma_pow2_strictly_increases(e1: nat, e2: nat)",
      "requires_clauses": [
        "e1 < e2"
      ],
      "ensures_clauses": [
        "# [trigger] pow2 (e1) < # [trigger] pow2 (e2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "source": "project"
    },
    {
      "name": "lemma_small_mod",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that a natural number x divided by a larger natural number\ngives a remainder equal to x. Specifically, because `x < m`, we\nknow `x % m == x`.",
      "signature": "pub fn lemma_small_mod(x: nat, m: nat)",
      "requires_clauses": [
        "x < m",
        "0 < m"
      ],
      "ensures_clauses": [
        "x % m == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_small_mod().",
      "source": "project"
    },
    {
      "name": "lemma_r_bounded",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1820,
      "documentation": "",
      "signature": "pub fn lemma_r_bounded(r: Scalar52)",
      "requires_clauses": [
        "r == (Scalar52 { limbs : [0x000f48bd6721e6ed , 0x0003bab5ac67e45a , 0x000fffffeb35e51b , 0x000fffffffffffff , 0x00000fffffffffff ,] , })"
      ],
      "ensures_clauses": [
        "limbs_bounded (& r)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_r_le_l",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 473,
      "documentation": "",
      "signature": "pub(crate) fn lemma_r_le_l(r: Scalar52)",
      "requires_clauses": [
        "r == (Scalar52 { limbs : [0x000f48bd6721e6ed , 0x0003bab5ac67e45a , 0x000fffffeb35e51b , 0x000fffffffffffff , 0x00000fffffffffff ,] , })"
      ],
      "ensures_clauses": [
        "to_nat (& r . limbs) < group_order ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_r_le_l().",
      "source": "project"
    },
    {
      "name": "lemma_five_limbs_equals_to_nat",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 203,
      "documentation": "",
      "signature": "pub fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "five_limbs_to_nat_aux (* limbs) == to_nat (limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_five_limbs_equals_to_nat().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_adds",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that `2^(e1 + e2)` is equivalent to `2^e1 * 2^e2`.",
      "signature": "pub fn lemma_pow2_adds(e1: nat, e2: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow2 (e1 + e2) == pow2 (e1) * pow2 (e2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_adds().",
      "source": "project"
    },
    {
      "name": "lemma_mul_factors_congruent_implies_products_congruent",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1797,
      "documentation": "",
      "signature": "pub fn lemma_mul_factors_congruent_implies_products_congruent(c: int, a: int, b: int, m: int)",
      "requires_clauses": [
        "m > 0",
        "a % m == b % m"
      ],
      "ensures_clauses": [
        "(c * a) % m == (c * b) % m"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_factors_congruent_implies_products_congruent().",
      "source": "project"
    },
    {
      "name": "lemma_cancel_mul_pow2_mod",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1677,
      "documentation": "",
      "signature": "pub fn lemma_cancel_mul_pow2_mod(a: nat, b: nat, r_pow: nat)",
      "requires_clauses": [
        "r_pow == pow2 (260)",
        "(a * r_pow) % group_order () == (b * r_pow) % group_order ()"
      ],
      "ensures_clauses": [
        "a % group_order () == b % group_order ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_pow2_mod().",
      "source": "project"
    },
    {
      "name": "lemma_group_order_smaller_than_pow256",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1811,
      "documentation": "",
      "signature": "pub fn lemma_group_order_smaller_than_pow256()",
      "requires_clauses": [],
      "ensures_clauses": [
        "group_order () < pow2 (256)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_smaller_than_pow256().",
      "source": "project"
    },
    {
      "name": "lemma_is_canonical_correctness",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1854,
      "documentation": "Proves correctness of is_canonical check\n\nThis lemma establishes that comparing a scalar to its reduced form\ncorrectly determines whether it is canonical (i.e., already in the range [0, group_order())).\n\nThe proof works by cases:\n- If self_bytes == reduced_bytes, then self is already canonical\n- If self_bytes != reduced_bytes, then they have different nat values (by injectivity),\n  but equal nat values mod group_order (by reduce's postcondition).\n  This is only possible if self_bytes represents a value >= group_order.",
      "signature": "pub fn lemma_is_canonical_correctness(self_bytes: &[u8; 32], reduced_bytes: &[u8; 32])",
      "requires_clauses": [
        "bytes_to_nat (reduced_bytes) < group_order ()",
        "bytes_to_nat (reduced_bytes) % group_order () == bytes_to_nat (self_bytes) % group_order ()"
      ],
      "ensures_clauses": [
        "(self_bytes == reduced_bytes) == (bytes_to_nat (self_bytes) < group_order ())"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_is_canonical_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_pos",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that 2 to the power of any natural number (specifically,\n`e`) is positive.",
      "signature": "pub fn lemma_pow2_pos(e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow2 (e) > 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_pos().",
      "source": "project"
    },
    {
      "name": "lemma_pow0",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that the given integer `b` to the power of 0 is 1.",
      "signature": "pub fn lemma_pow0(b: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (b , 0) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow0().",
      "source": "project"
    },
    {
      "name": "lemma_pow1",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that the given integer `b` to the power of 1 is `b`.",
      "signature": "pub fn lemma_pow1(b: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (b , 1) == b"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow1().",
      "source": "project"
    },
    {
      "name": "lemma_square_multiply_step",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1911,
      "documentation": "Lemma: Montgomery squaring preserves the squares property\nKey insight: 2^(k+1) - 1 = 2*(2^k - 1) + 1, so R^(2^(k+1) - 1) = R * (R^(2^k - 1))^2",
      "signature": "pub fn lemma_square_multiply_step(new_y: nat, y_before: nat, y0: nat, R: nat, L: nat, k: nat)",
      "requires_clauses": [
        "L > 0",
        "R > 0",
        "(new_y * R) % L == (y_before * y_before) % L",
        "(y_before * pow (R as int , (pow2 (k) - 1) as nat) as nat) % L == (pow (y0 as int , pow2 (k) ,) as nat) % L"
      ],
      "ensures_clauses": [
        "(new_y * pow (R as int , (pow2 (k + 1) - 1) as nat) as nat) % L == (pow (y0 as int , pow2 (k + 1) ,) as nat) % L"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_multiply_step().",
      "source": "project"
    },
    {
      "name": "lemma_pow_adds",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that taking an integer `b` to the power of the sum of two\nnatural numbers `e1` and `e2` is equivalent to multiplying `b` to\nthe power of `e1` by `b` to the power of `e2`.",
      "signature": "pub fn lemma_pow_adds(b: int, e1: nat, e2: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (b , e1 + e2) == pow (b , e1) * pow (b , e2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_adds().",
      "source": "project"
    },
    {
      "name": "lemma_pow_nonnegative",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 917,
      "documentation": "Lemma: Powers of non-negative integers are always non-negative\n\nFor any non-negative integer base and natural number exponent n,\npow(base, n) >= 0.\n\nThis is a fundamental property: multiplying non-negative numbers\nalways yields non-negative results.\n\nThis lemma extends vstd's `lemma_pow_positive` to handle the case when base = 0.",
      "signature": "pub fn lemma_pow_nonnegative(base: int, n: nat)",
      "requires_clauses": [
        "base >= 0"
      ],
      "ensures_clauses": [
        "pow (base , n) >= 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nonnegative().",
      "source": "project"
    },
    {
      "name": "lemma_scalar52_lt_pow2_256_if_canonical",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1631,
      "documentation": "If an UnpackedScalar (Scalar52) is canonical (< group_order), then it is < 2^256.",
      "signature": "pub fn lemma_scalar52_lt_pow2_256_if_canonical(a: &Scalar52)",
      "requires_clauses": [
        "limbs_bounded (a)",
        "to_nat (& a . limbs) < group_order ()"
      ],
      "ensures_clauses": [
        "to_nat (& a . limbs) < pow2 (256)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar52_lt_pow2_256_if_canonical().",
      "source": "project"
    },
    {
      "name": "lemma_mul_inequality",
      "file_path": "src/scalar.rs",
      "line_number": null,
      "documentation": "Proof that, since `x <= y` and `z >= 0`, `x * z <= y * z`.",
      "signature": "pub fn lemma_mul_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "x <= y",
        "z >= 0"
      ],
      "ensures_clauses": [
        "# [trigger] (x * z) <= # [trigger] (y * z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_inequality().",
      "source": "project"
    },
    {
      "name": "lemma_bytes_to_nat_lower_bound",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1558,
      "documentation": "Proves that bytes_to_nat is at least as large as any individual term in its sum",
      "signature": "pub fn lemma_bytes_to_nat_lower_bound(bytes: &[u8; 32], index: usize)",
      "requires_clauses": [
        "index < 32"
      ],
      "ensures_clauses": [
        "bytes_to_nat (bytes) >= (bytes [index as int] as nat) * pow2 ((index * 8) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_lower_bound().",
      "source": "project"
    },
    {
      "name": "spec_clamp_integer",
      "file_path": "src/specs/scalar_specs.rs",
      "line_number": 119,
      "documentation": "Spec function for clamping a byte array to produce a valid X25519 scalar.\nThis is the spec-level version of the `clamp_integer` exec function.\n\nThe clamping operation:\n- Clears the 3 least significant bits (bits 0-2 of byte 0)\n- Clears bit 255 (bit 7 of byte 31)\n- Sets bit 6 of byte 31)\n\nThis produces a value in the range [2^254, 2^255) that is divisible by 8.",
      "signature": "pub fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_clamp_integer().",
      "source": "project"
    },
    {
      "name": "spec_reduce",
      "file_path": "src/specs/field_specs_u64.rs",
      "line_number": 62,
      "documentation": "",
      "signature": "pub fn spec_reduce(limbs: [u64; 5]) -> [u64; 5]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_reduce().",
      "source": "project"
    },
    {
      "name": "spec_negate",
      "file_path": "src/specs/field_specs_u64.rs",
      "line_number": 93,
      "documentation": "",
      "signature": "pub fn spec_negate(limbs: [u64; 5]) -> [u64; 5]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs_u64/specs/spec_negate().",
      "source": "project"
    },
    {
      "name": "spec_field_element",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 75,
      "documentation": "Returns the canonical mathematical value of a field element in [0, p)\nwhere p = 2^255 - 19",
      "signature": "pub fn spec_field_element(fe: &FieldElement51) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element().",
      "source": "project"
    },
    {
      "name": "spec_edwards_point",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 187,
      "documentation": "Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates.",
      "signature": "pub fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_point().",
      "source": "project"
    },
    {
      "name": "spec_completed_point",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 205,
      "documentation": "Returns the field element values (X, Y, Z, T) from a CompletedPoint.\nA CompletedPoint is ((X:Z), (Y:T)) in P\u00b9 \u00d7 P\u00b9.",
      "signature": "pub fn spec_completed_point(point: crate::backend::serial::curve_models::CompletedPoint) -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_point().",
      "source": "project"
    },
    {
      "name": "spec_projective_point_edwards",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 228,
      "documentation": "Returns the field element values (X, Y, Z) from an Edwards ProjectivePoint.\nAn Edwards ProjectivePoint (X:Y:Z) is in projective coordinates.",
      "signature": "pub fn spec_projective_point_edwards(point: ProjectivePoint) -> (nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_point_edwards().",
      "source": "project"
    },
    {
      "name": "spec_identity_projective_point_edwards",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 237,
      "documentation": "Spec function: Identity element for ProjectivePoint as tuple\nIdentity in projective coordinates: (0, 1, 1) represents (0:1:1) which is affine point (0, 1)",
      "signature": "pub fn spec_identity_projective_point_edwards() -> (nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_projective_point_edwards().",
      "source": "project"
    },
    {
      "name": "spec_projective_niels_point",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 262,
      "documentation": "Returns the field element values (Y+X, Y-X, Z, T2d) from a ProjectiveNielsPoint.\n\nNiels coordinates are an optimized representation for point addition.\nReference: [HWCD2008] Section 3.1 for extended coordinates and efficient formulas",
      "signature": "pub fn spec_projective_niels_point(niels: ProjectiveNielsPoint) -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_niels_point().",
      "source": "project"
    },
    {
      "name": "spec_affine_niels_point",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 274,
      "documentation": "Returns the field element values (y+x, y-x, xy2d) from an AffineNielsPoint.\n\nAffine Niels coordinates store (y+x, y-x, xy2d) for efficient mixed addition.\nReference: [HWCD2008] Section 3.1",
      "signature": "pub fn spec_affine_niels_point(niels: AffineNielsPoint) -> (nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_affine_niels_point().",
      "source": "project"
    },
    {
      "name": "spec_field_element_from_bytes",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 82,
      "documentation": "Returns the canonical mathematical value when creating a field element from bytes.\nThe bytes are interpreted as a little-endian integer with the high bit of byte[31] ignored.\nThe result is the canonical value in [0, p) where p = 2^255 - 19.",
      "signature": "pub fn spec_field_element_from_bytes(bytes: &[u8; 32]) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_from_bytes().",
      "source": "project"
    },
    {
      "name": "spec_identity_affine_niels",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 415,
      "documentation": "Spec function: Identity element for AffineNielsPoint as tuple\nIdentity represents the point (0, 1) in affine coordinates\nFor Niels form (y+x, y-x, xy2d): (1, 1, 0)",
      "signature": "pub fn spec_identity_affine_niels() -> (nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_affine_niels().",
      "source": "project"
    },
    {
      "name": "spec_identity_projective_niels",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 431,
      "documentation": "Spec function: Identity element for ProjectiveNielsPoint as tuple\nIdentity represents the point (0:1:1) in projective coordinates\nFor Niels form (Y+X, Y-X, Z, T2d): (1, 1, 1, 0)",
      "signature": "pub fn spec_identity_projective_niels() -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_identity_projective_niels().",
      "source": "project"
    },
    {
      "name": "spec_negate_affine_niels",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 447,
      "documentation": "Spec function: Negation of an AffineNielsPoint as tuple\nNegation swaps y+x with y-x and negates xy2d",
      "signature": "pub fn spec_negate_affine_niels(p: (nat, nat, nat)) -> (nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_affine_niels().",
      "source": "project"
    },
    {
      "name": "spec_negate_projective_niels",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 465,
      "documentation": "Spec function: Negation of a ProjectiveNielsPoint as tuple\nNegation swaps Y+X with Y-X and negates T2d (Z stays the same)",
      "signature": "pub fn spec_negate_projective_niels(p: (nat, nat, nat, nat)) -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_negate_projective_niels().",
      "source": "project"
    },
    {
      "name": "spec_edwards_add_projective_niels",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 511,
      "documentation": "Helper spec function: Edwards addition of EdwardsPoint and ProjectiveNielsPoint\nCombines the affine conversion and addition into a single convenient spec function.",
      "signature": "pub fn spec_edwards_add_projective_niels(p: crate::edwards::EdwardsPoint, q: crate::backend::serial::curve_models::ProjectiveNielsPoint) -> (nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_projective_niels().",
      "source": "project"
    },
    {
      "name": "spec_edwards_add_affine_niels",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 522,
      "documentation": "Helper spec function: Edwards addition of EdwardsPoint and AffineNielsPoint\nCombines the affine conversion and addition into a single convenient spec function.",
      "signature": "pub fn spec_edwards_add_affine_niels(p: crate::edwards::EdwardsPoint, q: crate::backend::serial::curve_models::AffineNielsPoint) -> (nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_edwards_add_affine_niels().",
      "source": "project"
    },
    {
      "name": "spec_completed_to_projective",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 579,
      "documentation": "Spec for CompletedPoint::as_projective conversion\nConverts from P\u00b9 \u00d7 P\u00b9 to P\u00b2 via the mapping:\n  (X:Z, Y:T) \u21a6 (X\u00b7T : Y\u00b7Z : Z\u00b7T)\nThis preserves the affine point because:\n  X\u00b7T / Z\u00b7T = X/Z and Y\u00b7Z / Z\u00b7T = Y/T",
      "signature": "pub fn spec_completed_to_projective(point: crate::backend::serial::curve_models::CompletedPoint) -> (nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_projective().",
      "source": "project"
    },
    {
      "name": "spec_completed_to_extended",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 590,
      "documentation": "Spec for CompletedPoint::as_extended conversion\nConverts from P\u00b9 \u00d7 P\u00b9 to P\u00b3 via the Segre embedding:\n  ((X:Z), (Y:T)) \u21a6 (X\u00b7T : Y\u00b7Z : Z\u00b7T : X\u00b7Y)\nThis preserves the affine point and satisfies the extended coordinate invariant",
      "signature": "pub fn spec_completed_to_extended(point: crate::backend::serial::curve_models::CompletedPoint) -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_completed_to_extended().",
      "source": "project"
    },
    {
      "name": "spec_projective_to_extended",
      "file_path": "src/specs/edwards_specs.rs",
      "line_number": 601,
      "documentation": "Spec for ProjectivePoint::as_extended conversion\nConverts from P\u00b2 to P\u00b3 via:\n  (X:Y:Z) \u21a6 (X\u00b7Z : Y\u00b7Z : Z\u00b2 : X\u00b7Y)\nThis preserves the affine point and establishes the extended coordinate invariant",
      "signature": "pub fn spec_projective_to_extended(point: ProjectivePoint) -> (nat, nat, nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 edwards_specs/specs/spec_projective_to_extended().",
      "source": "project"
    },
    {
      "name": "axiom_p_is_prime",
      "file_path": "src/specs/primality_specs.rs",
      "line_number": 24,
      "documentation": "Axiom: The field modulus p() = 2^255 - 19 is prime\n\nThis is a well-known mathematical fact. The number 2^255 - 19 has been\nverified to be prime and is the foundation of the Curve25519 construction.\n\nThis axiom is the basis for field-theoretic properties like:\n- Existence of multiplicative inverses for all non-zero elements\n- Fermat's Little Theorem: x^(p-1) \u2261 1 (mod p) for x \u2262 0 (mod p)",
      "signature": "pub fn axiom_p_is_prime()",
      "requires_clauses": [],
      "ensures_clauses": [
        "is_prime (p ())"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 primality_specs/specs/axiom_p_is_prime().",
      "source": "project"
    },
    {
      "name": "spec_scalar",
      "file_path": "src/specs/scalar_specs.rs",
      "line_number": 39,
      "documentation": "Returns the mathematical value of a Scalar modulo the group order.\nThis is the value used in scalar multiplication: [n]P where n = spec_scalar(s).",
      "signature": "pub fn spec_scalar(s: &Scalar) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs/specs/spec_scalar().",
      "source": "project"
    },
    {
      "name": "lemma_u8_32_as_nat_equals_rec",
      "file_path": "src/specs/core_specs.rs",
      "line_number": 75,
      "documentation": "Lemma: u8_32_as_nat equals u8_32_as_nat_rec starting at index 0\nBoth represent the complete sum of all 32 bytes",
      "signature": "pub fn lemma_u8_32_as_nat_equals_rec(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "u8_32_as_nat (bytes) == u8_32_as_nat_rec (bytes , 0)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/lemma_u8_32_as_nat_equals_rec().",
      "source": "project"
    },
    {
      "name": "spec_load8_at",
      "file_path": "src/specs/core_specs.rs",
      "line_number": 93,
      "documentation": "Load 8 consecutive bytes from a byte array and interpret as a little-endian u64.\n\nReturns: bytes[i] + bytes[i+1] * 2^8 + ... + bytes[i+7] * 2^56\n\nThis is commonly used when unpacking byte arrays into larger word-sized limbs.",
      "signature": "pub fn spec_load8_at(input: &[u8], i: usize) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 core_specs/specs/spec_load8_at().",
      "source": "project"
    },
    {
      "name": "spec_montgomery_point",
      "file_path": "src/specs/montgomery_specs.rs",
      "line_number": 182,
      "documentation": "Returns the u-coordinate of a Montgomery point as a field element\nMontgomery points only store the u-coordinate; sign information is lost",
      "signature": "pub fn spec_montgomery_point(point: crate::montgomery::MontgomeryPoint) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_montgomery_point().",
      "source": "project"
    },
    {
      "name": "spec_u_coordinate",
      "file_path": "src/specs/montgomery_specs.rs",
      "line_number": 173,
      "documentation": "Extract the u-coordinate from a MontgomeryAffine point.\nMaps Infinity to 0, and Finite{u, v} to u.",
      "signature": "pub fn spec_u_coordinate(point: MontgomeryAffine) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_u_coordinate().",
      "source": "project"
    },
    {
      "name": "spec_projective_point_montgomery",
      "file_path": "src/specs/montgomery_specs.rs",
      "line_number": 223,
      "documentation": "Returns the field element values (U, W) from a Montgomery ProjectivePoint.\nA Montgomery ProjectivePoint (U:W) is in projective coordinates on the Montgomery curve.",
      "signature": "pub fn spec_projective_point_montgomery(point: crate::montgomery::ProjectivePoint) -> (nat, nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_point_montgomery().",
      "source": "project"
    },
    {
      "name": "spec_projective_u_coordinate",
      "file_path": "src/specs/montgomery_specs.rs",
      "line_number": 263,
      "documentation": "Extract the u-coordinate from a ProjectivePoint (U:W) as u = U/W.\nReturns 0 if W = 0 (which represents the point at infinity).",
      "signature": "pub fn spec_projective_u_coordinate(P: ProjectivePoint) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_specs/specs/spec_projective_u_coordinate().",
      "source": "project"
    },
    {
      "name": "spec_add_fe51_limbs",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 41,
      "documentation": "Spec function: result of limb-wise addition (what add_spec returns)",
      "signature": "pub fn spec_add_fe51_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_add_fe51_limbs().",
      "source": "project"
    },
    {
      "name": "spec_sub_limbs",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 55,
      "documentation": "Spec function: result of limb-wise subtraction with reduction (what sub_spec returns)\nAdds multiples of p to avoid underflow, then reduces",
      "signature": "pub fn spec_sub_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_sub_limbs().",
      "source": "project"
    },
    {
      "name": "spec_field_element_as_nat",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 69,
      "documentation": "",
      "signature": "pub fn spec_field_element_as_nat(fe: &FieldElement51) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_as_nat().",
      "source": "project"
    },
    {
      "name": "spec_field_element_sign_bit",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 88,
      "documentation": "Spec function: Get the sign bit of a field element\nIn Curve25519, the sign bit is the least significant bit of the canonical representation",
      "signature": "pub fn spec_field_element_sign_bit(fe: &FieldElement51) -> u8",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_field_element_sign_bit().",
      "source": "project"
    },
    {
      "name": "lemma_inverse_unique_core",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 150,
      "documentation": "Helper lemma: If a*w \u2261 1 (mod p) and a*z \u2261 1 (mod p), and both w,z < p, then w = z\n\nThis is the core uniqueness property of multiplicative inverses in modular arithmetic.\nThe proof follows the standard field theory argument:\n  w = w * 1 = w * (a * z) = (w * a) * z = 1 * z = z",
      "signature": "fn lemma_inverse_unique_core(a: nat, w: nat, z: nat, p: nat)",
      "requires_clauses": [
        "p > 0",
        "a % p != 0",
        "w < p",
        "z < p",
        "(a * w) % p == 1",
        "(a * z) % p == 1"
      ],
      "ensures_clauses": [
        "w == z"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_inverse_unique_core().",
      "source": "project"
    },
    {
      "name": "lemma_mul_mod_noop_general",
      "file_path": "src/specs/field_specs.rs",
      "line_number": null,
      "documentation": "Proof of various properties about modulo equivalence with respect\nto multiplication, specifically various expressions that `(x * y)\n% m` is equivalent to.",
      "signature": "pub fn lemma_mul_mod_noop_general(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "((x % m) * y) % m == (x * y) % m",
        "(x * (y % m)) % m == (x * y) % m",
        "((x % m) * (y % m)) % m == # [trigger] ((x * y) % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "source": "project"
    },
    {
      "name": "lemma_mul_is_associative",
      "file_path": "src/specs/field_specs.rs",
      "line_number": null,
      "documentation": "Proof that multiplication is associative, specifically that\n`x * (y * z) == (x * y) * z`.",
      "signature": "pub fn lemma_mul_is_associative(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x * (y * z) == (x * y) * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_associative().",
      "source": "project"
    },
    {
      "name": "lemma_mod_bound",
      "file_path": "src/specs/field_specs.rs",
      "line_number": null,
      "documentation": "Proof that when integer `x` is divided by positive integer `m`,\nthe remainder is nonegative and less than `m`.",
      "signature": "pub fn lemma_mod_bound(x: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x % m) < m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_bound().",
      "source": "project"
    },
    {
      "name": "lemma_fermat_for_p",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 274,
      "documentation": "Lemma: Fermat's Little Theorem applied to p() = 2^255 - 19\n\nFor any non-zero element x in the field \u2124/p()\u2124, we have x^(p-1) \u2261 1 (mod p).\nThis is a fundamental property of prime fields and the basis for computing\nmultiplicative inverses as x^(p-2) (since x * x^(p-2) = x^(p-1) \u2261 1).\n\nThis lemma is proven by:\n1. Invoking axiom_p_is_prime() to establish that p() is prime\n2. Applying the general lemma_fermat_little_theorem with p()\n\nThe general Fermat's Little Theorem is still admitted (requires group theory),\nbut this specific application to p() is now a proven lemma rather than an axiom.",
      "signature": "pub fn lemma_fermat_for_p(x: nat)",
      "requires_clauses": [
        "x % p () != 0"
      ],
      "ensures_clauses": [
        "(pow (x as int , (p () - 1) as nat) as nat) % p () == 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/lemma_fermat_for_p().",
      "source": "project"
    },
    {
      "name": "lemma_fermat_little_theorem",
      "file_path": "src/lemmas/common_lemmas/number_theory_lemmas.rs",
      "line_number": 29,
      "documentation": "Lemma: Fermat's Little Theorem\n\nFor any prime p and any integer x not divisible by p,\nwe have x^(p-1) \u2261 1 (mod p).\n\nThis is one of the fundamental theorems in number theory and the basis\nfor many cryptographic constructions, including:\n- Computing multiplicative inverses: x^(-1) \u2261 x^(p-2) (mod p)\n- Primality testing\n- Public-key cryptography\n\n**Proof Status**: Currently admitted. A complete proof would require:\n1. Defining the multiplicative group (\u2124/p\u2124)*\n2. Proving Lagrange's theorem (order of element divides order of group)\n3. Showing |\uff08\u2124/p\u2124)*| = p - 1 (Euler's totient for primes)\n\nWhile provable from the is_prime definition, this would require substantial\ngroup theory infrastructure that is currently beyond the scope of this\nverification effort.",
      "signature": "pub fn lemma_fermat_little_theorem(x: nat, prime: nat)",
      "requires_clauses": [
        "is_prime (prime)",
        "x % prime != 0"
      ],
      "ensures_clauses": [
        "(pow (x as int , (prime - 1) as nat) as nat) % prime == 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 number_theory_lemmas/common_lemmas/lemmas/lemma_fermat_little_theorem().",
      "source": "project"
    },
    {
      "name": "spec_fe51_from_bytes",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 303,
      "documentation": "Spec function for FieldElement::from_bytes\nTakes a 32-byte array and produces a FieldElement51\nThe high bit of byte[31] is ignored, giving a 255-bit value",
      "signature": "pub fn spec_fe51_from_bytes(bytes: &[u8; 32]) -> FieldElement51",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_from_bytes().",
      "source": "project"
    },
    {
      "name": "spec_fe51_to_bytes",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 325,
      "documentation": "",
      "signature": "pub fn spec_fe51_to_bytes(fe: &FieldElement51) -> Seq<u8>",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_fe51_to_bytes().",
      "source": "project"
    },
    {
      "name": "spec_product_of_field_elems",
      "file_path": "src/specs/field_specs.rs",
      "line_number": 403,
      "documentation": "Spec function to compute product of all field elements in a sequence (mod p)\nReturns the natural number representation",
      "signature": "pub fn spec_product_of_field_elems(fields: Seq<FieldElement51>) -> nat",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 field_specs/specs/spec_product_of_field_elems().",
      "source": "project"
    },
    {
      "name": "spec_mul_internal",
      "file_path": "src/specs/scalar_specs_u64.rs",
      "line_number": 158,
      "documentation": "",
      "signature": "pub fn spec_mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_specs_u64/specs/spec_mul_internal().",
      "source": "project"
    },
    {
      "name": "lemma_as_bytes_equals_spec_fe51_to_bytes",
      "file_path": "src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "line_number": 153,
      "documentation": "Lemma: as_bytes produces the same result as spec_fe51_to_bytes when converted to sequence\n\nThis is the key lemma for eliminating the assume in ct_eq.\nIt states that for any byte array that is produced by as_bytes() (i.e., satisfies\nthe as_bytes postcondition), when converted to a sequence, it equals spec_fe51_to_bytes().\n\nThe lemma relates:\n- bytes: a byte array satisfying as_bytes postcondition (u8_32_as_nat(&bytes) == u64_5_as_nat(fe.limbs) % p())\n- seq_from32(&bytes): the sequence representation of those bytes\n- spec_fe51_to_bytes(fe): the spec-level byte sequence\n\nProof strategy:\n- Both as_bytes() and spec_fe51_to_bytes() produce canonical representations\n- Both preserve the value modulo p (u64_5_as_nat(fe.limbs) % p())\n- The canonical representation modulo p is unique\n- Therefore, they produce the same byte sequence",
      "signature": "pub fn lemma_as_bytes_equals_spec_fe51_to_bytes(fe: &FieldElement51, bytes: &[u8; 32])",
      "requires_clauses": [
        "u8_32_as_nat (bytes) == u64_5_as_nat (fe . limbs) % p ()"
      ],
      "ensures_clauses": [
        "seq_from32 (bytes) == spec_fe51_to_bytes (fe)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_equals_spec_fe51_to_bytes().",
      "source": "project"
    },
    {
      "name": "lemma_seq_eq_implies_array_eq",
      "file_path": "src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "line_number": 390,
      "documentation": "Lemma: Sequence equality implies array equality",
      "signature": "pub fn lemma_seq_eq_implies_array_eq(bytes1: &[u8; 32], bytes2: &[u8; 32])",
      "requires_clauses": [
        "seq_from32 (bytes1) == seq_from32 (bytes2)"
      ],
      "ensures_clauses": [
        "* bytes1 == * bytes2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_seq_eq_implies_array_eq().",
      "source": "project"
    },
    {
      "name": "lemma_pow22501_prove_t3",
      "file_path": "src/lemmas/field_lemmas/pow22501_t3_lemma.rs",
      "line_number": 44,
      "documentation": "Proves that t3 = x^11 given the computation chain from pow22501\n\n# Arguments\n* `self_limbs` - The base value x\n* `t0_limbs` - x^2 (result of self.square())\n* `t0_sq_limbs` - x^4 (result of t0.square())\n* `t1_limbs` - x^8 (result of t0_sq.square())\n* `t2_limbs` - x^9 (result of self * t1)\n* `t3_limbs` - x^11 (result of t0 * t2)\n\n# Preconditions\n* Limbs are properly bounded (< 2^54)\n* Each step follows the correct field operation postconditions\n\n# Postconditions\n* u64_5_as_nat(t3_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, 11) as nat % p()\n* Also proves intermediate values: t0_sq = x^4, t1 = x^8, t2 = x^9",
      "signature": "pub fn lemma_pow22501_prove_t3(self_limbs: [u64; 5], t0_limbs: [u64; 5], t0_sq_limbs: [u64; 5], t1_limbs: [u64; 5], t2_limbs: [u64; 5], t3_limbs: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> self_limbs [i] < 1u64 << 54",
        "forall | i : int | 0 <= i < 5 ==> t0_limbs [i] < 1u64 << 54",
        "forall | i : int | 0 <= i < 5 ==> t0_sq_limbs [i] < 1u64 << 54",
        "forall | i : int | 0 <= i < 5 ==> t1_limbs [i] < 1u64 << 54",
        "forall | i : int | 0 <= i < 5 ==> t2_limbs [i] < 1u64 << 54",
        "forall | i : int | 0 <= i < 5 ==> t3_limbs [i] < 1u64 << 54",
        "u64_5_as_nat (t0_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 2) as nat % p ()",
        "u64_5_as_nat (t0_sq_limbs) % p () == pow (u64_5_as_nat (t0_limbs) as int , 2) as nat % p ()",
        "u64_5_as_nat (t1_limbs) % p () == pow (u64_5_as_nat (t0_sq_limbs) as int , 2) as nat % p ()",
        "u64_5_as_nat (t2_limbs) % p () == (u64_5_as_nat (self_limbs) * u64_5_as_nat (t1_limbs)) % p ()",
        "u64_5_as_nat (t3_limbs) % p () == (u64_5_as_nat (t0_limbs) * u64_5_as_nat (t2_limbs)) % p ()"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (t3_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 11) as nat % p ()",
        "u64_5_as_nat (t0_sq_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 4) as nat % p ()",
        "u64_5_as_nat (t1_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 8) as nat % p ()",
        "u64_5_as_nat (t2_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 9) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t3_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t3().",
      "source": "project"
    },
    {
      "name": "lemma_pow22501_prove_t19",
      "file_path": "src/lemmas/field_lemmas/pow22501_t19_lemma.rs",
      "line_number": 66,
      "documentation": "Proves that t19 = x^(2^250-1) given the complete computation chain from pow22501\n\n# Arguments\n* `self_limbs` - The base value x\n* `t0_limbs` - x^2\n* `t1_limbs` - x^8\n* `t2_limbs` - x^9\n* `t3_limbs` - x^11\n* `t4_limbs` - x^22 (result of t3.square())\n* `t5_limbs` - x^31 = x^(2^5-1) (result of t2 * t4)\n* `t6_limbs` - x^((2^5-1)*2^5) (result of t5.pow2k(5))\n* `t7_limbs` - x^(2^10-1) (result of t6 * t5)\n* `t8_limbs` - x^((2^10-1)*2^10) (result of t7.pow2k(10))\n* `t9_limbs` - x^(2^20-1) (result of t8 * t7)\n* `t10_limbs` - x^((2^20-1)*2^20) (result of t9.pow2k(20))\n* `t11_limbs` - x^(2^40-1) (result of t10 * t9)\n* `t12_limbs` - x^((2^40-1)*2^10) (result of t11.pow2k(10))\n* `t13_limbs` - x^(2^50-1) (result of t12 * t7)\n* `t14_limbs` - x^((2^50-1)*2^50) (result of t13.pow2k(50))\n* `t15_limbs` - x^(2^100-1) (result of t14 * t13)\n* `t16_limbs` - x^((2^100-1)*2^100) (result of t15.pow2k(100))\n* `t17_limbs` - x^(2^200-1) (result of t16 * t15)\n* `t18_limbs` - x^((2^200-1)*2^50) (result of t17.pow2k(50))\n* `t19_limbs` - x^(2^250-1) (result of t18 * t13)\n\n# Preconditions\n* Limbs are properly bounded (< 2^54)\n* Each step follows the correct field operation postconditions\n* t0, t1, t2, t3 satisfy the t3 checkpoint properties\n\n# Postconditions\n* u64_5_as_nat(t19_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, (pow2(250) - 1) as nat) as nat % p()\n* Also proves all intermediate values through the chain",
      "signature": "pub fn lemma_pow22501_prove_t19(self_limbs: [u64; 5], t0_limbs: [u64; 5], t1_limbs: [u64; 5], t2_limbs: [u64; 5], t3_limbs: [u64; 5], t4_limbs: [u64; 5], t5_limbs: [u64; 5], t6_limbs: [u64; 5], t7_limbs: [u64; 5], t8_limbs: [u64; 5], t9_limbs: [u64; 5], t10_limbs: [u64; 5], t11_limbs: [u64; 5], t12_limbs: [u64; 5], t13_limbs: [u64; 5], t14_limbs: [u64; 5], t15_limbs: [u64; 5], t16_limbs: [u64; 5], t17_limbs: [u64; 5], t18_limbs: [u64; 5], t19_limbs: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> self_limbs [i] < 1u64 << 54",
        "u64_5_as_nat (t2_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 9) as nat % p ()",
        "u64_5_as_nat (t3_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 11) as nat % p ()",
        "u64_5_as_nat (t0_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 2) as nat % p ()",
        "u64_5_as_nat (t1_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 8) as nat % p ()",
        "u64_5_as_nat (t4_limbs) % p () == pow (u64_5_as_nat (t3_limbs) as int , 2) as nat % p ()",
        "u64_5_as_nat (t6_limbs) % p () == pow (u64_5_as_nat (t5_limbs) as int , pow2 (5)) as nat % p ()",
        "u64_5_as_nat (t8_limbs) % p () == pow (u64_5_as_nat (t7_limbs) as int , pow2 (10)) as nat % p ()",
        "u64_5_as_nat (t10_limbs) % p () == pow (u64_5_as_nat (t9_limbs) as int , pow2 (20)) as nat % p ()",
        "u64_5_as_nat (t12_limbs) % p () == pow (u64_5_as_nat (t11_limbs) as int , pow2 (10)) as nat % p ()",
        "u64_5_as_nat (t14_limbs) % p () == pow (u64_5_as_nat (t13_limbs) as int , pow2 (50)) as nat % p ()",
        "u64_5_as_nat (t16_limbs) % p () == pow (u64_5_as_nat (t15_limbs) as int , pow2 (100)) as nat % p ()",
        "u64_5_as_nat (t18_limbs) % p () == pow (u64_5_as_nat (t17_limbs) as int , pow2 (50)) as nat % p ()",
        "u64_5_as_nat (t5_limbs) % p () == (u64_5_as_nat (t2_limbs) * u64_5_as_nat (t4_limbs)) % p ()",
        "u64_5_as_nat (t7_limbs) % p () == (u64_5_as_nat (t6_limbs) * u64_5_as_nat (t5_limbs)) % p ()",
        "u64_5_as_nat (t9_limbs) % p () == (u64_5_as_nat (t8_limbs) * u64_5_as_nat (t7_limbs)) % p ()",
        "u64_5_as_nat (t11_limbs) % p () == (u64_5_as_nat (t10_limbs) * u64_5_as_nat (t9_limbs)) % p ()",
        "u64_5_as_nat (t13_limbs) % p () == (u64_5_as_nat (t12_limbs) * u64_5_as_nat (t7_limbs)) % p ()",
        "u64_5_as_nat (t15_limbs) % p () == (u64_5_as_nat (t14_limbs) * u64_5_as_nat (t13_limbs)) % p ()",
        "u64_5_as_nat (t17_limbs) % p () == (u64_5_as_nat (t16_limbs) * u64_5_as_nat (t15_limbs)) % p ()",
        "u64_5_as_nat (t19_limbs) % p () == (u64_5_as_nat (t18_limbs) * u64_5_as_nat (t13_limbs)) % p ()"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (t19_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (250) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t2_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 9) as nat % p ()",
        "u64_5_as_nat (t3_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 11) as nat % p ()",
        "u64_5_as_nat (t4_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , 22) as nat % p ()",
        "u64_5_as_nat (t5_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (5) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t7_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (10) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t9_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (20) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t11_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (40) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t13_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (50) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t15_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (100) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t17_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (200) - 1) as nat ,) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow22501_t19_lemma/field_lemmas/lemmas/lemma_pow22501_prove_t19().",
      "source": "project"
    },
    {
      "name": "lemma_bridge_pow_as_nat_to_spec",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 71,
      "documentation": "",
      "signature": "pub fn lemma_bridge_pow_as_nat_to_spec(result: &FieldElement51, base: &FieldElement51, exp: nat)",
      "requires_clauses": [
        "u64_5_as_nat (result . limbs) % p () == (pow (u64_5_as_nat (base . limbs) as int , exp) as nat) % p ()"
      ],
      "ensures_clauses": [
        "spec_field_element (result) == (pow (spec_field_element (base) as int , exp) as nat) % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_bridge_pow_as_nat_to_spec().",
      "source": "project"
    },
    {
      "name": "lemma_invert_correctness",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 467,
      "documentation": "Main lemma: Correctness of the invert implementation\n\nTies together all the smaller lemmas to prove the complete specification",
      "signature": "pub fn lemma_invert_correctness(self_fe: &FieldElement51, t19: &FieldElement51, t3: &FieldElement51, t20: &FieldElement51, t21: &FieldElement51)",
      "requires_clauses": [
        "spec_field_element (t19) == (pow (spec_field_element (self_fe) as int , (pow2 (250) - 1) as nat ,) as nat) % p ()",
        "spec_field_element (t3) == (pow (spec_field_element (self_fe) as int , 11) as nat) % p ()",
        "u64_5_as_nat (t20 . limbs) % p () == (pow (u64_5_as_nat (t19 . limbs) as int , pow2 (5)) as nat) % p ()",
        "spec_field_element (t21) == math_field_mul (spec_field_element (t20) , spec_field_element (t3))"
      ],
      "ensures_clauses": [
        "spec_field_element (self_fe) != 0 ==> (spec_field_element (t21) * spec_field_element (self_fe)) % p () == 1",
        "spec_field_element (self_fe) == 0 ==> spec_field_element (t21) == 0",
        "spec_field_element (t21) == math_field_inv (spec_field_element (self_fe))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_pow_mod_noop",
      "file_path": "src/field.rs",
      "line_number": null,
      "documentation": "Proof that exponentiation then modulo produces the same result as\ndoing the modulo first, then doing the exponentiation, then doing\nthe modulo again. Specifically, `((b % m)^e) % m == b^e % m`.",
      "signature": "pub fn lemma_pow_mod_noop(b: int, e: nat, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] pow (b % m , e) % m == pow (b , e) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_mod_noop().",
      "source": "project"
    },
    {
      "name": "lemma_pow_p58_prove",
      "file_path": "src/lemmas/field_lemmas/pow_p58_lemma.rs",
      "line_number": 42,
      "documentation": "Proves that pow_p58 correctly computes x^(2^252-3)\n\n# Arguments\n* `self_limbs` - The base value x\n* `t19_limbs` - x^(2^250-1) (from pow22501)\n* `t20_limbs` - Result of t19.pow2k(2) = x^(2^252-4)\n* `t21_limbs` - Result of self * t20 = x^(2^252-3)\n\n# Preconditions\n* t19 = x^(2^250-1) mod p\n* t20 = t19^4 mod p (from pow2k(2))\n* t21 = self * t20 mod p\n\n# Postconditions\n* u64_5_as_nat(t21_limbs) % p() == pow(u64_5_as_nat(self_limbs) as int, (pow2(252) - 3) as nat) % p()",
      "signature": "pub fn lemma_pow_p58_prove(self_limbs: [u64; 5], t19_limbs: [u64; 5], t20_limbs: [u64; 5], t21_limbs: [u64; 5])",
      "requires_clauses": [
        "u64_5_as_nat (t19_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (250) - 1) as nat ,) as nat % p ()",
        "u64_5_as_nat (t20_limbs) % p () == pow (u64_5_as_nat (t19_limbs) as int , pow2 (2)) as nat % p ()",
        "u64_5_as_nat (t21_limbs) % p () == (u64_5_as_nat (self_limbs) * u64_5_as_nat (t20_limbs)) % p ()"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (t21_limbs) % p () == pow (u64_5_as_nat (self_limbs) as int , (pow2 (252) - 3) as nat ,) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_p58_lemma/field_lemmas/lemmas/lemma_pow_p58_prove().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_rec_version_is_exec",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 32,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_rec_version_is_exec(input: &[u8], i: usize)",
      "requires_clauses": [],
      "ensures_clauses": [
        "load8_at_or_version_rec (input , i , 7) == (input [i as int] as u64) | ((input [i + 1] as u64) << 8) | ((input [i + 2] as u64) << 16) | ((input [i + 3] as u64) << 24) | ((input [i + 4] as u64) << 32) | ((input [i + 5] as u64) << 40) | ((input [i + 6] as u64) << 48) | ((input [i + 7] as u64) << 56)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_rec_version_is_exec().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_versions_equivalent",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 232,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_versions_equivalent(input: &[u8], i: usize, k: nat)",
      "requires_clauses": [
        "k <= 7"
      ],
      "ensures_clauses": [
        "load8_at_or_version_rec (input , i , k) == load8_at_plus_version_rec (input , i , k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_versions_equivalent().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_plus_version_is_spec",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 176,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_plus_version_is_spec(input: &[u8], i: usize)",
      "requires_clauses": [],
      "ensures_clauses": [
        "load8_at_plus_version_rec (input , i , 7) == spec_load8_at (input , i)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec().",
      "source": "project"
    },
    {
      "name": "lemma_mul_le",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 28,
      "documentation": "",
      "signature": "pub fn lemma_mul_le(a1: nat, b1: nat, a2: nat, b2: nat)",
      "requires_clauses": [
        "a1 <= b1",
        "a2 <= b2"
      ],
      "ensures_clauses": [
        "a1 * a2 <= b1 * b2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_le().",
      "source": "project"
    },
    {
      "name": "lemma_field51_add",
      "file_path": "src/lemmas/field_lemmas/add_lemmas.rs",
      "line_number": 14,
      "documentation": "",
      "signature": "pub fn lemma_field51_add(lhs: &FieldElement51, rhs: &FieldElement51)",
      "requires_clauses": [
        "sum_of_limbs_bounded (lhs , rhs , u64 :: MAX)"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (spec_add_fe51_limbs (lhs , rhs) . limbs) == u64_5_as_nat (lhs . limbs) + u64_5_as_nat (rhs . limbs ,)",
        "spec_field_element (& spec_add_fe51_limbs (lhs , rhs)) == math_field_add (spec_field_element (lhs) , spec_field_element (rhs) ,)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field51_add().",
      "source": "project"
    },
    {
      "name": "lemma_field_add_16p_no_overflow",
      "file_path": "src/lemmas/field_lemmas/add_lemmas.rs",
      "line_number": 47,
      "documentation": "",
      "signature": "pub fn lemma_field_add_16p_no_overflow(lhs: &FieldElement51, rhs: &FieldElement51)",
      "requires_clauses": [
        "fe51_limbs_bounded (lhs , 54)",
        "fe51_limbs_bounded (rhs , 54)"
      ],
      "ensures_clauses": [
        "lhs . limbs [0] <= u64 :: MAX - 36028797018963664u64",
        "lhs . limbs [1] <= u64 :: MAX - 36028797018963952u64",
        "lhs . limbs [2] <= u64 :: MAX - 36028797018963952u64",
        "lhs . limbs [3] <= u64 :: MAX - 36028797018963952u64",
        "lhs . limbs [4] <= u64 :: MAX - 36028797018963952u64",
        "rhs . limbs [0] < 36028797018963664u64",
        "rhs . limbs [1] < 36028797018963952u64",
        "rhs . limbs [2] < 36028797018963952u64",
        "rhs . limbs [3] < 36028797018963952u64",
        "rhs . limbs [4] < 36028797018963952u64"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 add_lemmas/field_lemmas/lemmas/lemma_field_add_16p_no_overflow().",
      "source": "project"
    },
    {
      "name": "lemma_u64_5_as_nat_add",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 119,
      "documentation": "",
      "signature": "pub fn lemma_u64_5_as_nat_add(a: [u64; 5], b: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> b [i] as nat + a [i] as nat <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "u64_5_as_nat ([(a [0] + b [0]) as u64 , (a [1] + b [1]) as u64 , (a [2] + b [2]) as u64 , (a [3] + b [3]) as u64 , (a [4] + b [4]) as u64 ,] ,) == u64_5_as_nat (a) + u64_5_as_nat (b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_add().",
      "source": "project"
    },
    {
      "name": "lemma_u64_5_as_nat_sub",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 152,
      "documentation": "",
      "signature": "pub fn lemma_u64_5_as_nat_sub(a: [u64; 5], b: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> b [i] <= a [i]"
      ],
      "ensures_clauses": [
        "u64_5_as_nat ([(a [0] - b [0]) as u64 , (a [1] - b [1]) as u64 , (a [2] - b [2]) as u64 , (a [3] - b [3]) as u64 , (a [4] - b [4]) as u64 ,] ,) == u64_5_as_nat (a) - u64_5_as_nat (b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_sub().",
      "source": "project"
    },
    {
      "name": "lemma_sub_constants_equal_16p",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 699,
      "documentation": "Proves that the subtraction constants expand to 16 * p() in radix-2^51 form.",
      "signature": "pub fn lemma_sub_constants_equal_16p()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(36028797018963664u64 as nat + pow2 (51) * (36028797018963952u64 as nat) + pow2 (102) * (36028797018963952u64 as nat) + pow2 (153) * (36028797018963952u64 as nat) + pow2 (204) * (36028797018963952u64 as nat)) == (16 as nat) * p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_sub_constants_equal_16p().",
      "source": "project"
    },
    {
      "name": "lemma_mod_sum_factor",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 42,
      "documentation": "",
      "signature": "pub fn lemma_mod_sum_factor(a: int, b: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "(a * m + b) % m == b % m"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_factor().",
      "source": "project"
    },
    {
      "name": "lemma_mod_twice",
      "file_path": "src/backend/serial/u64/field.rs",
      "line_number": null,
      "documentation": "Proof that performing `(x % m) % m` gives the same result as simply perfoming `x % m`.",
      "signature": "pub fn lemma_mod_twice(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] ((x % m) % m) == x % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_twice().",
      "source": "project"
    },
    {
      "name": "lemma_sub_mod_noop",
      "file_path": "src/backend/serial/u64/field.rs",
      "line_number": null,
      "documentation": "Proof that modulo distributes over subtraction provided you do an\nextra modulo operation after subtracting the remainders.\nSpecifically, `((x % m) - (y % m)) % m == (x - y) % m`.",
      "signature": "pub fn lemma_sub_mod_noop(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "((x % m) - (y % m)) % m == (x - y) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "source": "project"
    },
    {
      "name": "lemma_neg",
      "file_path": "src/lemmas/field_lemmas/negate_lemmas.rs",
      "line_number": 130,
      "documentation": "",
      "signature": "pub fn lemma_neg(elem: &FieldElement51)",
      "requires_clauses": [
        "(u64_5_as_nat (spec_negate (elem . limbs)) + u64_5_as_nat (elem . limbs)) % p () == 0"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (spec_negate (elem . limbs)) % p () == math_field_neg (spec_field_element (elem))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg().",
      "source": "project"
    },
    {
      "name": "lemma_neg_no_underflow",
      "file_path": "src/lemmas/field_lemmas/negate_lemmas.rs",
      "line_number": 27,
      "documentation": "",
      "signature": "pub fn lemma_neg_no_underflow(limbs: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 51)"
      ],
      "ensures_clauses": [
        "all_neg_limbs_positive (limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/lemma_neg_no_underflow().",
      "source": "project"
    },
    {
      "name": "proof_negate",
      "file_path": "src/lemmas/field_lemmas/negate_lemmas.rs",
      "line_number": 39,
      "documentation": "",
      "signature": "pub fn proof_negate(limbs: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 51)",
        "all_neg_limbs_positive (limbs)"
      ],
      "ensures_clauses": [
        "forall | i : int | 0 <= i < 5 ==> spec_negate (limbs) [i] < (1u64 << 52)",
        "u64_5_as_nat (spec_negate (limbs)) == 16 * p () - u64_5_as_nat (limbs) - p () * ((36028797018963952u64 - limbs [4]) as u64 >> 51)",
        "(u64_5_as_nat (spec_negate (limbs)) + u64_5_as_nat (limbs)) % p () == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 negate_lemmas/field_lemmas/lemmas/proof_negate().",
      "source": "project"
    },
    {
      "name": "lemma_reduce_boundaries",
      "file_path": "src/lemmas/field_lemmas/reduce_lemmas.rs",
      "line_number": 25,
      "documentation": "",
      "signature": "pub fn lemma_reduce_boundaries(limbs: [u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "((limbs [0] & mask51) + (limbs [4] >> 51) * 19) < (1u64 << 52)",
        "((limbs [1] & mask51) + (limbs [0] >> 51)) < (1u64 << 52)",
        "((limbs [2] & mask51) + (limbs [1] >> 51)) < (1u64 << 52)",
        "((limbs [3] & mask51) + (limbs [2] >> 51)) < (1u64 << 52)",
        "((limbs [4] & mask51) + (limbs [3] >> 51)) < (1u64 << 52)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_boundaries().",
      "source": "project"
    },
    {
      "name": "proof_reduce",
      "file_path": "src/lemmas/field_lemmas/reduce_lemmas.rs",
      "line_number": 66,
      "documentation": "",
      "signature": "pub fn proof_reduce(limbs: [u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | i : int | 0 <= i < 5 ==> spec_reduce (limbs) [i] < (1u64 << 52)",
        "(forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 51)) ==> (spec_reduce (limbs) =~= limbs)",
        "u64_5_as_nat (spec_reduce (limbs)) == u64_5_as_nat (limbs) - p () * (limbs [4] >> 51)",
        "u64_5_as_nat (spec_reduce (limbs)) % p () == u64_5_as_nat (limbs) % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/proof_reduce().",
      "source": "project"
    },
    {
      "name": "lemma_reduce_bound_2p",
      "file_path": "src/lemmas/field_lemmas/reduce_lemmas.rs",
      "line_number": 205,
      "documentation": "Proves that reduce() ensures u64_5_as_nat < 2*p()\n\nThis is the key property needed for to_bytes(): after reduce(),\nthe value is bounded by 2*p = 2^256 - 38, not just by the loose\nbound from individual limb sizes.",
      "signature": "pub fn lemma_reduce_bound_2p(limbs: [u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "u64_5_as_nat (spec_reduce (limbs)) < 2 * p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 reduce_lemmas/field_lemmas/lemmas/lemma_reduce_bound_2p().",
      "source": "project"
    },
    {
      "name": "lemma_spec_load8_at_fits_u64",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 290,
      "documentation": "",
      "signature": "pub fn lemma_spec_load8_at_fits_u64(input: &[u8], i: usize)",
      "requires_clauses": [
        "i + 7 < input . len ()"
      ],
      "ensures_clauses": [
        "spec_load8_at (input , i) <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_spec_load8_at_fits_u64().",
      "source": "project"
    },
    {
      "name": "lemma_from_bytes_as_nat",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 397,
      "documentation": "",
      "signature": "pub fn lemma_from_bytes_as_nat(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "u64_5_as_nat ([spec_load8_at (bytes , 0) as u64 & mask51 , (spec_load8_at (bytes , 6) as u64 >> 3) & mask51 , (spec_load8_at (bytes , 12) as u64 >> 6) & mask51 , (spec_load8_at (bytes , 19) as u64 >> 1) & mask51 , (spec_load8_at (bytes , 24) as u64 >> 12) & mask51 ,] ,) == (bytes [0] * pow2 (0 * 8)) + (bytes [1] * pow2 (1 * 8)) + (bytes [2] * pow2 (2 * 8)) + (bytes [3] * pow2 (3 * 8)) + (bytes [4] * pow2 (4 * 8)) + (bytes [5] * pow2 (5 * 8)) + (bytes [6] * pow2 (6 * 8)) + (bytes [7] * pow2 (7 * 8)) + (bytes [8] * pow2 (8 * 8)) + (bytes [9] * pow2 (9 * 8 ,)) + (bytes [10] * pow2 (10 * 8)) + (bytes [11] * pow2 (11 * 8)) + (bytes [12] * pow2 (12 * 8)) + (bytes [13] * pow2 (13 * 8)) + (bytes [14] * pow2 (14 * 8)) + (bytes [15] * pow2 (15 * 8)) + (bytes [16] * pow2 (16 * 8)) + (bytes [17] * pow2 (17 * 8)) + (bytes [18] * pow2 (18 * 8)) + (bytes [19] * pow2 (19 * 8)) + (bytes [20] * pow2 (20 * 8)) + (bytes [21] * pow2 (21 * 8)) + (bytes [22] * pow2 (22 * 8)) + (bytes [23] * pow2 (23 * 8)) + (bytes [24] * pow2 (24 * 8)) + (bytes [25] * pow2 (25 * 8)) + (bytes [26] * pow2 (26 * 8)) + (bytes [27] * pow2 (27 * 8)) + (bytes [28] * pow2 (28 * 8)) + (bytes [29] * pow2 (29 * 8)) + (bytes [30] * pow2 (30 * 8)) + ((bytes [31] as nat % pow2 (7)) * pow2 ((31 * 8) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat().",
      "source": "project"
    },
    {
      "name": "lemma_as_nat_32_mod_255",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 423,
      "documentation": "",
      "signature": "pub fn lemma_as_nat_32_mod_255(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "u8_32_as_nat (bytes) % pow2 (255) == (bytes [0] * pow2 (0 * 8)) + (bytes [1] * pow2 (1 * 8)) + (bytes [2] * pow2 (2 * 8)) + (bytes [3] * pow2 (3 * 8)) + (bytes [4] * pow2 (4 * 8)) + (bytes [5] * pow2 (5 * 8)) + (bytes [6] * pow2 (6 * 8)) + (bytes [7] * pow2 (7 * 8)) + (bytes [8] * pow2 (8 * 8 ,)) + (bytes [9] * pow2 (9 * 8)) + (bytes [10] * pow2 (10 * 8)) + (bytes [11] * pow2 (11 * 8)) + (bytes [12] * pow2 (12 * 8)) + (bytes [13] * pow2 (13 * 8)) + (bytes [14] * pow2 (14 * 8)) + (bytes [15] * pow2 (15 * 8)) + (bytes [16] * pow2 (16 * 8)) + (bytes [17] * pow2 (17 * 8)) + (bytes [18] * pow2 (18 * 8)) + (bytes [19] * pow2 (19 * 8)) + (bytes [20] * pow2 (20 * 8)) + (bytes [21] * pow2 (21 * 8)) + (bytes [22] * pow2 (22 * 8)) + (bytes [23] * pow2 (23 * 8)) + (bytes [24] * pow2 (24 * 8)) + (bytes [25] * pow2 (25 * 8)) + (bytes [26] * pow2 (26 * 8)) + (bytes [27] * pow2 (27 * 8)) + (bytes [28] * pow2 (28 * 8)) + (bytes [29] * pow2 (29 * 8)) + (bytes [30] * pow2 (30 * 8)) + ((bytes [31] as nat % pow2 (7)) * pow2 (31 * 8))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_as_nat_32_mod_255().",
      "source": "project"
    },
    {
      "name": "lemma_as_bytes_boundaries1",
      "file_path": "src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "line_number": 31,
      "documentation": "",
      "signature": "pub fn lemma_as_bytes_boundaries1(raw_limbs: [u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "spec_reduce (raw_limbs) [0] + 19 < u64 :: MAX",
        "spec_reduce (raw_limbs) [1] + 2 < u64 :: MAX",
        "spec_reduce (raw_limbs) [2] + 2 < u64 :: MAX",
        "spec_reduce (raw_limbs) [3] + 2 < u64 :: MAX",
        "spec_reduce (raw_limbs) [4] + 2 < u64 :: MAX",
        "forall | i : int | 0 <= i <= 4 ==> compute_q_arr (spec_reduce (raw_limbs)) [i] as u64 <= 2",
        "(1u64 << 52) + 19 <= u64 :: MAX",
        "((1u64 << 52) + 19) as u64 >> 51 == 2",
        "((1u64 << 52) + 2) as u64 >> 51 == 2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries1().",
      "source": "project"
    },
    {
      "name": "lemma_as_bytes_boundaries2",
      "file_path": "src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "line_number": 79,
      "documentation": "",
      "signature": "pub fn lemma_as_bytes_boundaries2(raw_limbs: [u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "mask51 == (1u64 << 51) - 1",
        "compute_unmasked_limbs (spec_reduce (raw_limbs) , compute_q_spec (spec_reduce (raw_limbs))) [0] >> 51 <= 2",
        "compute_unmasked_limbs (spec_reduce (raw_limbs) , compute_q_spec (spec_reduce (raw_limbs))) [1] >> 51 <= 2",
        "compute_unmasked_limbs (spec_reduce (raw_limbs) , compute_q_spec (spec_reduce (raw_limbs))) [2] >> 51 <= 2",
        "compute_unmasked_limbs (spec_reduce (raw_limbs) , compute_q_spec (spec_reduce (raw_limbs))) [3] >> 51 <= 2",
        "compute_unmasked_limbs (spec_reduce (raw_limbs) , compute_q_spec (spec_reduce (raw_limbs))) [4] >> 51 <= 2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_as_bytes_boundaries2().",
      "source": "project"
    },
    {
      "name": "lemma_compute_q",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 558,
      "documentation": "Proves that q computed via successive carry propagation equals 1 iff h >= p, 0 otherwise\nwhere h = u64_5_as_nat(limbs) and limbs[i] < 2^52 for all i\n\nThe precondition `u64_5_as_nat(limbs) < 2 * p()` is satisfied when limbs come from\n`reduce()` output, which now ensures this property in its postcondition.",
      "signature": "pub fn lemma_compute_q(limbs: [u64; 5], q: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)",
        "u64_5_as_nat (limbs) < 2 * p ()",
        "q == compute_q_spec (limbs)"
      ],
      "ensures_clauses": [
        "q == 0 || q == 1",
        "u64_5_as_nat (limbs) >= p () <==> q == 1",
        "u64_5_as_nat (limbs) < p () <==> q == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_compute_q().",
      "source": "project"
    },
    {
      "name": "lemma_to_bytes_reduction",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 561,
      "documentation": "Proves that after adding 19*q and propagating carries while masking to 51 bits,\nthe result equals u64_5_as_nat(input_limbs) mod p",
      "signature": "pub fn lemma_to_bytes_reduction(input_limbs: [u64; 5], final_limbs: [u64; 5], q: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> input_limbs [i] < (1u64 << 52)",
        "q == 0 || q == 1",
        "u64_5_as_nat (input_limbs) >= p () <==> q == 1",
        "u64_5_as_nat (input_limbs) < 2 * p ()",
        "final_limbs == reduce_with_q_spec (input_limbs , q)"
      ],
      "ensures_clauses": [
        "forall | i : int | 0 <= i < 5 ==> final_limbs [i] < (1u64 << 51)",
        "u64_5_as_nat (final_limbs) == u64_5_as_nat (input_limbs) % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_to_bytes_reduction().",
      "source": "project"
    },
    {
      "name": "lemma_limbs_to_bytes",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 49,
      "documentation": "Core lemma: proves that packing 51-bit limbs into bytes preserves the value\n\nThis is the main lemma we need to complete the `to_bytes` proof.\nIt connects the byte representation with the limb representation.",
      "signature": "pub fn lemma_limbs_to_bytes(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "u8_32_as_nat (& bytes) == u64_5_as_nat (limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limbs_to_bytes().",
      "source": "project"
    },
    {
      "name": "lemma_pow2k_loop_boundary",
      "file_path": "src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "line_number": 236,
      "documentation": "",
      "signature": "pub fn lemma_pow2k_loop_boundary(a: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> a [i] < 1u64 << 54"
      ],
      "ensures_clauses": [
        "pow2k_loop_boundary_spec (a)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_boundary().",
      "source": "project"
    },
    {
      "name": "lemma_pow2k_loop_value",
      "file_path": "src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "line_number": 327,
      "documentation": "",
      "signature": "pub fn lemma_pow2k_loop_value(a: [u64; 5], limbs: [u64; 5], i: nat)",
      "requires_clauses": [
        "pow2k_loop_boundary_spec (a)",
        "u64_5_as_nat (a) % p () == pow (u64_5_as_nat (limbs) as int , pow2 (i)) as nat % p ()"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (pow2k_loop_return (a)) % p () == pow (u64_5_as_nat (limbs) as int , pow2 (i + 1) ,) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_pow2k_loop_value().",
      "source": "project"
    },
    {
      "name": "lemma_mul_left_inequality",
      "file_path": "src/backend/serial/u64/field.rs",
      "line_number": null,
      "documentation": "Proof that multiplying the positive integer `x` by respectively\n`y` and `z` maintains the order of `y` and `z`. Specifically, `y\n<= z ==> x * y <= x * z` and `y < z ==> x * y < x * z`.",
      "signature": "pub fn lemma_mul_left_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 < x"
      ],
      "ensures_clauses": [
        "y <= z ==> # [trigger] (x * y) <= # [trigger] (x * z)",
        "y < z ==> x * y < x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_left_inequality().",
      "source": "project"
    },
    {
      "name": "lemma_u64_5_as_nat_k",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 516,
      "documentation": "",
      "signature": "pub fn lemma_u64_5_as_nat_k(a: [u64; 5], k: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> (k * a [i]) <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "u64_5_as_nat ([(k * a [0]) as u64 , (k * a [1]) as u64 , (k * a [2]) as u64 , (k * a [3]) as u64 , (k * a [4]) as u64 ,] ,) == k * u64_5_as_nat (a)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_k().",
      "source": "project"
    },
    {
      "name": "lemma_mul_mod_noop",
      "file_path": "src/backend/serial/u64/field.rs",
      "line_number": null,
      "documentation": "Proof that modulo distributes over multiplication, provided you do\nan extra modulo operation after multiplying the remainders. Specifically,\n`(x % m) * (y % m) % m == (x * y) % m`.",
      "signature": "pub fn lemma_mul_mod_noop(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(x % m) * (y % m) % m == # [trigger] ((x * y) % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "source": "project"
    },
    {
      "name": "lemma_pow_nat_is_nat",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 89,
      "documentation": "",
      "signature": "pub fn lemma_pow_nat_is_nat(v: nat, i: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow (v as int , pow2 (i)) >= 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_nat_is_nat().",
      "source": "project"
    },
    {
      "name": "lemma_mul_strict_inequality",
      "file_path": "src/backend/serial/u64/field.rs",
      "line_number": null,
      "documentation": "Proof that since `x < y` and `z > 0`, `x * z < y * z`.",
      "signature": "pub fn lemma_mul_strict_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "x < y",
        "z > 0"
      ],
      "ensures_clauses": [
        "x * z < y * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "source": "project"
    },
    {
      "name": "lemma_from_montgomery_is_product_with_one",
      "file_path": "src/lemmas/scalar_montgomery_lemmas.rs",
      "line_number": 12,
      "documentation": "Lemma: A 9-limb array with first 5 limbs matching self and last 4 being 0\ncan be viewed as the product of self and 1",
      "signature": "pub fn lemma_from_montgomery_is_product_with_one(self_scalar: &Scalar52, limbs: &[u128; 9])",
      "requires_clauses": [
        "limbs_bounded (self_scalar)",
        "forall | j : int | # ! [auto] 0 <= j < 5 ==> limbs [j] == self_scalar . limbs [j] as u128",
        "forall | j : int | # ! [auto] 5 <= j < 9 ==> limbs [j] == 0"
      ],
      "ensures_clauses": [
        "(exists | bounded1 : & Scalar52 , bounded2 : & Scalar52 | limbs_bounded (bounded1) && limbs_bounded (bounded2) && spec_mul_internal (bounded1 , bounded2 ,) == limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_montgomery_lemmas/lemmas/lemma_from_montgomery_is_product_with_one().",
      "source": "project"
    },
    {
      "name": "lemma_52_52",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 46,
      "documentation": "",
      "signature": "pub fn lemma_52_52(x: u64, y: u64)",
      "requires_clauses": [
        "x < (1u64 << 52)",
        "y < (1u64 << 52)"
      ],
      "ensures_clauses": [
        "(x as u128) * (y as u128) < (1u128 << 104)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_52_52().",
      "source": "project"
    },
    {
      "name": "lemma_as_bytes_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 144,
      "documentation": "Core lemma: proves that packing 52-bit limbs into bytes preserves the value\nNow using non-recursive specification functions (like field_verus.rs does)\n\nThis follows the same proof strategy as lemma_limbs_to_bytes from field_lemmas,\nbut adapted for 52-bit limbs instead of 51-bit limbs.",
      "signature": "pub fn lemma_as_bytes_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "u8_32_as_nat (& bytes) == five_limbs_to_nat_aux (limbs) % pow2 (256)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_as_bytes_52().",
      "source": "project"
    },
    {
      "name": "lemma_add_loop_bounds",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 297,
      "documentation": "",
      "signature": "pub fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)",
      "requires_clauses": [
        "0 <= i < 5",
        "a_limb < (1u64 << 52)",
        "b_limb < (1u64 << 52)",
        "i == 0 ==> carry == 0",
        "i >= 1 ==> (carry >> 52) < 2"
      ],
      "ensures_clauses": [
        "(carry >> 52) + a_limb + b_limb < (1u64 << 53)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_bounds().",
      "source": "project"
    },
    {
      "name": "lemma_add_loop_invariant",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1384,
      "documentation": "Proves that the addition loop maintains its invariant:\na[0..i+1] + b[0..i+1] == sum[0..i+1] + (carry >> 52) * 2^(52*(i+1))\nSee lemma_sub_loop1_invariant for more comments",
      "signature": "pub fn lemma_add_loop_invariant(sum: Scalar52, carry: u64, i: usize, a: &Scalar52, b: &Scalar52, old_carry: u64, mask: u64, sum_loop_start: Scalar52)",
      "requires_clauses": [
        "limbs_bounded (a)",
        "limbs_bounded (b)",
        "0 <= i < 5",
        "forall | j : int | 0 <= j < i ==> sum . limbs [j] < (1u64 << 52)",
        "mask == (1u64 << 52) - 1",
        "seq_u64_to_nat (a . limbs @ . subrange (0 , i as int)) + seq_u64_to_nat (b . limbs @ . subrange (0 , i as int) ,) == seq_u64_to_nat (sum_loop_start . limbs @ . subrange (0 , i as int)) + (old_carry >> 52) * pow2 ((52 * (i) as nat) ,)",
        "sum_loop_start . limbs @ . subrange (0 , i as int) == sum . limbs @ . subrange (0 , i as int)",
        "sum . limbs [i as int] == carry & mask",
        "carry == a . limbs [i as int] + b . limbs [i as int] + (old_carry >> 52)"
      ],
      "ensures_clauses": [
        "seq_u64_to_nat (sum . limbs @ . subrange (0 , i + 1)) + (carry >> 52) * pow2 ((52 * (i + 1) as nat)) == seq_u64_to_nat (a . limbs @ . subrange (0 , i + 1)) + seq_u64_to_nat (b . limbs @ . subrange (0 , i + 1) ,)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_loop_invariant().",
      "source": "project"
    },
    {
      "name": "lemma_add_carry_and_sum_bounds",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 313,
      "documentation": "",
      "signature": "pub fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)",
      "requires_clauses": [
        "mask == (1u64 << 52) - 1",
        "carry < (1u64 << 53)"
      ],
      "ensures_clauses": [
        "(carry & mask) < (1u64 << 52)",
        "(carry >> 52) < 2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_carry_and_sum_bounds().",
      "source": "project"
    },
    {
      "name": "lemma_add_sum_simplify",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1489,
      "documentation": "Get rid of the subranges from the invariant statement.\nSince a and b are less than group order, we can show that carry >> 52\nhas to be 0, else the RHS is too large",
      "signature": "pub fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)",
      "requires_clauses": [
        "limbs_bounded (a)",
        "limbs_bounded (b)",
        "to_nat (& a . limbs) < group_order ()",
        "to_nat (& b . limbs) < group_order ()",
        "forall | j : int | 0 <= j < 5 ==> sum . limbs [j] < (1u64 << 52)",
        "(carry >> 52) < 2",
        "seq_u64_to_nat (a . limbs @ . subrange (0 , 5 as int)) + seq_u64_to_nat (b . limbs @ . subrange (0 , 5 as int) ,) == seq_u64_to_nat (sum . limbs @ . subrange (0 , 5 as int)) + (carry >> 52) as nat * pow2 ((52 * (5) as nat) ,)"
      ],
      "ensures_clauses": [
        "to_nat (& a . limbs) + to_nat (& b . limbs) == to_nat (& sum . limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_add_sum_simplify().",
      "source": "project"
    },
    {
      "name": "lemma_l_value_properties",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 334,
      "documentation": "",
      "signature": "pub fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)",
      "requires_clauses": [
        "l_value . limbs [0] == 0x0002631a5cf5d3ed",
        "l_value . limbs [1] == 0x000dea2f79cd6581",
        "l_value . limbs [2] == 0x000000000014def9",
        "l_value . limbs [3] == 0x0000000000000000",
        "l_value . limbs [4] == 0x0000100000000000",
        "forall | j : int | 0 <= j < 5 ==> sum . limbs [j] < (1u64 << 52)"
      ],
      "ensures_clauses": [
        "forall | j : int | 0 <= j < 5 ==> l_value . limbs [j] < (1u64 << 52)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_value_properties().",
      "source": "project"
    },
    {
      "name": "lemma_l_equals_group_order",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1008,
      "documentation": "Just a proof by computation",
      "signature": "pub(crate) fn lemma_l_equals_group_order()",
      "requires_clauses": [],
      "ensures_clauses": [
        "to_nat (& constants :: L . limbs) == group_order ()",
        "seq_u64_to_nat (constants :: L . limbs @ . subrange (0 , 5 as int)) == group_order ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_l_equals_group_order().",
      "source": "project"
    },
    {
      "name": "lemma_mod_sub_multiples_vanish",
      "file_path": "src/backend/serial/u64/scalar.rs",
      "line_number": null,
      "documentation": "Proof that subtracting the divisor from the dividend doesn't\nchange the remainder. Specifically, `(-m + b) % m == b % m`.",
      "signature": "pub fn lemma_mod_sub_multiples_vanish(b: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(- m + b) % m == # [trigger] (b % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "source": "project"
    },
    {
      "name": "lemma_scalar_subtract_no_overflow",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 230,
      "documentation": "",
      "signature": "pub fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)",
      "requires_clauses": [
        "i < 5",
        "difference_limb < (1u64 << 52)",
        "addend == 0 || addend == l_value . limbs [i as int]",
        "i == 0 ==> carry == 0",
        "i >= 1 ==> (carry >> 52) < 2",
        "l_value . limbs [0] == 0x0002631a5cf5d3ed",
        "l_value . limbs [1] == 0x000dea2f79cd6581",
        "l_value . limbs [2] == 0x000000000014def9",
        "l_value . limbs [3] == 0x0000000000000000",
        "l_value . limbs [4] == 0x0000100000000000"
      ],
      "ensures_clauses": [
        "(carry >> 52) + difference_limb + addend < (1u64 << 53)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_scalar_subtract_no_overflow().",
      "source": "project"
    },
    {
      "name": "lemma_carry_bounded_after_mask",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 276,
      "documentation": "",
      "signature": "pub fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)",
      "requires_clauses": [
        "mask == (1u64 << 52) - 1",
        "carry < (1u64 << 53)"
      ],
      "ensures_clauses": [
        "(carry & mask) < (1u64 << 52)",
        "(carry >> 52) <= 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_carry_bounded_after_mask().",
      "source": "project"
    },
    {
      "name": "lemma_sub_loop1_invariant",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 790,
      "documentation": "The loop invariant says that subtraction is correct if we only subtract\nthe first i items of each array, plus there's a borrow term.\nThe first parts of the calc statement expand using the previous invariant.\nThen we have cases depending if the wrapping_sub wrapped.\nIf it didn't wrap, we show that borrow must be small, and borrow >> 52 == 0.\nIf it did wrap, we show that borrow is so large that its bit-shifts are all\nthe maximum amount.\nEither way, we then use the preconditions about what was mutated,\nand shuffle around the powers of 52.",
      "signature": "pub fn lemma_sub_loop1_invariant(difference: Scalar52, borrow: u64, i: usize, a: &Scalar52, b: &Scalar52, old_borrow: u64, mask: u64, difference_loop1_start: Scalar52)",
      "requires_clauses": [
        "limbs_bounded (a)",
        "limbs_bounded (b)",
        "0 <= i < 5",
        "forall | j : int | 0 <= j < i ==> difference . limbs [j] < (1u64 << 52)",
        "mask == (1u64 << 52) - 1",
        "seq_u64_to_nat (a . limbs @ . subrange (0 , i as int)) - seq_u64_to_nat (b . limbs @ . subrange (0 , i as int) ,) == seq_u64_to_nat (difference_loop1_start . limbs @ . subrange (0 , i as int)) - (old_borrow >> 63) * pow2 ((52 * (i) as nat))",
        "difference_loop1_start . limbs @ . subrange (0 , i as int) == difference . limbs @ . subrange (0 , i as int ,)",
        "difference . limbs [i as int] == borrow & mask",
        "borrow == a . limbs [i as int] . wrapping_sub ((b . limbs [i as int] + (old_borrow >> 63)) as u64)"
      ],
      "ensures_clauses": [
        "seq_u64_to_nat (difference . limbs @ . subrange (0 , i + 1)) - (borrow >> 63) * pow2 ((52 * (i + 1) as nat) ,) == seq_u64_to_nat (a . limbs @ . subrange (0 , i + 1)) - seq_u64_to_nat (b . limbs @ . subrange (0 , i + 1) ,)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop1_invariant().",
      "source": "project"
    },
    {
      "name": "lemma_borrow_and_mask_bounded",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 267,
      "documentation": "",
      "signature": "pub fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)",
      "requires_clauses": [
        "mask == (1u64 << 52) - 1"
      ],
      "ensures_clauses": [
        "(borrow & mask) < (1u64 << 52)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_borrow_and_mask_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_sub_loop2_invariant",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1224,
      "documentation": "If borrow >> 63 == 0, we just prove that the loop step has no effect.\nIf borrow >> 63 == 1, we substitute in the loop's updates\nlike `difference.limbs[i as int] == carry & mask`.\nIn that case we're proving that subtraction is correct if we only\nconsider the first i items of each array, except there's also a\n`(carry >> 52) * pow2(52 * (i+1) as nat)` term that doesn't go away.",
      "signature": "pub(crate) fn lemma_sub_loop2_invariant(difference: Scalar52, i: usize, a: &Scalar52, b: &Scalar52, mask: u64, difference_after_loop1: Scalar52, difference_loop2_start: Scalar52, carry: u64, old_carry: u64, addend: u64, borrow: u64)",
      "requires_clauses": [
        "0 <= i < 5",
        "mask == (1u64 << 52) - 1",
        "forall | j : int | 0 <= j < 5 ==> difference_loop2_start . limbs [j] < (1u64 << 52)",
        "forall | j : int | i <= j < 5 ==> difference_loop2_start . limbs [j] == difference_after_loop1 . limbs [j]",
        "forall | j : int | (0 <= j < 5 && j != i) ==> difference_loop2_start . limbs [j] == difference . limbs [j]",
        "mask == (1u64 << 52) - 1",
        "i == 0 ==> old_carry == 0",
        "i >= 1 ==> (old_carry >> 52) < 2",
        "(i >= 1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start . limbs [i - 1]",
        "borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start",
        "borrow >> 63 == 1 ==> seq_u64_to_nat (difference_after_loop1 . limbs @ . subrange (0 , i as int)) + seq_u64_to_nat (constants :: L . limbs @ . subrange (0 , i as int)) == seq_u64_to_nat (difference_loop2_start . limbs @ . subrange (0 , i as int) ,) + (old_carry >> 52) * pow2 (52 * i as nat)",
        "difference . limbs [i as int] == carry & mask",
        "difference_loop2_start . limbs @ . subrange (0 , i as int) == difference . limbs @ . subrange (0 , i as int ,)",
        "borrow >> 63 == 0 ==> addend == 0",
        "borrow >> 63 == 1 ==> addend == constants :: L . limbs [i as int]",
        "carry == (old_carry >> 52) + difference_loop2_start . limbs [i as int] + addend"
      ],
      "ensures_clauses": [
        "(i + 1 >= 1 && borrow >> 63 == 0) ==> carry == difference . limbs [i as int]",
        "borrow >> 63 == 0 ==> difference_after_loop1 == difference",
        "borrow >> 63 == 1 ==> seq_u64_to_nat (difference_after_loop1 . limbs @ . subrange (0 , i + 1 as int) ,) + seq_u64_to_nat (constants :: L . limbs @ . subrange (0 , i + 1 as int)) == seq_u64_to_nat (difference . limbs @ . subrange (0 , i + 1 as int) ,) + (carry >> 52) * pow2 (52 * (i + 1) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_loop2_invariant().",
      "source": "project"
    },
    {
      "name": "lemma_sub_correct_after_loops",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1066,
      "documentation": "If borrow >> 63 == 0, we apply\n(1) `-group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()`,\nand that's enough to show that to_nat(&difference.limbs) is between\n0 and group order.\nIf borrow >> 63 == 1, we apply (1) to show that carry >> 52 can't be 0.\nThis makes the excess terms in the borrow >> 63 == 1 precondition disappear",
      "signature": "pub(crate) fn lemma_sub_correct_after_loops(difference: Scalar52, carry: u64, a: &Scalar52, b: &Scalar52, difference_after_loop1: Scalar52, borrow: u64)",
      "requires_clauses": [
        "limbs_bounded (a)",
        "limbs_bounded (b)",
        "limbs_bounded (& difference)",
        "limbs_bounded (& difference_after_loop1)",
        "(carry >> 52) < 2",
        "- group_order () <= to_nat (& a . limbs) - to_nat (& b . limbs) < group_order ()",
        "borrow >> 63 == 0 ==> difference_after_loop1 == difference",
        "borrow >> 63 == 1 ==> seq_u64_to_nat (difference_after_loop1 . limbs @ . subrange (0 , 5 as int)) + seq_u64_to_nat (constants :: L . limbs @ . subrange (0 , 5 as int)) == seq_u64_to_nat (difference . limbs @ . subrange (0 , 5 as int) ,) + (carry >> 52) * pow2 (52 * 5 as nat)",
        "seq_u64_to_nat (a . limbs @ . subrange (0 , 5 as int)) - seq_u64_to_nat (b . limbs @ . subrange (0 , 5 as int) ,) == seq_u64_to_nat (difference_after_loop1 . limbs @ . subrange (0 , 5 as int)) - (borrow >> 63) * pow2 ((52 * (5) as nat))"
      ],
      "ensures_clauses": [
        "to_nat (& difference . limbs) == (to_nat (& a . limbs) - to_nat (& b . limbs)) % (group_order () as int)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_sub_correct_after_loops().",
      "source": "project"
    },
    {
      "name": "lemma_mul_internal_no_overflow",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 119,
      "documentation": "",
      "signature": "pub fn lemma_mul_internal_no_overflow()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(1u128 << 104) + (1u128 << 104) == (1u128 << 105)",
        "3u128 * (1u128 << 104) < (1u128 << 106)",
        "4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)",
        "(1u128 << 2) * (1u128 << 104) == (1u128 << 106)",
        "8u128 == (1u128 << 3)",
        "(1u128 << 3) * (1u128 << 104) == (1u128 << 107)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_no_overflow().",
      "source": "project"
    },
    {
      "name": "lemma_mul_internal_correct",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 136,
      "documentation": "",
      "signature": "pub fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> a [i] < (1u64 << 52)",
        "forall | i : int | 0 <= i < 5 ==> b [i] < (1u64 << 52)",
        "z [0] == (a [0] * b [0])",
        "z [1] == (a [0] * b [1]) + (a [1] * b [0])",
        "z [2] == (a [0] * b [2]) + (a [1] * b [1]) + (a [2] * b [0])",
        "z [3] == (a [0] * b [3]) + (a [1] * b [2]) + (a [2] * b [1]) + (a [3] * b [0])",
        "z [4] == (a [0] * b [4]) + (a [1] * b [3]) + (a [2] * b [2]) + (a [3] * b [1]) + (a [4] * b [0])",
        "z [5] == (a [1] * b [4]) + (a [2] * b [3]) + (a [3] * b [2]) + (a [4] * b [1])",
        "z [6] == (a [2] * b [4]) + (a [3] * b [3]) + (a [4] * b [2])",
        "z [7] == (a [3] * b [4]) + (a [4] * b [3])",
        "z [8] == (a [4] * b [4])"
      ],
      "ensures_clauses": [
        "slice128_to_nat (z) == to_nat (a) * to_nat (b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mul_internal_correct().",
      "source": "project"
    },
    {
      "name": "lemma_square_internal_no_overflow",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 72,
      "documentation": "",
      "signature": "pub fn lemma_square_internal_no_overflow()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(1u128 << 105) + (1u128 << 105) == (1u128 << 106)",
        "(1u128 << 105) + (1u128 << 104) < (1u128 << 106)",
        "(1u128 << 104) * 2 == (1u128 << 105)",
        "(1u128 << 106) + (1u128 << 104) < (1u128 << 107)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_no_overflow().",
      "source": "project"
    },
    {
      "name": "lemma_square_internal_correct",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 85,
      "documentation": "",
      "signature": "pub fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> a [i] < (1u64 << 52)",
        "z [0] == (a [0] * a [0])",
        "z [1] == (a [0] * a [1]) * 2",
        "z [2] == (a [0] * a [2]) * 2 + (a [1] * a [1])",
        "z [3] == (a [0] * a [3]) * 2 + (a [1] * a [2]) * 2",
        "z [4] == (a [0] * a [4]) * 2 + (a [1] * a [3]) * 2 + (a [2] * a [2])",
        "z [5] == (a [1] * a [4]) * 2 + (a [2] * a [3]) * 2",
        "z [6] == (a [2] * a [4]) * 2 + (a [3] * a [3])",
        "z [7] == (a [3] * a [4]) * 2",
        "z [8] == (a [4] * a [4])"
      ],
      "ensures_clauses": [
        "slice128_to_nat (z) == to_nat (a) * to_nat (a)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_square_internal_correct().",
      "source": "project"
    },
    {
      "name": "lemma_rr_limbs_bounded",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 367,
      "documentation": "",
      "signature": "pub fn lemma_rr_limbs_bounded()",
      "requires_clauses": [],
      "ensures_clauses": [
        "0x000d63c715bea69fu64 < (1u64 << 52)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_limbs_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_rr_equals_spec",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 500,
      "documentation": "",
      "signature": "pub(crate) fn lemma_rr_equals_spec(rr: Scalar52)",
      "requires_clauses": [
        "rr == (Scalar52 { limbs : [0x0009d265e952d13b , 0x000d63c715bea69f , 0x0005be65cb687604 , 0x0003dceec73d217f , 0x000009411b7c309a ,] , })"
      ],
      "ensures_clauses": [
        "to_nat (& rr . limbs) % group_order () == (montgomery_radix () * montgomery_radix ()) % group_order ()",
        "to_nat (& rr . limbs) < group_order ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_rr_equals_spec().",
      "source": "project"
    },
    {
      "name": "lemma_cancel_mul_montgomery_mod",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 375,
      "documentation": "",
      "signature": "pub fn lemma_cancel_mul_montgomery_mod(x: nat, a: nat, rr: nat)",
      "requires_clauses": [
        "((x * montgomery_radix ()) % group_order ()) == ((a * rr) % group_order ())",
        "(rr % group_order ()) == ((montgomery_radix () * montgomery_radix ()) % group_order ())",
        "group_order () > 0"
      ],
      "ensures_clauses": [
        "(x % group_order ()) == ((a * montgomery_radix ()) % group_order ())"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_cancel_mul_montgomery_mod().",
      "source": "project"
    },
    {
      "name": "lemma_rr_equals_radix_squared",
      "file_path": "src/lemmas/montgomery_lemmas.rs",
      "line_number": 21,
      "documentation": "Proves that the precomputed RR constant equals R\u00b2 mod L\n\nIn Montgomery arithmetic, RR is precomputed as R\u00b2 mod L where:\n- R = montgomery_radix() = 2^260\n- L = group_order() (the curve order)\n\nThis lemma verifies the precomputed constant is correct by showing:\n  to_nat(RR.limbs) % L == (R * R) % L",
      "signature": "pub(crate) fn lemma_rr_equals_radix_squared()",
      "requires_clauses": [],
      "ensures_clauses": [
        "to_nat (& constants :: RR . limbs) % group_order () == (montgomery_radix () * montgomery_radix ()) % group_order ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 montgomery_lemmas/lemmas/lemma_rr_equals_radix_squared().",
      "source": "project"
    },
    {
      "name": "lemma_from_montgomery_limbs_conversion",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 349,
      "documentation": "",
      "signature": "pub fn lemma_from_montgomery_limbs_conversion(limbs: &[u128; 9], self_limbs: &[u64; 5])",
      "requires_clauses": [
        "forall | j : int | # ! [auto] 0 <= j < 5 ==> limbs [j] == self_limbs [j] as u128",
        "forall | j : int | 5 <= j < 9 ==> limbs [j] == 0"
      ],
      "ensures_clauses": [
        "slice128_to_nat (limbs) == to_nat (self_limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_from_montgomery_limbs_conversion().",
      "source": "project"
    },
    {
      "name": "lemma_bitwise_or_r_zero_is_id",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": 14,
      "documentation": "",
      "signature": "pub fn lemma_bitwise_or_r_zero_is_id(a: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "a | 0 == a"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_r_zero_is_id().",
      "source": "project"
    },
    {
      "name": "lemma_bitwise_or_l_zero_is_id",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": 21,
      "documentation": "",
      "signature": "pub fn lemma_bitwise_or_l_zero_is_id(a: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 | a == a"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitwise_or_l_zero_is_id().",
      "source": "project"
    },
    {
      "name": "lemma_bit_or_is_plus",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": 28,
      "documentation": "",
      "signature": "pub fn lemma_bit_or_is_plus(a: u64, b: u64, k: u64)",
      "requires_clauses": [
        "b <= (u64 :: MAX >> k)",
        "a < 1u64 << k"
      ],
      "ensures_clauses": [
        "a | (b << k) == a + (b << k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bit_or_is_plus().",
      "source": "project"
    },
    {
      "name": "lemma_bitops",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": 38,
      "documentation": "",
      "signature": "pub fn lemma_bitops(a: u64, b: u64, c: u64)",
      "requires_clauses": [
        "c < 64"
      ],
      "ensures_clauses": [
        "(a | b) >> c == (a >> c) | (b >> c)",
        "(a | b) & (low_bits_mask (c as nat) as u64) == (a & (low_bits_mask (c as nat) as u64)) | (b & (low_bits_mask (c as nat) as u64))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops().",
      "source": "project"
    },
    {
      "name": "lemma_low_bits_masks_fit_u64",
      "file_path": "src/lemmas/common_lemmas/mask_lemmas.rs",
      "line_number": 54,
      "documentation": "",
      "signature": "pub fn lemma_low_bits_masks_fit_u64(k: nat)",
      "requires_clauses": [
        "k <= 64"
      ],
      "ensures_clauses": [
        "low_bits_mask (k) <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_masks_fit_u64().",
      "source": "project"
    },
    {
      "name": "lemma_bitops_lifted",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": 54,
      "documentation": "",
      "signature": "pub fn lemma_bitops_lifted(a: u64, b: u64, s: nat, k: nat)",
      "requires_clauses": [
        "a < pow2 (s)",
        "a + b * pow2 (s) <= u64 :: MAX",
        "s < 64",
        "k < 64"
      ],
      "ensures_clauses": [
        "(a + b * pow2 (s)) as nat / pow2 (k) == (a as nat) / pow2 (k) + (b * pow2 (s)) as nat / pow2 (k)",
        "(a + b * pow2 (s)) as nat % pow2 (k) == (a as nat) % pow2 (k) + (b * pow2 (s)) as nat % pow2 (k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 bit_lemmas/common_lemmas/lemmas/lemma_bitops_lifted().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_le_max64",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 25,
      "documentation": "",
      "signature": "pub fn lemma_pow2_le_max64(k: nat)",
      "requires_clauses": [
        "k < 64"
      ],
      "ensures_clauses": [
        "pow2 (k) <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_le_max64().",
      "source": "project"
    },
    {
      "name": "lemma_left_right_shift",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 263,
      "documentation": "",
      "signature": "pub fn lemma_left_right_shift(v: u64, sl: u64, sr: u64)",
      "requires_clauses": [
        "sr <= sl < 64",
        "v * pow2 (sl as nat) <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "(v << sl) >> sr == v << (sl - sr)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_left_right_shift().",
      "source": "project"
    },
    {
      "name": "lemma_shl_zero_is_id",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 25,
      "documentation": "",
      "signature": "pub fn lemma_shl_zero_is_id(v: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "v << 0 == v"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_zero_is_id().",
      "source": "project"
    },
    {
      "name": "lemma_shift_is_pow2",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 14,
      "documentation": "",
      "signature": "pub fn lemma_shift_is_pow2(k: nat)",
      "requires_clauses": [
        "k < 64"
      ],
      "ensures_clauses": [
        "(1u64 << k) == pow2 (k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shift_is_pow2().",
      "source": "project"
    },
    {
      "name": "lemma_shr_nonincreasing",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 184,
      "documentation": "",
      "signature": "pub fn lemma_shr_nonincreasing(v: u64, a: nat, b: nat)",
      "requires_clauses": [
        "a <= b <= 64"
      ],
      "ensures_clauses": [
        "v >> b <= v >> a"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_nonincreasing().",
      "source": "project"
    },
    {
      "name": "lemma_multiply_divide_lt",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that if an integer is less than the product of two other\nintegers, then the quotient with one of them will be less than the\nother. Specifically, because `a < b * c`, we know `a / b < c`.",
      "signature": "pub fn lemma_multiply_divide_lt(a: int, b: int, c: int)",
      "requires_clauses": [
        "0 < b",
        "a < b * c"
      ],
      "ensures_clauses": [
        "a / b < c"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "source": "project"
    },
    {
      "name": "lemma_basic_div",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that dividing any non-negative integer by a larger integer\nproduces a quotient of 0.",
      "signature": "pub fn lemma_basic_div(x: int, d: int)",
      "requires_clauses": [
        "0 <= x < d"
      ],
      "ensures_clauses": [
        "# [trigger] (x / d) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_basic_div().",
      "source": "project"
    },
    {
      "name": "lemma_mul_is_commutative",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplication is commutative, specifically that\n`x * y == y * x`.",
      "signature": "pub fn lemma_mul_is_commutative(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) == y * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "source": "project"
    },
    {
      "name": "lemma_mod_multiples_basic",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplying by a number then dividing by that same\nnumber produces a remainder of 0. Specifically, `(x * m) % m == 0`.",
      "signature": "pub fn lemma_mod_multiples_basic(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] ((x * m) % m) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_mod",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 294,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_mod(x: nat, k: nat, s: nat)",
      "requires_clauses": [
        "k <= s"
      ],
      "ensures_clauses": [
        "(x * pow2 (k)) % pow2 (s) == (x % pow2 ((s - k) as nat)) * pow2 (k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_mod().",
      "source": "project"
    },
    {
      "name": "lemma_mod_decreases",
      "file_path": "src/lemmas/common_lemmas/bit_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that when natural number `x` is divided by natural number\n`m`, the remainder will be less than or equal to `x`.",
      "signature": "pub fn lemma_mod_decreases(x: nat, m: nat)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "# [trigger] (x % m) <= x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_decreases().",
      "source": "project"
    },
    {
      "name": "lemma_div_and_mod",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 10,
      "documentation": "",
      "signature": "pub fn lemma_div_and_mod(ai: u64, bi: u64, v: u64, k: nat)",
      "requires_clauses": [
        "k < 64",
        "ai == v >> k",
        "bi == v & (low_bits_mask (k) as u64)"
      ],
      "ensures_clauses": [
        "ai == v / (pow2 (k) as u64)",
        "bi == v % (pow2 (k) as u64)",
        "v == ai * pow2 (k) + bi"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_and_mod().",
      "source": "project"
    },
    {
      "name": "lemma_fundamental_div_mod",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof of the fundamental theorem of division and modulo, namely\nthat `x` can be expressed as `d` times the quotient `x / d` plus\nthe remainder `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod(x: int, d: int)",
      "requires_clauses": [
        "d != 0"
      ],
      "ensures_clauses": [
        "x == d * (x / d) + (x % d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "source": "project"
    },
    {
      "name": "lemma_add_mod_noop",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that modulo distributes over addition, provided you do an\nextra modulo after adding the remainders. Specifically,\n`((x % m) + (y % m)) % m == (x + y) % m`.",
      "signature": "pub fn lemma_add_mod_noop(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "((x % m) + (y % m)) % m == (x + y) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "source": "project"
    },
    {
      "name": "lemma_mod_diff_factor",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 56,
      "documentation": "",
      "signature": "pub fn lemma_mod_diff_factor(a: int, b: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "(b - a * m) % m == b % m"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_diff_factor().",
      "source": "project"
    },
    {
      "name": "lemma_div_of_sum",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 70,
      "documentation": "",
      "signature": "pub fn lemma_div_of_sum(a: nat, b: nat, k: nat)",
      "requires_clauses": [
        "(a % k) + (b % k) < k"
      ],
      "ensures_clauses": [
        "(a + b) / k == a / k + b / k"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_of_sum().",
      "source": "project"
    },
    {
      "name": "lemma_mul_is_distributive_add",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplication distributes over addition, specifically that\n`x * (y + z) == x * y + x * z`.",
      "signature": "pub fn lemma_mul_is_distributive_add(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x * (y + z) == x * y + x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "source": "project"
    },
    {
      "name": "lemma_div_multiples_vanish_fancy",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that, since `0 <= b < d`, we have `(d * x + b) / d == x`.",
      "signature": "pub fn lemma_div_multiples_vanish_fancy(x: int, b: int, d: int)",
      "requires_clauses": [
        "0 < d",
        "0 <= b < d"
      ],
      "ensures_clauses": [
        "(d * x + b) / d == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "source": "project"
    },
    {
      "name": "lemma_div_strictly_bounded",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 97,
      "documentation": "Helper lemma: Division with strict upper bound\nIf x < a * b and a > 0, then x / a < b",
      "signature": "pub fn lemma_div_strictly_bounded(x: int, a: int, b: int)",
      "requires_clauses": [
        "a > 0",
        "b >= 0",
        "x < a * b"
      ],
      "ensures_clauses": [
        "x / a < b"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_div_strictly_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_div_by_multiple",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplying a whole number by a common numerator and\ndenominator results in the original integer. Specifically,\n`(b * d) / d == b`.",
      "signature": "pub fn lemma_div_by_multiple(b: int, d: int)",
      "requires_clauses": [
        "0 <= b",
        "0 < d"
      ],
      "ensures_clauses": [
        "(b * d) / d == b"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "source": "project"
    },
    {
      "name": "lemma_div_by_multiple_is_strongly_ordered",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that a dividend that is a positive multiple of a divisor\nwill always yield a greater quotient than a smaller dividend.\nSpecifically, `x / z < y / z` because `y == m * z` and `x < y`.",
      "signature": "pub fn lemma_div_by_multiple_is_strongly_ordered(x: int, y: int, m: int, z: int)",
      "requires_clauses": [
        "x < y",
        "y == m * z",
        "0 < z"
      ],
      "ensures_clauses": [
        "x / z < y / z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "source": "project"
    },
    {
      "name": "lemma_mul_le_implies_div_le",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 112,
      "documentation": "Helper lemma: if a * b <= c and b > 0, then a <= c / b",
      "signature": "pub fn lemma_mul_le_implies_div_le(a: nat, b: nat, c: nat)",
      "requires_clauses": [
        "b > 0",
        "a * b <= c"
      ],
      "ensures_clauses": [
        "a <= c / b"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mul_le_implies_div_le().",
      "source": "project"
    },
    {
      "name": "lemma_div_is_ordered",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that numerical order is preserved when dividing two seperate\nintegers by a common positive divisor. Specifically, given that\n`z > 0` and `x <= y`, we know `x / z <= y / z`.",
      "signature": "pub fn lemma_div_is_ordered(x: int, y: int, z: int)",
      "requires_clauses": [
        "x <= y",
        "0 < z"
      ],
      "ensures_clauses": [
        "# [trigger] (x / z) <= # [trigger] (y / z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "source": "project"
    },
    {
      "name": "lemma_u8_cast_is_mod_256",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 123,
      "documentation": "",
      "signature": "pub fn lemma_u8_cast_is_mod_256(x: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(x as u8) == (x as nat) % 256"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_u8_cast_is_mod_256().",
      "source": "project"
    },
    {
      "name": "lemma_mod_sum_both_divisible",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 135,
      "documentation": "Helper: Sum of two numbers both divisible by d is divisible by d\n\nMathematical property: Closure of divisibility under addition\nIf d | a and d | b, then d | (a + b)",
      "signature": "pub fn lemma_mod_sum_both_divisible(a: nat, b: nat, d: nat)",
      "requires_clauses": [
        "d > 0",
        "a % d == 0",
        "b % d == 0"
      ],
      "ensures_clauses": [
        "(a + b) % d == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_mod_sum_both_divisible().",
      "source": "project"
    },
    {
      "name": "lemma_divisibility_factor",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 158,
      "documentation": "Helper: Divisibility factorization\n\nIf n is divisible by (a\u00b7b), then (n/a) is divisible by b.\n\nMathematical property: Divisibility distribution across division",
      "signature": "pub fn lemma_divisibility_factor(n: nat, a: nat, b: nat)",
      "requires_clauses": [
        "n % (a * b) == 0",
        "a > 0",
        "b > 0"
      ],
      "ensures_clauses": [
        "(n / a) % b == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_divisibility_factor().",
      "source": "project"
    },
    {
      "name": "lemma_mod_breakdown",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof of the validity of an expanded form of the modulus operation.\nSpecifically, `x % (y * z) == y * ((x / y) % z) + x % y`.",
      "signature": "pub fn lemma_mod_breakdown(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < y",
        "0 < z"
      ],
      "ensures_clauses": [
        "y * z > 0",
        "x % (y * z) == y * ((x / y) % z) + x % y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_breakdown().",
      "source": "project"
    },
    {
      "name": "lemma_int_nat_mod_equiv",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": 187,
      "documentation": "Lemma: int modulo and nat modulo are equivalent for non-negative values\n\nFor v >= 0 and m > 0, computing v % m gives the same result whether\nwe use int modulo or nat modulo operations.\n\nThis bridges the type-level gap between `int % int` and `nat % nat`.",
      "signature": "pub fn lemma_int_nat_mod_equiv(v: int, m: nat)",
      "requires_clauses": [
        "v >= 0",
        "m > 0"
      ],
      "ensures_clauses": [
        "v % (m as int) == ((v as nat) % m) as int"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 div_mod_lemmas/common_lemmas/lemmas/lemma_int_nat_mod_equiv().",
      "source": "project"
    },
    {
      "name": "lemma_fundamental_div_mod_converse_mod",
      "file_path": "src/lemmas/common_lemmas/div_mod_lemmas.rs",
      "line_number": null,
      "documentation": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `r` is the remainder `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod_converse_mod(x: int, d: int, q: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d",
        "x == # [trigger] (q * d + r)"
      ],
      "ensures_clauses": [
        "r == # [trigger] (x % d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_mod().",
      "source": "project"
    },
    {
      "name": "lemma_masked_lt",
      "file_path": "src/lemmas/common_lemmas/mask_lemmas.rs",
      "line_number": 13,
      "documentation": "",
      "signature": "pub fn lemma_masked_lt(v: u64, k: nat)",
      "requires_clauses": [
        "0 <= k < 64"
      ],
      "ensures_clauses": [
        "v & (low_bits_mask (k) as u64) < (1u64 << k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_masked_lt().",
      "source": "project"
    },
    {
      "name": "lemma_low_bits_mask_increases",
      "file_path": "src/lemmas/common_lemmas/mask_lemmas.rs",
      "line_number": 30,
      "documentation": "",
      "signature": "pub fn lemma_low_bits_mask_increases(a: nat, b: nat)",
      "requires_clauses": [
        "a < b"
      ],
      "ensures_clauses": [
        "low_bits_mask (a) < low_bits_mask (b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mask_lemmas/common_lemmas/lemmas/lemma_low_bits_mask_increases().",
      "source": "project"
    },
    {
      "name": "lemma_low_bits_mask_values",
      "file_path": "src/lemmas/common_lemmas/mask_lemmas.rs",
      "line_number": null,
      "documentation": "Proof establishing the concrete values of all masks of bit sizes from 0 to\n32, and 64.",
      "signature": "pub fn lemma_low_bits_mask_values()",
      "requires_clauses": [],
      "ensures_clauses": [
        "low_bits_mask (0) == 0x0",
        "low_bits_mask (1) == 0x1",
        "low_bits_mask (2) == 0x3",
        "low_bits_mask (3) == 0x7",
        "low_bits_mask (4) == 0xf",
        "low_bits_mask (5) == 0x1f",
        "low_bits_mask (6) == 0x3f",
        "low_bits_mask (7) == 0x7f",
        "low_bits_mask (8) == 0xff",
        "low_bits_mask (9) == 0x1ff",
        "low_bits_mask (10) == 0x3ff",
        "low_bits_mask (11) == 0x7ff",
        "low_bits_mask (12) == 0xfff",
        "low_bits_mask (13) == 0x1fff",
        "low_bits_mask (14) == 0x3fff",
        "low_bits_mask (15) == 0x7fff",
        "low_bits_mask (16) == 0xffff",
        "low_bits_mask (17) == 0x1ffff",
        "low_bits_mask (18) == 0x3ffff",
        "low_bits_mask (19) == 0x7ffff",
        "low_bits_mask (20) == 0xfffff",
        "low_bits_mask (21) == 0x1fffff",
        "low_bits_mask (22) == 0x3fffff",
        "low_bits_mask (23) == 0x7fffff",
        "low_bits_mask (24) == 0xffffff",
        "low_bits_mask (25) == 0x1ffffff",
        "low_bits_mask (26) == 0x3ffffff",
        "low_bits_mask (27) == 0x7ffffff",
        "low_bits_mask (28) == 0xfffffff",
        "low_bits_mask (29) == 0x1fffffff",
        "low_bits_mask (30) == 0x3fffffff",
        "low_bits_mask (31) == 0x7fffffff",
        "low_bits_mask (32) == 0xffffffff",
        "low_bits_mask (64) == 0xffffffffffffffff"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_values().",
      "source": "project"
    },
    {
      "name": "lemma_low_bits_mask_unfold",
      "file_path": "src/lemmas/common_lemmas/mask_lemmas.rs",
      "line_number": null,
      "documentation": "Proof relating the n-bit mask to a function of the (n-1)-bit mask.",
      "signature": "pub fn lemma_low_bits_mask_unfold(n: nat)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "# [trigger] low_bits_mask (n) == 2 * low_bits_mask ((n - 1) as nat) + 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_unfold().",
      "source": "project"
    },
    {
      "name": "lemma_low_bits_mask_div2",
      "file_path": "src/lemmas/common_lemmas/mask_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that dividing the low n bit mask by 2 gives the low n-1 bit mask.",
      "signature": "pub fn lemma_low_bits_mask_div2(n: nat)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (low_bits_mask (n) / 2) == low_bits_mask ((n - 1) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 bits/lemma_low_bits_mask_div2().",
      "source": "project"
    },
    {
      "name": "lemma_sum_bounds",
      "file_path": "src/lemmas/common_lemmas/sum_lemmas.rs",
      "line_number": 28,
      "documentation": "",
      "signature": "pub fn lemma_sum_bounds(coefs: Seq<nat>, k: nat, s: nat)",
      "requires_clauses": [
        "k <= coefs . len ()",
        "forall | i : nat | 0 <= i <= k ==> # [trigger] coefs [i as int] <= pow2 ((i + 1) * s) - pow2 (i * s)"
      ],
      "ensures_clauses": [
        "seq_sum (coefs , k) <= pow2 ((k + 1) * s) - 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 sum_lemmas/common_lemmas/lemmas/lemma_sum_bounds().",
      "source": "project"
    },
    {
      "name": "lemma_mul_is_distributive_add_other_way",
      "file_path": "src/lemmas/common_lemmas/sum_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplication distributes over addition, specifically that\n`(y + z) * x == y * x + z * x`.",
      "signature": "pub fn lemma_mul_is_distributive_add_other_way(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] ((y + z) * x) == y * x + z * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "source": "project"
    },
    {
      "name": "lemma_mul_strictly_positive",
      "file_path": "src/lemmas/common_lemmas/sum_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplication distributes over addition and\nsubtraction, whether the addition or subtraction happens in the\nfirst or the second argument to the multiplication.\nProof that if `x` and `y` are both positive, then their product is\nalso positive.",
      "signature": "pub fn lemma_mul_strictly_positive(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(0 < x && 0 < y) ==> (0 < x * y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "source": "project"
    },
    {
      "name": "lemma_shl_by_sum",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 34,
      "documentation": "",
      "signature": "pub fn lemma_shl_by_sum(v: u64, a: nat, b: nat)",
      "requires_clauses": [
        "(a + b) < 64",
        "v * pow2 (a + b) <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "(v << (a + b)) == ((v << a) << b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_by_sum().",
      "source": "project"
    },
    {
      "name": "lemma_shl_le_u64",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 63,
      "documentation": "",
      "signature": "pub fn lemma_shl_le_u64(a: u64, b: u64, k: nat)",
      "requires_clauses": [
        "a <= b",
        "k < 64",
        "(b * pow2 (k)) <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "(a << k) <= (b << k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_le_u64().",
      "source": "project"
    },
    {
      "name": "lemma_shl_nondecreasing",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 77,
      "documentation": "",
      "signature": "pub fn lemma_shl_nondecreasing(v: u64, a: nat, b: nat)",
      "requires_clauses": [
        "a <= b < 64",
        "v * pow2 (b) <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "(v << a) <= (v << b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shl_nondecreasing().",
      "source": "project"
    },
    {
      "name": "lemma_shr_zero_is_id",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 127,
      "documentation": "",
      "signature": "pub fn lemma_shr_zero_is_id(v: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "v >> 0 == v"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_zero_is_id().",
      "source": "project"
    },
    {
      "name": "lemma_shr_by_sum",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 136,
      "documentation": "",
      "signature": "pub fn lemma_shr_by_sum(v: u64, a: nat, b: nat)",
      "requires_clauses": [
        "(a + b) < 64"
      ],
      "ensures_clauses": [
        "(v >> (a + b)) == ((v >> a) >> b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_by_sum().",
      "source": "project"
    },
    {
      "name": "lemma_div_denominator",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that dividing `x` by `c * d` is equivalent to first dividing\n`x` by `c` and then dividing the result by `d`.",
      "signature": "pub fn lemma_div_denominator(x: int, c: int, d: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < c",
        "0 < d"
      ],
      "ensures_clauses": [
        "c * d != 0",
        "# [trigger] ((x / c) / d) == x / (c * d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_denominator().",
      "source": "project"
    },
    {
      "name": "lemma_shr_le_u64",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 170,
      "documentation": "",
      "signature": "pub fn lemma_shr_le_u64(a: u64, b: u64, k: nat)",
      "requires_clauses": [
        "a <= b",
        "k < 64"
      ],
      "ensures_clauses": [
        "(a >> k) <= (b >> k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shr_le_u64().",
      "source": "project"
    },
    {
      "name": "lemma_u64_max_shifting",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 205,
      "documentation": "",
      "signature": "pub fn lemma_u64_max_shifting(k: nat)",
      "requires_clauses": [
        "1 <= k < 64"
      ],
      "ensures_clauses": [
        "u64 :: MAX >> k < 1u64 << (64 - k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_u64_max_shifting().",
      "source": "project"
    },
    {
      "name": "lemma_div_multiples_vanish",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplying an integer by a common numerator and\ndenominator results in the original integer. Specifically,\n`(d * x) / d == x`.",
      "signature": "pub fn lemma_div_multiples_vanish(x: int, d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "(d * x) / d == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "source": "project"
    },
    {
      "name": "lemma_shifted_lt",
      "file_path": "src/lemmas/common_lemmas/shift_lemmas.rs",
      "line_number": 305,
      "documentation": "",
      "signature": "pub fn lemma_shifted_lt(v: u64, k: nat)",
      "requires_clauses": [
        "1 <= k <= 64"
      ],
      "ensures_clauses": [
        "v >> k < 1u64 << (64 - k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 shift_lemmas/common_lemmas/lemmas/lemma_shifted_lt().",
      "source": "project"
    },
    {
      "name": "lemma_mul_lt",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 8,
      "documentation": "",
      "signature": "pub fn lemma_mul_lt(a1: nat, b1: nat, a2: nat, b2: nat)",
      "requires_clauses": [
        "a1 < b1",
        "a2 < b2"
      ],
      "ensures_clauses": [
        "a1 * a2 < b1 * b2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_lt().",
      "source": "project"
    },
    {
      "name": "lemma_mul_nonzero",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that `x * y` is nonzero if and only if both `x` and `y` are nonzero.",
      "signature": "pub fn lemma_mul_nonzero(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x * y != 0 <==> x != 0 && y != 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonzero().",
      "source": "project"
    },
    {
      "name": "lemma_m",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 42,
      "documentation": "",
      "signature": "pub fn lemma_m(x: u64, y: u64, bx: u64, by: u64)",
      "requires_clauses": [
        "x < bx",
        "y < by"
      ],
      "ensures_clauses": [
        "(x as u128) * (y as u128) < (bx as u128) * (by as u128)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_m().",
      "source": "project"
    },
    {
      "name": "lemma_mul_distributive_3_terms",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 52,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributive_3_terms(n: int, x1: int, x2: int, x3: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n * (x1 + x2 + x3) == (x1 + x2 + x3) * n == n * x1 + n * x2 + n * x3"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_3_terms().",
      "source": "project"
    },
    {
      "name": "lemma_mul_distributive_4_terms",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 69,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributive_4_terms(n: int, x1: int, x2: int, x3: int, x4: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n * (x1 + x2 + x3 + x4) == (x1 + x2 + x3 + x4) * n == n * x1 + n * x2 + n * x3 + n * x4"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_4_terms().",
      "source": "project"
    },
    {
      "name": "lemma_mul_distributive_5_terms",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 86,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributive_5_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n * (x1 + x2 + x3 + x4 + x5) == (x1 + x2 + x3 + x4 + x5) * n == n * x1 + n * x2 + n * x3 + n * x4 + n * x5"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_5_terms().",
      "source": "project"
    },
    {
      "name": "lemma_mul_distributive_6_terms",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 104,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributive_6_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int, x6: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n * (x1 + x2 + x3 + x4 + x5 + x6) == (x1 + x2 + x3 + x4 + x5 + x6) * n == n * x1 + n * x2 + n * x3 + n * x4 + n * x5 + n * x6"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_6_terms().",
      "source": "project"
    },
    {
      "name": "lemma_mul_distributive_7_terms",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 130,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributive_7_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int, x6: int, x7: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n * (x1 + x2 + x3 + x4 + x5 + x6 + x7) == (x1 + x2 + x3 + x4 + x5 + x6 + x7) * n == n * x1 + n * x2 + n * x3 + n * x4 + n * x5 + n * x6 + n * x7"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_7_terms().",
      "source": "project"
    },
    {
      "name": "lemma_mul_distributive_8_terms",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 159,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributive_8_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int, x6: int, x7: int, x8: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n * (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8) == (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8) * n == n * x1 + n * x2 + n * x3 + n * x4 + n * x5 + n * x6 + n * x7 + n * x8"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_distributive_8_terms().",
      "source": "project"
    },
    {
      "name": "lemma_mul_quad_prod",
      "file_path": "src/lemmas/common_lemmas/mul_lemmas.rs",
      "line_number": 190,
      "documentation": "",
      "signature": "pub fn lemma_mul_quad_prod(a1: int, b1: int, a2: int, b2: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(a1 * b1) * (a2 * b2) == (a1 * a2) * (b1 * b2)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 mul_lemmas/common_lemmas/lemmas/lemma_mul_quad_prod().",
      "source": "project"
    },
    {
      "name": "lemma_u8_lt_pow2_8",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 15,
      "documentation": "",
      "signature": "pub fn lemma_u8_lt_pow2_8(a: u8)",
      "requires_clauses": [],
      "ensures_clauses": [
        "a < pow2 (8)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_lt_pow2_8().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_plus_one",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 35,
      "documentation": "",
      "signature": "pub fn lemma_pow2_plus_one(n: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (n + 1) == pow2 (n) + pow2 (n)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_plus_one().",
      "source": "project"
    },
    {
      "name": "lemma_mul_basics_3",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
      "signature": "pub fn lemma_mul_basics_3(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * 1) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_3().",
      "source": "project"
    },
    {
      "name": "lemma_div_bound",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 52,
      "documentation": "Helper: Division bounds - if x < 2^b then x/2^a < 2^(b-a)",
      "signature": "pub fn lemma_div_bound(x: nat, a: nat, b: nat)",
      "requires_clauses": [
        "a <= b",
        "x < pow2 (b)"
      ],
      "ensures_clauses": [
        "x / pow2 (a) < pow2 ((b - a) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_bound().",
      "source": "project"
    },
    {
      "name": "lemma_two_factoring",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 69,
      "documentation": "",
      "signature": "pub fn lemma_two_factoring(a: nat, b: nat, v: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (a + b) * v == pow2 (a) * (pow2 (b) * v)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_two_factoring().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_square",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 78,
      "documentation": "",
      "signature": "pub fn lemma_pow2_square(v: int, i: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow (v , pow2 (i)) * pow (v , pow2 (i)) == pow (v , pow2 (i + 1))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_square().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_unfold",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof relating 2^e to 2^(e-1).",
      "signature": "pub fn lemma_pow2_unfold(e: nat)",
      "requires_clauses": [
        "e > 0"
      ],
      "ensures_clauses": [
        "# [trigger] pow2 (e) == 2 * pow2 ((e - 1) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_unfold().",
      "source": "project"
    },
    {
      "name": "lemma_pow_positive",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that taking the given positive integer `b` to the power of\nthe given natural number `n` produces a positive result.",
      "signature": "pub fn lemma_pow_positive(b: int, e: nat)",
      "requires_clauses": [
        "b > 0"
      ],
      "ensures_clauses": [
        "0 < # [trigger] pow (b , e)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_positive().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_bound_general",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 101,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_bound_general(a: nat, s: nat, k: nat)",
      "requires_clauses": [
        "a < pow2 (s)"
      ],
      "ensures_clauses": [
        "pow2 (k) * a <= pow2 (k + s) - pow2 (k)",
        "a * pow2 (k) <= pow2 (k + s) - pow2 (k)",
        "pow2 (k + s) - pow2 (k) < pow2 (k + s)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_general().",
      "source": "project"
    },
    {
      "name": "lemma_mul_is_distributive_sub",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplication distributes over subtraction, specifically that\n`x * (y - z) == x * y - x * z`.",
      "signature": "pub fn lemma_mul_is_distributive_sub(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * (y - z)) == x * y - x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_bound_u8",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 124,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_bound_u8(a: u8, k: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (k) * a <= pow2 (k + 8) - pow2 (k)",
        "a * pow2 (k) <= pow2 (k + 8) - pow2 (k)",
        "pow2 (k + 8) - pow2 (k) < pow2 (k + 8)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_bound_u8().",
      "source": "project"
    },
    {
      "name": "lemma_bindary_sum_div_decomposition",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 137,
      "documentation": "",
      "signature": "pub fn lemma_bindary_sum_div_decomposition(a: nat, b: nat, s: nat, k: nat)",
      "requires_clauses": [
        "a < pow2 (s)"
      ],
      "ensures_clauses": [
        "(a + b * pow2 (s)) / pow2 (k) == a / pow2 (k) + (b * pow2 (s)) / pow2 (k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_bindary_sum_div_decomposition().",
      "source": "project"
    },
    {
      "name": "lemma_binary_sum_mod_decomposition",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 178,
      "documentation": "",
      "signature": "pub fn lemma_binary_sum_mod_decomposition(a: nat, b: nat, s: nat, k: nat)",
      "requires_clauses": [
        "a < pow2 (s)"
      ],
      "ensures_clauses": [
        "(a + b * pow2 (s)) % pow2 (k) == a % pow2 (k) + (b * pow2 (s)) % pow2 (k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_binary_sum_mod_decomposition().",
      "source": "project"
    },
    {
      "name": "lemma_mul_equality_converse",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that if `x` and `y` have equal results when multiplied by\nnonzero `m`, then they're equal.",
      "signature": "pub fn lemma_mul_equality_converse(m: int, x: int, y: int)",
      "requires_clauses": [
        "m != 0",
        "# [trigger] (m * x) == # [trigger] (m * y)"
      ],
      "ensures_clauses": [
        "x == y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_equality_converse().",
      "source": "project"
    },
    {
      "name": "lemma_u8_times_pow2_mod_is_id",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 249,
      "documentation": "",
      "signature": "pub fn lemma_u8_times_pow2_mod_is_id(a: u8, k: nat, s: nat)",
      "requires_clauses": [
        "k + 8 <= s"
      ],
      "ensures_clauses": [
        "(pow2 (k) * a) as nat % pow2 (s) == pow2 (k) * a"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_mod_is_id().",
      "source": "project"
    },
    {
      "name": "lemma_u8_times_pow2_fits_u64",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 272,
      "documentation": "",
      "signature": "pub fn lemma_u8_times_pow2_fits_u64(a: u8, k: nat)",
      "requires_clauses": [
        "k <= 56"
      ],
      "ensures_clauses": [
        "(a as u64) * pow2 (k) <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_u8_times_pow2_fits_u64().",
      "source": "project"
    },
    {
      "name": "lemma_truncate_middle",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that common factors from the dividend and divisor of a\nmodulus operation can be factored out. Specifically,\n`(b * x) % (b * c) == b * (x % c)`.",
      "signature": "pub fn lemma_truncate_middle(x: int, b: int, c: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < b",
        "0 < c"
      ],
      "ensures_clauses": [
        "0 < b * c",
        "(b * x) % (b * c) == b * (x % c)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_truncate_middle().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_div_mod",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 315,
      "documentation": "",
      "signature": "pub fn lemma_pow2_div_mod(x: nat, k: nat, s: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(x / pow2 (k)) % pow2 (s) == (x % pow2 (s + k)) / pow2 (k)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_div_mod().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 423,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div(x: nat, k: nat, s: nat)",
      "requires_clauses": [
        "k <= s"
      ],
      "ensures_clauses": [
        "(x * pow2 (k)) / pow2 (s) == x / pow2 ((s - k) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_small_div",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 449,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_small_div(x: nat, px: nat, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "x < pow2 (px)",
        "s <= k",
        "px + k - s <= t"
      ],
      "ensures_clauses": [
        "((x * pow2 (k)) / pow2 (s)) % pow2 (t) == x * pow2 ((k - s) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_small_div_u8",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 481,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_small_div_u8(x: u8, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "s <= k",
        "8 + k - s <= t"
      ],
      "ensures_clauses": [
        "((x as nat * pow2 (k)) / pow2 (s)) % pow2 (t) == x as nat * pow2 ((k - s) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_div_u8().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_small_mul",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 494,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_small_mul(x: nat, px: nat, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "x < pow2 (px)",
        "k <= s",
        "px <= t + s - k"
      ],
      "ensures_clauses": [
        "((x * pow2 (k)) / pow2 (s)) % pow2 (t) == x / pow2 ((s - k) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_small_mul_u8",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 533,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_small_mul_u8(x: u8, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "k <= s",
        "8 <= t + s - k"
      ],
      "ensures_clauses": [
        "((x as nat * pow2 (k)) / pow2 (s)) % pow2 (t) == x as nat / pow2 ((s - k) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mul_u8().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_close_mod",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 546,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_close_mod(x: nat, px: nat, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "x < pow2 (px)",
        "s <= k",
        "k - s <= t"
      ],
      "ensures_clauses": [
        "((x * pow2 (k)) / pow2 (s)) % pow2 (t) == (x % pow2 ((t - (k - s)) as nat) * pow2 ((k - s) as nat ,))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_close_mod_u8",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 569,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_close_mod_u8(x: u8, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "s <= k",
        "k - s <= t"
      ],
      "ensures_clauses": [
        "((x as nat * pow2 (k)) / pow2 (s)) % pow2 (t) == (x as nat % pow2 ((t - (k - s)) as nat) * pow2 ((k - s) as nat ,))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_close_mod_u8().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_small_mod",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 584,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_small_mod(x: nat, px: nat, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "x < pow2 (px)",
        "s <= k",
        "t <= k - s"
      ],
      "ensures_clauses": [
        "((x * pow2 (k)) / pow2 (s)) % pow2 (t) == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_mul_div_mod_small_mod_u8",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 614,
      "documentation": "",
      "signature": "pub fn lemma_pow2_mul_div_mod_small_mod_u8(x: u8, k: nat, s: nat, t: nat)",
      "requires_clauses": [
        "s <= k",
        "t <= k - s"
      ],
      "ensures_clauses": [
        "((x as nat * pow2 (k)) / pow2 (s)) % pow2 (t) == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_mul_div_mod_small_mod_u8().",
      "source": "project"
    },
    {
      "name": "lemma_div_pow2_preserves_decomposition",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 627,
      "documentation": "",
      "signature": "pub fn lemma_div_pow2_preserves_decomposition(a: u64, b: u64, s: nat, k: nat)",
      "requires_clauses": [
        "a < pow2 (s)",
        "a + b * pow2 (s) <= u64 :: MAX",
        "k <= s < 64"
      ],
      "ensures_clauses": [
        "(a as nat) / pow2 (k) < pow2 ((s - k) as nat)",
        "(b * pow2 (s)) as nat / pow2 (k) == b * pow2 ((s - k) as nat)",
        "(a as nat) / pow2 (k) + b * pow2 ((s - k) as nat) <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_div_pow2_preserves_decomposition().",
      "source": "project"
    },
    {
      "name": "lemma_chunk_extraction_commutes_with_mod",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 678,
      "documentation": "Generalized: Chunk extraction commutes with modulo\nIf we extract a b-bit chunk at position k*b where k*b+b <= m, then:\n(x / 2^(k*b)) % 2^b == ((x % 2^m) / 2^(k*b)) % 2^b\n\nThis is a fundamental property that allows us to extract fixed-size chunks\nfrom a number before or after taking modulo, as long as the chunk lies\nentirely below the modulo boundary.\n\nCommon uses:\n- b=8 for byte extraction (256 = 2^8)\n- b=16 for 16-bit word extraction\n- b=32 for 32-bit word extraction",
      "signature": "pub fn lemma_chunk_extraction_commutes_with_mod(x: nat, k: nat, b: nat, m: nat)",
      "requires_clauses": [
        "b > 0",
        "k * b + b <= m"
      ],
      "ensures_clauses": [
        "(x / pow2 (k * b)) % pow2 (b) == ((x % pow2 (m)) / pow2 (k * b)) % pow2 (b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_chunk_extraction_commutes_with_mod().",
      "source": "project"
    },
    {
      "name": "lemma_mod_mod",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that the remainder when `x` is divided by `a * b`, taken\nmodulo `a`, is equivalent to `x` modulo `a`. That is,\n`(x % (a * b)) % a == x % a`.",
      "signature": "pub fn lemma_mod_mod(x: int, a: int, b: int)",
      "requires_clauses": [
        "0 < a",
        "0 < b"
      ],
      "ensures_clauses": [
        "0 < a * b",
        "(x % (a * b)) % a == x % a"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_mod().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_sum_bounds",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 728,
      "documentation": "",
      "signature": "pub fn lemma_pow2_sum_bounds(coefs: &[u8], offset: nat, step: nat, k: nat)",
      "requires_clauses": [
        "offset + k <= coefs . len ()",
        "forall | i : nat | 0 <= i <= k ==> # [trigger] coefs [(offset + i) as int] < pow2 (step)"
      ],
      "ensures_clauses": [
        "pow2_sum (coefs , offset , step , k) < pow2 ((k + 1) * step)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_sum_bounds().",
      "source": "project"
    },
    {
      "name": "lemma_modular_bit_partitioning",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 778,
      "documentation": "Modular Bit Partitioning Theorem\nIf we add a value 'a' (fitting in k bits) to 'b' shifted left by k positions,\nand take the result mod 2^n, we can partition the contributions:\n- The low k bits come from 'a' (masked to k bits)\n- The high (n-k) bits come from 'b' (masked to n-k bits, then shifted)\n\nThis works because:\n1. When a < 2^k, 'a' only affects bits [0, k-1]\n2. When we shift 'b' left by k, it only affects bits [k, n-1]\n3. No carry occurs between the two regions\n4. The sum fits within n bits",
      "signature": "pub fn lemma_modular_bit_partitioning(a: nat, b: nat, k: nat, n: nat)",
      "requires_clauses": [
        "k <= n",
        "a < pow2 (k)"
      ],
      "ensures_clauses": [
        "(a + b * pow2 (k)) % pow2 (n) == (a % pow2 (k)) + ((b % pow2 ((n - k) as nat)) * pow2 (k))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_bit_partitioning().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_even",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 805,
      "documentation": "",
      "signature": "pub fn lemma_pow2_even(n: nat)",
      "requires_clauses": [
        "n >= 1"
      ],
      "ensures_clauses": [
        "pow2 (n) % 2 == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_even().",
      "source": "project"
    },
    {
      "name": "lemma_mod_self_0",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that any integer divided by itself produces a remainder of 0.",
      "signature": "pub fn lemma_mod_self_0(m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (m % m) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "source": "project"
    },
    {
      "name": "lemma_mul_mod_noop_right",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that the remainder when `x * y` is divided by `m` is\nequivalent to the remainder when `x * (y % m)` is divided by `m`.",
      "signature": "pub fn lemma_mul_mod_noop_right(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "x * (y % m) % m == # [trigger] ((x * y) % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "source": "project"
    },
    {
      "name": "lemma_pow_mod_one",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 833,
      "documentation": "",
      "signature": "pub fn lemma_pow_mod_one(x: int, n: nat, m: int)",
      "requires_clauses": [
        "m > 1",
        "x % m == 1"
      ],
      "ensures_clauses": [
        "pow (x , n) % m == 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_one().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_geometric_double",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 868,
      "documentation": "",
      "signature": "pub fn lemma_pow2_geometric_double(n: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(pow2 (n) - 1) * pow2 (n) + (pow2 (n) - 1) == pow2 (2 * n) - 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric_double().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_geometric",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 884,
      "documentation": "",
      "signature": "pub fn lemma_pow2_geometric(a: nat, b: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(pow2 (a) - 1) * pow2 (b) + (pow2 (b) - 1) == pow2 (a + b) - 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow2_geometric().",
      "source": "project"
    },
    {
      "name": "lemma_pow_mod_congruent",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 897,
      "documentation": "",
      "signature": "pub fn lemma_pow_mod_congruent(a: int, b: int, n: nat, m: int)",
      "requires_clauses": [
        "m > 0",
        "a % m == b % m"
      ],
      "ensures_clauses": [
        "pow (a , n) % m == pow (b , n) % m"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_congruent().",
      "source": "project"
    },
    {
      "name": "lemma_pow_even_nonnegative",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 945,
      "documentation": "Lemma: Powers with even exponents are always non-negative\n\nFor any integer x and natural number k, pow(x, 2*k) >= 0\nThis is because pow(x, 2*k) = (pow(x, k))^2, and squares are always non-negative.\n\nThis is useful for proving non-negativity of powers when you need to convert\nbetween int and nat types in modular arithmetic contexts.",
      "signature": "pub fn lemma_pow_even_nonnegative(x: int, k: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow (x , 2 * k) >= 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_even_nonnegative().",
      "source": "project"
    },
    {
      "name": "lemma_mul_nonnegative",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that since `x` and `y` are non-negative, their product is\nnon-negative.",
      "signature": "pub fn lemma_mul_nonnegative(x: int, y: int)",
      "requires_clauses": [
        "0 <= x",
        "0 <= y"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x * y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "source": "project"
    },
    {
      "name": "lemma_mul_cancels_negatives",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplying `-x` and `-y` produces the same product as\nmultiplying `x` and `y`.",
      "signature": "pub fn lemma_mul_cancels_negatives(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) == (- x) * (- y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_cancels_negatives().",
      "source": "project"
    },
    {
      "name": "lemma_pow_mod_composition",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 967,
      "documentation": "Lemma: Modular exponentiation composition\n\nProves: ((x^a % m)^b % m) = (x^(a*b) % m)\n\nThis is essential for chaining power operations in modular arithmetic.\nFor example, in the invert proof we compute: (x^(2^250-1))^(2^5) = x^((2^250-1)*2^5)",
      "signature": "pub fn lemma_pow_mod_composition(x: nat, a: nat, b: nat, m: nat)",
      "requires_clauses": [
        "a > 0",
        "b > 0",
        "m > 0"
      ],
      "ensures_clauses": [
        "(pow (((pow (x as int , a) as nat) % m) as int , b) as nat) % m == (pow (x as int , a * b) as nat) % m"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_pow_mod_composition().",
      "source": "project"
    },
    {
      "name": "lemma_pow_multiplies",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that `a` to the power of `b * c` is equal to the result of\ntaking `a` to the power of `b`, then taking that to the power of\n`c`.",
      "signature": "pub fn lemma_pow_multiplies(a: int, b: nat, c: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= b * c",
        "# [trigger] pow (pow (a , b) , c) == pow (a , b * c)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_multiplies().",
      "source": "project"
    },
    {
      "name": "lemma_modular_power_addition",
      "file_path": "src/lemmas/common_lemmas/pow_lemmas.rs",
      "line_number": 1048,
      "documentation": "Lemma: Modular power addition\n\nProves that (x^a % m * x^b % m) % m == x^(a+b) % m\n\nThis lemma combines:\n- Power addition: x^(a+b) = x^a * x^b (from lemma_pow_adds)\n- Modular multiplication property (from lemma_mul_mod_noop_general)\n- Int/nat modulo equivalence (via lemma_int_nat_mod_equiv)",
      "signature": "pub fn lemma_modular_power_addition(x: nat, a: nat, b: nat, m: nat)",
      "requires_clauses": [
        "a > 0",
        "b > 0",
        "m > 0"
      ],
      "ensures_clauses": [
        "((pow (x as int , a) as nat) % m) * ((pow (x as int , b) as nat) % m) % m == (pow (x as int , a + b ,) as nat) % m"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_lemmas/common_lemmas/lemmas/lemma_modular_power_addition().",
      "source": "project"
    },
    {
      "name": "lemma_sum_equals_byte_nat_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 276,
      "documentation": "Helper: proves that the sum of byte contributions equals u8_32_as_nat\n\nThe key insight here is that the byte contributions partition the bytes\nsuch that each byte (or parts of bytes at boundaries) is accounted for exactly once.",
      "signature": "pub fn lemma_sum_equals_byte_nat_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb0_byte_contribution_52 (limbs , bytes) + limb1_byte_contribution_52 (limbs , bytes) + limb2_byte_contribution_52 (limbs , bytes) + limb3_byte_contribution_52 (limbs , bytes) + limb4_byte_contribution_52 (limbs , bytes) == u8_32_as_nat (& bytes)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_sum_equals_byte_nat_52().",
      "source": "project"
    },
    {
      "name": "lemma_limb0_contribution_correctness_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 548,
      "documentation": "Per-limb correctness lemmas (one for each limb 0-4)",
      "signature": "pub fn lemma_limb0_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [0] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb0_byte_contribution_52 (limbs , bytes) == (limbs [0] as nat) % pow2 (52)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb0_contribution_correctness_52().",
      "source": "project"
    },
    {
      "name": "lemma_limb1_contribution_correctness_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 667,
      "documentation": "",
      "signature": "pub fn lemma_limb1_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [0] < (1u64 << 52)",
        "limbs [1] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb1_byte_contribution_52 (limbs , bytes) == (limbs [1] as nat) * pow2 (52)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb1_contribution_correctness_52().",
      "source": "project"
    },
    {
      "name": "lemma_limb2_contribution_correctness_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 867,
      "documentation": "",
      "signature": "pub fn lemma_limb2_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [2] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb2_byte_contribution_52 (limbs , bytes) == (limbs [2] as nat) * pow2 (104)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb2_contribution_correctness_52().",
      "source": "project"
    },
    {
      "name": "lemma_limb3_contribution_correctness_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 1021,
      "documentation": "",
      "signature": "pub fn lemma_limb3_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [2] < (1u64 << 52)",
        "limbs [3] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb3_byte_contribution_52 (limbs , bytes) == (limbs [3] as nat) * pow2 (156)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb3_contribution_correctness_52().",
      "source": "project"
    },
    {
      "name": "lemma_limb4_contribution_correctness_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 1222,
      "documentation": "",
      "signature": "pub fn lemma_limb4_contribution_correctness_52(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [4] < (1u64 << 52)",
        "bytes_match_limbs_packing_52 (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb4_byte_contribution_52 (limbs , bytes) == ((limbs [4] as nat) % pow2 (48)) * pow2 (208)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_limb4_contribution_correctness_52().",
      "source": "project"
    },
    {
      "name": "lemma_byte_from_limb_shift_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 245,
      "documentation": "Helper: A byte formed by simple right shift has a direct arithmetic interpretation\nThis is the 52-bit version of lemma_byte_from_limb_shift",
      "signature": "fn lemma_byte_from_limb_shift_52(limb: u64, shift: u64, byte: u8)",
      "requires_clauses": [
        "limb < pow2 (52)",
        "shift < 64",
        "byte == (limb >> shift) as u8"
      ],
      "ensures_clauses": [
        "byte as nat == (limb as nat / pow2 (shift as nat)) % 256"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_byte_from_limb_shift_52().",
      "source": "project"
    },
    {
      "name": "lemma_boundary_byte_combines_52",
      "file_path": "src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs",
      "line_number": 387,
      "documentation": "Helper lemma: proves that a boundary byte correctly combines parts from two limbs (52-bit version)",
      "signature": "fn lemma_boundary_byte_combines_52(low_limb: u64, high_limb: u64, byte: u8, low_shift: nat, low_bits: nat)",
      "requires_clauses": [
        "low_limb < pow2 (52)",
        "high_limb < pow2 (52)",
        "low_bits < 8",
        "low_shift + low_bits == 52",
        "byte == ((low_limb >> low_shift) | (high_limb << low_bits)) as u8"
      ],
      "ensures_clauses": [
        "byte as nat == (low_limb as nat / pow2 (low_shift)) % pow2 (low_bits) + (high_limb as nat % pow2 ((8 - low_bits) as nat)) * pow2 (low_bits)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_to_bytes_lemmas/scalar_byte_lemmas/lemmas/lemma_boundary_byte_combines_52().",
      "source": "project"
    },
    {
      "name": "lemma_byte_extraction_commutes_with_mod",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 224,
      "documentation": "Helper: Byte extraction commutes with modulo for low-order bytes\nIf we extract a byte at position k*8 where k*8+8 <= m, then:\n(x / 2^(k*8)) % 256 == ((x % 2^m) / 2^(k*8)) % 256\n\nThis is a specialized version of lemma_chunk_extraction_commutes_with_mod for bytes (b=8).",
      "signature": "pub fn lemma_byte_extraction_commutes_with_mod(x: nat, k: nat, m: nat)",
      "requires_clauses": [
        "k * 8 + 8 <= m"
      ],
      "ensures_clauses": [
        "(x / pow2 (k * 8)) % 256 == ((x % pow2 (m)) / pow2 (k * 8)) % 256"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_extraction_commutes_with_mod().",
      "source": "project"
    },
    {
      "name": "lemma_6_bytes_reconstruct",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 479,
      "documentation": "Helper: 6-byte reconstruction lemma\nProves that 6 consecutive bytes reconstruct a 48-bit value",
      "signature": "pub fn lemma_6_bytes_reconstruct(value: nat, byte0: u8, byte1: u8, byte2: u8, byte3: u8, byte4: u8, byte5: u8)",
      "requires_clauses": [
        "byte0 as nat == (value / pow2 (0)) % 256",
        "byte1 as nat == (value / pow2 (8)) % 256",
        "byte2 as nat == (value / pow2 (16)) % 256",
        "byte3 as nat == (value / pow2 (24)) % 256",
        "byte4 as nat == (value / pow2 (32)) % 256",
        "byte5 as nat == (value / pow2 (40)) % 256",
        "value < pow2 (48)"
      ],
      "ensures_clauses": [
        "byte0 as nat * pow2 (0) + byte1 as nat * pow2 (8) + byte2 as nat * pow2 (16) + byte3 as nat * pow2 (24) + byte4 as nat * pow2 (32) + byte5 as nat * pow2 (40) == value"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_6_bytes_reconstruct().",
      "source": "project"
    },
    {
      "name": "lemma_reduction_telescoping",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 27,
      "documentation": "Telescoping lemma for reduction: expands u64_5_as_nat through the carry propagation\nThis is analogous to lemma_radix51_telescoping_direct but for the reduction case",
      "signature": "pub fn lemma_reduction_telescoping(input_limbs: [u64; 5], final_limbs: [u64; 5], q: u64, c0: int, c1: int, c2: int, c3: int, c4: int)",
      "requires_clauses": [
        "input_limbs [0] as int + 19 * q as int == c0 * pow2 (51) as int + final_limbs [0] as int",
        "input_limbs [1] as int + c0 == c1 * pow2 (51) as int + final_limbs [1] as int",
        "input_limbs [2] as int + c1 == c2 * pow2 (51) as int + final_limbs [2] as int",
        "input_limbs [3] as int + c2 == c3 * pow2 (51) as int + final_limbs [3] as int",
        "input_limbs [4] as int + c3 == c4 * pow2 (51) as int + final_limbs [4] as int",
        "final_limbs [0] < (1u64 << 51)",
        "final_limbs [1] < (1u64 << 51)",
        "final_limbs [2] < (1u64 << 51)",
        "final_limbs [3] < (1u64 << 51)",
        "final_limbs [4] < (1u64 << 51)"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (input_limbs) as int + 19 * q as int == u64_5_as_nat (final_limbs) as int + c4 * pow2 (255) as int"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_telescoping().",
      "source": "project"
    },
    {
      "name": "lemma_mul_is_distributive_sub_other_way",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that multiplication distributes over subtraction when the\nsubtraction happens in the multiplicand (i.e., in the left-hand\nargument to `*`). Specifically, `(y - z) * x == y * x - z * x`.",
      "signature": "pub fn lemma_mul_is_distributive_sub_other_way(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] ((y - z) * x) == y * x - z * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "source": "project"
    },
    {
      "name": "lemma_mul_upper_bound",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 205,
      "documentation": "Helper lemma: Multiplication preserves upper bounds",
      "signature": "fn lemma_mul_upper_bound(a: nat, x: nat, b: nat)",
      "requires_clauses": [
        "x <= b"
      ],
      "ensures_clauses": [
        "a * x <= a * b"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_mul_upper_bound().",
      "source": "project"
    },
    {
      "name": "lemma_geometric_sum_5_terms",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 224,
      "documentation": "Helper lemma: Proves the geometric series identity for 5 terms with base 2^51\n(2^51 - 1) * (1 + 2^51 + 2^102 + 2^153 + 2^204) = 2^255 - 1",
      "signature": "fn lemma_geometric_sum_5_terms()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(pow2 (51) - 1) * (1 + pow2 (51) + pow2 (102) + pow2 (153) + pow2 (204)) == pow2 (255) - 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_geometric_sum_5_terms().",
      "source": "project"
    },
    {
      "name": "lemma_as_nat_bound_from_51bit_limbs",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 282,
      "documentation": "Helper lemma: u64_5_as_nat bound for 51-bit limbs\nIf each limb < 2^51, then u64_5_as_nat < 2^255",
      "signature": "pub fn lemma_as_nat_bound_from_51bit_limbs(limbs: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 51)"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (limbs) < pow2 (255)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_as_nat_bound_from_51bit_limbs().",
      "source": "project"
    },
    {
      "name": "lemma_reduction_carry_propagation_is_division",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 349,
      "documentation": "Helper lemma: Proves that the carry propagation in reduction computes the division by 2^255\nThis is analogous to lemma_carry_propagation_is_division but for the reduction step",
      "signature": "pub fn lemma_reduction_carry_propagation_is_division(input_limbs: [u64; 5], q: u64, c4: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> input_limbs [i] < (1u64 << 52)",
        "q == 0 || q == 1",
        "c4 == ({ let l0 = (input_limbs [0] + 19 * q) as u64 ; let l1 = (input_limbs [1] + (l0 >> 51)) as u64 ; let l2 = (input_limbs [2] + (l1 >> 51)) as u64 ; let l3 = (input_limbs [3] + (l2 >> 51)) as u64 ; let l4 = (input_limbs [4] + (l3 >> 51)) as u64 ; l4 >> 51 })"
      ],
      "ensures_clauses": [
        "c4 as int == (u64_5_as_nat (input_limbs) as int + 19 * q as int) / (pow2 (255) as int)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_reduction_carry_propagation_is_division().",
      "source": "project"
    },
    {
      "name": "lemma_div_and_mod_51",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 113,
      "documentation": "",
      "signature": "pub fn lemma_div_and_mod_51(ai: u64, bi: u64, v: u64)",
      "requires_clauses": [
        "ai == v >> 51",
        "bi == v & mask51"
      ],
      "ensures_clauses": [
        "ai == v / (pow2 (51) as u64)",
        "bi == v % (pow2 (51) as u64)",
        "v == ai * pow2 (51) + bi"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_div_and_mod_51().",
      "source": "project"
    },
    {
      "name": "lemma_masked_lt_51",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 104,
      "documentation": "",
      "signature": "pub fn lemma_masked_lt_51(v: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "v & mask51 < (1u64 << 51)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_masked_lt_51().",
      "source": "project"
    },
    {
      "name": "lemma_carry_out_equals_q",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 451,
      "documentation": "Helper lemma: Show that the carry out of l4 equals q",
      "signature": "pub fn lemma_carry_out_equals_q(input_limbs: [u64; 5], q: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> input_limbs [i] < (1u64 << 52)",
        "q == 0 || q == 1",
        "u64_5_as_nat (input_limbs) >= p () <==> q == 1",
        "u64_5_as_nat (input_limbs) < 2 * p ()"
      ],
      "ensures_clauses": [
        "({ let l0 = (input_limbs [0] + 19 * q) as u64 ; let l1 = (input_limbs [1] + (l0 >> 51)) as u64 ; let l2 = (input_limbs [2] + (l1 >> 51)) as u64 ; let l3 = (input_limbs [3] + (l2 >> 51)) as u64 ; let l4 = (input_limbs [4] + (l3 >> 51)) as u64 ; (l4 >> 51) == q })"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_carry_out_equals_q().",
      "source": "project"
    },
    {
      "name": "lemma_div_is_ordered_by_denominator",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that given two fractions with the same numerator, the order\nof the fractions is determined by the denominators. However, if\nthe numerator is 0, the fractions are equal regardless of the\ndenominators' values. Specifically, given that `1 <= y <= z`, we\nknow `x / y >= x / z`.",
      "signature": "pub fn lemma_div_is_ordered_by_denominator(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "1 <= y <= z"
      ],
      "ensures_clauses": [
        "# [trigger] (x / y) >= # [trigger] (x / z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "source": "project"
    },
    {
      "name": "lemma_div_basics_3",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": null,
      "documentation": "Proof for basic property that `x` divided by `x` is 1.",
      "signature": "pub fn lemma_div_basics_3(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x != 0 ==> # [trigger] (x / x) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_3().",
      "source": "project"
    },
    {
      "name": "lemma_p_radix_representation",
      "file_path": "src/lemmas/field_lemmas/to_bytes_reduction_lemmas.rs",
      "line_number": 747,
      "documentation": "Helper lemma establishing the radix-2^51 expansion of p().",
      "signature": "pub fn lemma_p_radix_representation()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(pow2 (51) - 19) + pow2 (51) * (pow2 (51) - 1) + pow2 (102) * (pow2 (51) - 1) + pow2 (153) * (pow2 (51) - 1) + pow2 (204) * (pow2 (51) - 1) == p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 to_bytes_reduction_lemmas/field_lemmas/lemmas/lemma_p_radix_representation().",
      "source": "project"
    },
    {
      "name": "lemma_prove_pow2k_step",
      "file_path": "src/lemmas/field_lemmas/pow_chain_lemmas.rs",
      "line_number": 26,
      "documentation": "",
      "signature": "pub fn lemma_prove_pow2k_step(base: int, val_in: nat, val_out: nat, exp_in: nat, exp_power: nat)",
      "requires_clauses": [
        "base >= 0",
        "p () > 0",
        "exp_power > 0",
        "val_in % p () == pow (base , exp_in) as nat % p ()",
        "val_out % p () == pow (val_in as int , exp_power) as nat % p ()"
      ],
      "ensures_clauses": [
        "val_out % p () == pow (base , (exp_in * exp_power) as nat) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_pow2k_step().",
      "source": "project"
    },
    {
      "name": "lemma_prove_geometric_mul_step",
      "file_path": "src/lemmas/field_lemmas/pow_chain_lemmas.rs",
      "line_number": 87,
      "documentation": "",
      "signature": "pub fn lemma_prove_geometric_mul_step(base: int, val_a: nat, val_b: nat, val_result: nat, exp_a: nat, exp_b: nat)",
      "requires_clauses": [
        "base >= 0",
        "p () > 0",
        "val_a % p () == pow (base , exp_a) as nat % p ()",
        "val_b % p () == pow (base , exp_b) as nat % p ()",
        "val_result % p () == (val_a * val_b) % p ()"
      ],
      "ensures_clauses": [
        "val_result % p () == pow (base , (exp_a + exp_b) as nat) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow_chain_lemmas/field_lemmas/lemmas/lemma_prove_geometric_mul_step().",
      "source": "project"
    },
    {
      "name": "lemma_two_factoring_51",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 18,
      "documentation": "",
      "signature": "pub fn lemma_two_factoring_51(k: nat, ai: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (k + 51) * ai == pow2 (k) * (pow2 (51) * ai)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_two_factoring_51().",
      "source": "project"
    },
    {
      "name": "lemma_add_then_shift",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 25,
      "documentation": "",
      "signature": "pub fn lemma_add_then_shift(a: u64, b: u64)",
      "requires_clauses": [
        "a < (1u64 << 52)",
        "b < (1u64 << 52)"
      ],
      "ensures_clauses": [
        "(a + b) < (1u64 << 53)",
        "((a + b) as u64 >> 51) < 4"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_add_then_shift().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_subtracts",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that, as long as `e1 <= e2`, `2^(e2 - e1)` is equivalent to `2^e2 / 2^e1`.",
      "signature": "pub fn lemma_pow2_subtracts(e1: nat, e2: nat)",
      "requires_clauses": [
        "e1 <= e2"
      ],
      "ensures_clauses": [
        "# [trigger] pow2 ((e2 - e1) as nat) == pow2 (e2) / pow2 (e1) > 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2_subtracts().",
      "source": "project"
    },
    {
      "name": "lemma_shr_51_le",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 52,
      "documentation": "",
      "signature": "pub fn lemma_shr_51_le(a: u128, b: u128)",
      "requires_clauses": [
        "a <= b"
      ],
      "ensures_clauses": [
        "(a >> 51) <= (b >> 51)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_le().",
      "source": "project"
    },
    {
      "name": "lemma_shr_51_fits_u64",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 66,
      "documentation": "",
      "signature": "pub fn lemma_shr_51_fits_u64(a: u128)",
      "requires_clauses": [
        "a <= (u64 :: MAX as u128) << 51"
      ],
      "ensures_clauses": [
        "(a >> 51) <= (u64 :: MAX as u128)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_shr_51_fits_u64().",
      "source": "project"
    },
    {
      "name": "lemma_cast_then_mod_51",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 80,
      "documentation": "",
      "signature": "pub fn lemma_cast_then_mod_51(x: u128)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(x as u64) % (pow2 (51) as u64) == x % (pow2 (51) as u128)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mod_51().",
      "source": "project"
    },
    {
      "name": "lemma_mul_sub",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 88,
      "documentation": "",
      "signature": "pub fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (k) * (ci - pow2 (51) * (cj - cj_0)) == pow2 (k) * ci - pow2 (k + 51) * cj + pow2 (k + 51) * cj_0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_mul_sub().",
      "source": "project"
    },
    {
      "name": "lemma_cast_then_mask_51",
      "file_path": "src/lemmas/field_lemmas/pow2_51_lemmas.rs",
      "line_number": 126,
      "documentation": "",
      "signature": "pub fn lemma_cast_then_mask_51(x: u128)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(x as u64) & mask51 == x & (mask51 as u128)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2_51_lemmas/field_lemmas/lemmas/lemma_cast_then_mask_51().",
      "source": "project"
    },
    {
      "name": "lemma_mul_v0_and_reorder",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 17,
      "documentation": "",
      "signature": "pub fn lemma_mul_v0_and_reorder(v0: int, s1: int, v1: int, s2: int, v2: int, s3: int, v3: int, s4: int, v4: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "v0 * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) == s4 * (v0 * v4) + s3 * (v0 * v3) + s2 * (v0 * v2) + s1 * (v0 * v1) + (v0 * v0)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_v0_and_reorder().",
      "source": "project"
    },
    {
      "name": "lemma_mul_si_vi_and_reorder",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 40,
      "documentation": "",
      "signature": "pub fn lemma_mul_si_vi_and_reorder(si: int, vi: int, v0: int, s1: int, v1: int, s2: int, v2: int, s3: int, v3: int, s4: int, v4: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) == (si) * (vi * v0) + (si * s1) * (vi * v1) + (si * s2) * (vi * v2) + (si * s3) * (vi * v3) + (si * s4) * (vi * v4)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_mul_si_vi_and_reorder().",
      "source": "project"
    },
    {
      "name": "lemma_u64_5_as_nat_squared",
      "file_path": "src/lemmas/field_lemmas/u64_5_as_nat_lemmas.rs",
      "line_number": 186,
      "documentation": "",
      "signature": "pub fn lemma_u64_5_as_nat_squared(v: [u64; 5])",
      "requires_clauses": [],
      "ensures_clauses": [
        "u64_5_as_nat (v) * u64_5_as_nat (v) == pow2 (8 * 51) * (v [4] * v [4]) + pow2 (7 * 51) * (2 * (v [3] * v [4])) + pow2 (6 * 51) * (v [3] * v [3] + 2 * (v [2] * v [4])) + pow2 (5 * 51) * (2 * (v [2] * v [3]) + 2 * (v [1] * v [4])) + pow2 (4 * 51) * (v [2] * v [2] + 2 * (v [1] * v [3]) + 2 * (v [0] * v [4])) + pow2 (3 * 51) * (2 * (v [1] * v [2]) + 2 * (v [0] * v [3])) + pow2 (2 * 51) * (v [1] * v [1] + 2 * (v [0] * v [2])) + pow2 (1 * 51) * (2 * (v [0] * v [1])) + (v [0] * v [0])",
        "(u64_5_as_nat (v) * u64_5_as_nat (v)) % p () == (pow2 (4 * 51) * (v [2] * v [2] + 2 * (v [1] * v [3]) + 2 * (v [0] * v [4])) + pow2 (3 * 51) * (2 * (v [1] * v [2]) + 2 * (v [0] * v [3]) + 19 * (v [4] * v [4])) + pow2 (2 * 51) * (v [1] * v [1] + 2 * (v [0] * v [2]) + 19 * (2 * (v [3] * v [4]))) + pow2 (1 * 51) * (2 * (v [0] * v [1]) + 19 * (v [3] * v [3] + 2 * (v [2] * v [4]))) + (v [0] * v [0] + 19 * (2 * (v [2] * v [3]) + 2 * (v [1] * v [4])))) as nat % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u64_5_as_nat_lemmas/field_lemmas/lemmas/lemma_u64_5_as_nat_squared().",
      "source": "project"
    },
    {
      "name": "lemma_pow2k_to_field_element",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 31,
      "documentation": "Lemma: Lift pow2k postcondition from limb-level to field-level\n\nThis lemma derives a field-level postcondition from pow2k's limb-level postcondition.\nIt bridges the abstraction gap between u64_5_as_nat(limbs) and spec_field_element.\n\n**Purpose**: pow2k gives us postconditions in terms of limbs, but we need them in terms\nof field elements for higher-level reasoning.\n\n**Strategy**: Since spec_field_element(x) = u64_5_as_nat(x.limbs) % p() by definition,\nwe use modular congruence properties to show that pow(limbs, k) \u2261 pow(field_element, k) (mod p).",
      "signature": "pub fn lemma_pow2k_to_field_element(fe: &FieldElement51, result: &FieldElement51, k: nat)",
      "requires_clauses": [
        "k > 0",
        "u64_5_as_nat (result . limbs) % p () == (pow (u64_5_as_nat (fe . limbs) as int , k) as nat) % p ()"
      ],
      "ensures_clauses": [
        "spec_field_element (result) == (pow (spec_field_element (fe) as int , k) as nat) % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_pow2k_to_field_element().",
      "source": "project"
    },
    {
      "name": "lemma_invert_zero_case",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 81,
      "documentation": "Lemma: When the input is zero, the invert result is zero\n\nStrategy: Show that 0^11 = 0, therefore t3 = 0, therefore t21 = t20 * 0 = 0",
      "signature": "pub fn lemma_invert_zero_case(self_fe: &FieldElement51, t3: &FieldElement51, t20: &FieldElement51, t21: &FieldElement51)",
      "requires_clauses": [
        "spec_field_element (self_fe) == 0",
        "spec_field_element (t3) == (pow (spec_field_element (self_fe) as int , 11) as nat) % p ()",
        "spec_field_element (t21) == math_field_mul (spec_field_element (t20) , spec_field_element (t3))"
      ],
      "ensures_clauses": [
        "spec_field_element (t21) == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_zero_case().",
      "source": "project"
    },
    {
      "name": "lemma_mod_is_mod_recursive",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that computing the modulus using `%` is equivalent to\ncomputing it with a recursive definition of modulus. Specifically,\n`x % m` is equivalent in that way.",
      "signature": "pub fn lemma_mod_is_mod_recursive(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "mod_recursive (x , m) == # [trigger] (x % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_mod_recursive().",
      "source": "project"
    },
    {
      "name": "lemma_invert_exponent_arithmetic",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 119,
      "documentation": "Lemma: Arithmetic fact about the exponent decomposition\n\nShows that: (2^250 - 1) * 2^5 + 11 = 2^255 - 21 = p - 2\nwhere p = 2^255 - 19",
      "signature": "pub fn lemma_invert_exponent_arithmetic()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(pow2 (250) - 1) * pow2 (5) == pow2 (255) - 32",
        "pow2 (255) - 21 == p () - 2"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_exponent_arithmetic().",
      "source": "project"
    },
    {
      "name": "lemma_invert_power_chain",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 146,
      "documentation": "Lemma: Connect field element postconditions to power expressions\n\nThis lemma bridges the gap between the postconditions from pow2k and mul\nto the explicit power expression form needed for the inversion proof.\n\nIt establishes:\n1. t20 = x^(2^255 - 32) mod p (by chaining lifting, composition, and arithmetic lemmas)\n2. t21 = (x^(2^255 - 32) mod p * x^11 mod p) mod p (by expanding mul and substituting)",
      "signature": "pub fn lemma_invert_power_chain(self_fe: &FieldElement51, t19: &FieldElement51, t20: &FieldElement51, t3: &FieldElement51, t21: &FieldElement51)",
      "requires_clauses": [
        "spec_field_element (t19) == (pow (spec_field_element (self_fe) as int , (pow2 (250) - 1) as nat ,) as nat) % p ()",
        "spec_field_element (t3) == (pow (spec_field_element (self_fe) as int , 11) as nat) % p ()",
        "u64_5_as_nat (t20 . limbs) % p () == (pow (u64_5_as_nat (t19 . limbs) as int , pow2 (5)) as nat) % p ()",
        "spec_field_element (t21) == math_field_mul (spec_field_element (t20) , spec_field_element (t3))"
      ],
      "ensures_clauses": [
        "spec_field_element (t20) == (pow (spec_field_element (self_fe) as int , (pow2 (255) - 32) as nat ,) as nat) % p ()",
        "spec_field_element (t21) == (spec_field_element (t20) * spec_field_element (t3)) % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_power_chain().",
      "source": "project"
    },
    {
      "name": "lemma_multiply_by_base_power_addition",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 232,
      "documentation": "Helper lemma: Multiplying x^(p-2) by x yields x^(p-1)\n\nProves that (x^(p-2) * x) % p = x^(p-1) % p in modular arithmetic.\nThis is a key step in applying Fermat's Little Theorem.",
      "signature": "pub fn lemma_multiply_by_base_power_addition(x: nat, self_fe: &FieldElement51, t21: &FieldElement51)",
      "requires_clauses": [
        "x == spec_field_element (self_fe)",
        "spec_field_element (t21) == (pow (x as int , (p () - 2) as nat) as nat) % p ()"
      ],
      "ensures_clauses": [
        "(spec_field_element (t21) * x) % p () == (pow (x as int , (p () - 1) as nat) as nat) % p ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_multiply_by_base_power_addition().",
      "source": "project"
    },
    {
      "name": "lemma_invert_is_multiplicative_inverse",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 290,
      "documentation": "Lemma: The computed value is the multiplicative inverse (non-zero case)\n\nUses Fermat's Little Theorem: a^(p-1) \u2261 1 (mod p) for non-zero a\nTherefore: a^(p-2) * a \u2261 1 (mod p)",
      "signature": "pub fn lemma_invert_is_multiplicative_inverse(self_fe: &FieldElement51, t19: &FieldElement51, t20: &FieldElement51, t3: &FieldElement51, t21: &FieldElement51)",
      "requires_clauses": [
        "spec_field_element (self_fe) != 0",
        "spec_field_element (t19) == (pow (spec_field_element (self_fe) as int , (pow2 (250) - 1) as nat ,) as nat) % p ()",
        "spec_field_element (t3) == (pow (spec_field_element (self_fe) as int , 11) as nat) % p ()",
        "u64_5_as_nat (t20 . limbs) % p () == (pow (u64_5_as_nat (t19 . limbs) as int , pow2 (5)) as nat) % p ()",
        "spec_field_element (t21) == math_field_mul (spec_field_element (t20) , spec_field_element (t3))"
      ],
      "ensures_clauses": [
        "(spec_field_element (t21) * spec_field_element (self_fe)) % p () == 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_is_multiplicative_inverse().",
      "source": "project"
    },
    {
      "name": "lemma_invert_equals_math_field_inv",
      "file_path": "src/lemmas/field_lemmas/invert_lemmas.rs",
      "line_number": 397,
      "documentation": "Lemma: The computed value equals math_field_inv\n\nShows that spec_field_element(t21) satisfies the definition of math_field_inv",
      "signature": "pub fn lemma_invert_equals_math_field_inv(self_fe: &FieldElement51, t21: &FieldElement51)",
      "requires_clauses": [
        "spec_field_element (self_fe) != 0 ==> (spec_field_element (t21) * spec_field_element (self_fe)) % p () == 1",
        "spec_field_element (self_fe) == 0 ==> spec_field_element (t21) == 0"
      ],
      "ensures_clauses": [
        "spec_field_element (t21) == math_field_inv (spec_field_element (self_fe))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 invert_lemmas/field_lemmas/lemmas/lemma_invert_equals_math_field_inv().",
      "source": "project"
    },
    {
      "name": "lemma_assemble_mod_div",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 22,
      "documentation": "",
      "signature": "pub fn lemma_assemble_mod_div(a: nat, d: nat, b: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(a % pow2 (d)) * pow2 (b) + pow2 (b + d) * (a / pow2 (d)) == a * pow2 (b)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_mod_div().",
      "source": "project"
    },
    {
      "name": "lemma_assemble_pow_a_pow",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 55,
      "documentation": "",
      "signature": "pub fn lemma_assemble_pow_a_pow(a: nat, j: nat, k: nat, l: nat)",
      "requires_clauses": [
        "k * 8 > l"
      ],
      "ensures_clauses": [
        "pow2 (j * 8 + l) * (a * pow2 ((k * 8 - l) as nat)) == a * pow2 ((j + k) * 8)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_assemble_pow_a_pow().",
      "source": "project"
    },
    {
      "name": "lemma_from_bytes_as_nat_01",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 81,
      "documentation": "",
      "signature": "pub fn lemma_from_bytes_as_nat_01(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "(spec_load8_at (bytes , 0) as u64 & mask51) + pow2 (51) * ((spec_load8_at (bytes , 6) as u64 >> 3) & mask51) == (bytes [0] * pow2 (0 * 8)) + (bytes [1] * pow2 (1 * 8)) + (bytes [2] * pow2 (2 * 8)) + (bytes [3] * pow2 (3 * 8)) + (bytes [4] * pow2 (4 * 8)) + (bytes [5] * pow2 (5 * 8 ,)) + (bytes [6] * pow2 (6 * 8)) + (bytes [7] * pow2 (7 * 8)) + (bytes [8] * pow2 (8 * 8)) + (bytes [9] * pow2 (9 * 8)) + (bytes [10] * pow2 (10 * 8)) + (bytes [11] * pow2 (11 * 8)) + ((bytes [12] as nat % pow2 (6)) * pow2 ((12 * 8) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb0",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 825,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb0(input: &[u8])",
      "requires_clauses": [
        "0 + 7 < input . len ()"
      ],
      "ensures_clauses": [
        "(spec_load8_at (input , 0) as u64) & mask51 == (input [0] * pow2 (0 * 8)) + (input [1] * pow2 (1 * 8 ,)) + (input [2] * pow2 (2 * 8)) + (input [3] * pow2 (3 * 8)) + (input [4] * pow2 (4 * 8)) + (input [5] * pow2 (5 * 8)) + ((input [6] as nat % pow2 (3)) * pow2 (6 * 8))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb0().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb1",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 872,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb1(input: &[u8])",
      "requires_clauses": [
        "6 + 7 < input . len ()"
      ],
      "ensures_clauses": [
        "((spec_load8_at (input , 6) as u64) >> 3) & mask51 == (input [6] as nat / pow2 (3)) + (input [7] * pow2 ((1 * 8 - 3) as nat)) + (input [8] * pow2 ((2 * 8 - 3) as nat)) + (input [9] * pow2 ((3 * 8 - 3) as nat ,)) + (input [10] * pow2 ((4 * 8 - 3) as nat)) + (input [11] * pow2 ((5 * 8 - 3) as nat)) + ((input [12] as nat % pow2 (6)) * pow2 ((6 * 8 - 3) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb1().",
      "source": "project"
    },
    {
      "name": "lemma_from_bytes_as_nat_012",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 147,
      "documentation": "",
      "signature": "pub fn lemma_from_bytes_as_nat_012(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "(spec_load8_at (bytes , 0) as u64 & mask51) + pow2 (51) * ((spec_load8_at (bytes , 6) as u64 >> 3) & mask51) + pow2 (102) * ((spec_load8_at (bytes , 12) as u64 >> 6) & mask51) == (bytes [0] * pow2 (0 * 8)) + (bytes [1] * pow2 (1 * 8)) + (bytes [2] * pow2 (2 * 8)) + (bytes [3] * pow2 (3 * 8)) + (bytes [4] * pow2 (4 * 8)) + (bytes [5] * pow2 (5 * 8)) + (bytes [6] * pow2 (6 * 8 ,)) + (bytes [7] * pow2 (7 * 8)) + (bytes [8] * pow2 (8 * 8)) + (bytes [9] * pow2 (9 * 8)) + (bytes [10] * pow2 (10 * 8)) + (bytes [11] * pow2 (11 * 8)) + (bytes [12] * pow2 (12 * 8)) + (bytes [13] * pow2 (13 * 8)) + (bytes [14] * pow2 (14 * 8)) + (bytes [15] * pow2 (15 * 8)) + (bytes [16] * pow2 (16 * 8)) + (bytes [17] * pow2 (17 * 8)) + (bytes [18] * pow2 (18 * 8)) + ((bytes [19] as nat % pow2 (1)) * pow2 ((19 * 8) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_012().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb2",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 909,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb2(input: &[u8])",
      "requires_clauses": [
        "12 + 7 < input . len ()"
      ],
      "ensures_clauses": [
        "((spec_load8_at (input , 12) as u64) >> 6) & mask51 == (input [12] as nat / pow2 (6)) + (input [13] * pow2 ((1 * 8 - 6) as nat)) + (input [14] * pow2 ((2 * 8 - 6) as nat)) + (input [15] * pow2 ((3 * 8 - 6) as nat)) + (input [16] * pow2 ((4 * 8 - 6) as nat)) + (input [17] * pow2 ((5 * 8 - 6) as nat)) + (input [18] * pow2 ((6 * 8 - 6) as nat)) + ((input [19] as nat % pow2 (1)) * pow2 ((7 * 8 - 6) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb2().",
      "source": "project"
    },
    {
      "name": "lemma_from_bytes_as_nat_0123",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 229,
      "documentation": "",
      "signature": "pub fn lemma_from_bytes_as_nat_0123(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "(spec_load8_at (bytes , 0) as u64 & mask51) + pow2 (51) * ((spec_load8_at (bytes , 6) as u64 >> 3) & mask51) + pow2 (102) * ((spec_load8_at (bytes , 12) as u64 >> 6) & mask51) + pow2 (153 ,) * ((spec_load8_at (bytes , 19) as u64 >> 1) & mask51) == (bytes [0] * pow2 (0 * 8)) + (bytes [1] * pow2 (1 * 8)) + (bytes [2] * pow2 (2 * 8)) + (bytes [3] * pow2 (3 * 8)) + (bytes [4] * pow2 (4 * 8)) + (bytes [5] * pow2 (5 * 8)) + (bytes [6] * pow2 (6 * 8)) + (bytes [7] * pow2 (7 * 8 ,)) + (bytes [8] * pow2 (8 * 8)) + (bytes [9] * pow2 (9 * 8)) + (bytes [10] * pow2 (10 * 8)) + (bytes [11] * pow2 (11 * 8)) + (bytes [12] * pow2 (12 * 8)) + (bytes [13] * pow2 (13 * 8)) + (bytes [14] * pow2 (14 * 8)) + (bytes [15] * pow2 (15 * 8)) + (bytes [16] * pow2 (16 * 8)) + (bytes [17] * pow2 (17 * 8)) + (bytes [18] * pow2 (18 * 8)) + (bytes [19] * pow2 (19 * 8)) + (bytes [20] * pow2 (20 * 8)) + (bytes [21] * pow2 (21 * 8)) + (bytes [22] * pow2 (22 * 8)) + (bytes [23] * pow2 (23 * 8)) + (bytes [24] * pow2 (24 * 8)) + ((bytes [25] as nat % pow2 (4)) * pow2 ((25 * 8) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_0123().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb3",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 946,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb3(input: &[u8])",
      "requires_clauses": [
        "19 + 7 < input . len ()"
      ],
      "ensures_clauses": [
        "((spec_load8_at (input , 19) as u64) >> 1) & mask51 == (input [19] as nat / pow2 (1)) + (input [20] * pow2 ((1 * 8 - 1) as nat)) + (input [21] * pow2 ((2 * 8 - 1) as nat)) + (input [22] * pow2 ((3 * 8 - 1) as nat)) + (input [23] * pow2 ((4 * 8 - 1) as nat)) + (input [24] * pow2 ((5 * 8 - 1) as nat)) + ((input [25] as nat % pow2 (4)) * pow2 ((6 * 8 - 1) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb3().",
      "source": "project"
    },
    {
      "name": "lemma_from_bytes_as_nat_01234",
      "file_path": "src/lemmas/field_lemmas/from_bytes_lemmas.rs",
      "line_number": 310,
      "documentation": "",
      "signature": "pub fn lemma_from_bytes_as_nat_01234(bytes: &[u8; 32])",
      "requires_clauses": [],
      "ensures_clauses": [
        "(spec_load8_at (bytes , 0) as u64 & mask51) + pow2 (51) * ((spec_load8_at (bytes , 6) as u64 >> 3) & mask51) + pow2 (102) * ((spec_load8_at (bytes , 12) as u64 >> 6) & mask51) + pow2 (153 ,) * ((spec_load8_at (bytes , 19) as u64 >> 1) & mask51) + pow2 (204) * ((spec_load8_at (bytes , 24 ,) as u64 >> 12) & mask51) == (bytes [0] * pow2 (0 * 8)) + (bytes [1] * pow2 (1 * 8)) + (bytes [2] * pow2 (2 * 8)) + (bytes [3] * pow2 (3 * 8)) + (bytes [4] * pow2 (4 * 8)) + (bytes [5] * pow2 (5 * 8 ,)) + (bytes [6] * pow2 (6 * 8)) + (bytes [7] * pow2 (7 * 8)) + (bytes [8] * pow2 (8 * 8)) + (bytes [9] * pow2 (9 * 8)) + (bytes [10] * pow2 (10 * 8)) + (bytes [11] * pow2 (11 * 8)) + (bytes [12] * pow2 (12 * 8)) + (bytes [13] * pow2 (13 * 8)) + (bytes [14] * pow2 (14 * 8)) + (bytes [15] * pow2 (15 * 8)) + (bytes [16] * pow2 (16 * 8)) + (bytes [17] * pow2 (17 * 8)) + (bytes [18] * pow2 (18 * 8)) + (bytes [19] * pow2 (19 * 8)) + (bytes [20] * pow2 (20 * 8)) + (bytes [21] * pow2 (21 * 8)) + (bytes [22] * pow2 (22 * 8)) + (bytes [23] * pow2 (23 * 8)) + (bytes [24] * pow2 (24 * 8)) + (bytes [25] * pow2 (25 * 8)) + (bytes [26] * pow2 (26 * 8)) + (bytes [27] * pow2 (27 * 8)) + (bytes [28] * pow2 (28 * 8)) + (bytes [29] * pow2 (29 * 8)) + (bytes [30] * pow2 (30 * 8)) + ((bytes [31] as nat % pow2 (7)) * pow2 ((31 * 8) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 from_bytes_lemmas/field_lemmas/lemmas/lemma_from_bytes_as_nat_01234().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb4",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 982,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb4(input: &[u8])",
      "requires_clauses": [
        "24 + 7 < input . len ()"
      ],
      "ensures_clauses": [
        "((spec_load8_at (input , 24) as u64) >> 12) & mask51 == (input [25] as nat / pow2 (4)) + (input [26] * pow2 ((2 * 8 - 12) as nat)) + (input [27] * pow2 ((3 * 8 - 12) as nat)) + (input [28] * pow2 ((4 * 8 - 12) as nat)) + (input [29] * pow2 ((5 * 8 - 12) as nat)) + (input [30] * pow2 ((6 * 8 - 12) as nat)) + ((input [31] as nat % pow2 (7)) * pow2 ((7 * 8 - 12) as nat ,))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb4().",
      "source": "project"
    },
    {
      "name": "lemma_byte_sum_equals_limb_sum",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 66,
      "documentation": "Core algebraic lemma: The sum of bytes equals the sum of limbs\nThis is where we do the heavy algebraic lifting to show the equivalence",
      "signature": "fn lemma_byte_sum_equals_limb_sum(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "u8_32_as_nat (& bytes) == u64_5_as_nat (limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_sum_equals_limb_sum().",
      "source": "project"
    },
    {
      "name": "lemma_limb0_contribution_correctness",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 243,
      "documentation": "Proves that limb 0's byte contribution equals limbs[0] * pow2(0) = limbs[0]",
      "signature": "fn lemma_limb0_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [0] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb0_byte_contribution (limbs , bytes) == limbs [0] as nat"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb0_contribution_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_limb1_contribution_correctness",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 558,
      "documentation": "Proves that limb 1's byte contribution equals limbs[1] * pow2(51)",
      "signature": "fn lemma_limb1_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [0] < pow2 (51)",
        "limbs [1] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb1_byte_contribution (limbs , bytes) == limbs [1] as nat * pow2 (51)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb1_contribution_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_limb2_contribution_correctness",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 948,
      "documentation": "Proves that limb 2's byte contribution equals limbs[2] * pow2(102)",
      "signature": "fn lemma_limb2_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [1] < pow2 (51)",
        "limbs [2] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb2_byte_contribution (limbs , bytes) == limbs [2] as nat * pow2 (102)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb2_contribution_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_limb3_contribution_correctness",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 1326,
      "documentation": "Proves that limb 3's byte contribution equals limbs[3] * pow2(153)",
      "signature": "fn lemma_limb3_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [2] < pow2 (51)",
        "limbs [3] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb3_byte_contribution (limbs , bytes) == limbs [3] as nat * pow2 (153)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb3_contribution_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_limb4_contribution_correctness",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 1663,
      "documentation": "Proves that limb 4's byte contribution equals limbs[4] * pow2(204)",
      "signature": "fn lemma_limb4_contribution_correctness(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "limbs [3] < pow2 (51)",
        "limbs [4] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "limb4_byte_contribution (limbs , bytes) == limbs [4] as nat * pow2 (204)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_limb4_contribution_correctness().",
      "source": "project"
    },
    {
      "name": "lemma_sum_equals_byte_nat",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 2057,
      "documentation": "Proves that the sum of all limb contributions equals u8_32_as_nat(&bytes)",
      "signature": "fn lemma_sum_equals_byte_nat(limbs: [u64; 5], bytes: [u8; 32])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < pow2 (51)",
        "bytes_match_limbs_packing (limbs , bytes)"
      ],
      "ensures_clauses": [
        "u8_32_as_nat (& bytes) == limb0_byte_contribution (limbs , bytes) + limb1_byte_contribution (limbs , bytes ,) + limb2_byte_contribution (limbs , bytes) + limb3_byte_contribution (limbs , bytes) + limb4_byte_contribution (limbs , bytes)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_sum_equals_byte_nat().",
      "source": "project"
    },
    {
      "name": "lemma_byte_from_limb_shift",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 133,
      "documentation": "Helper: A byte formed by simple right shift has a direct arithmetic interpretation",
      "signature": "fn lemma_byte_from_limb_shift(limb: u64, shift: u64, byte: u8)",
      "requires_clauses": [
        "limb < pow2 (51)",
        "shift < 64",
        "byte == (limb >> shift) as u8"
      ],
      "ensures_clauses": [
        "byte as nat == (limb as nat / pow2 (shift as nat)) % 256"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_byte_from_limb_shift().",
      "source": "project"
    },
    {
      "name": "lemma_5_bytes_reconstruct",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 413,
      "documentation": "Helper: 5-byte reconstruction lemma\nProves that 5 consecutive bytes reconstruct a 40-bit value",
      "signature": "fn lemma_5_bytes_reconstruct(value: nat, byte0: u8, byte1: u8, byte2: u8, byte3: u8, byte4: u8)",
      "requires_clauses": [
        "byte0 as nat == (value / pow2 (0)) % 256",
        "byte1 as nat == (value / pow2 (8)) % 256",
        "byte2 as nat == (value / pow2 (16)) % 256",
        "byte3 as nat == (value / pow2 (24)) % 256",
        "byte4 as nat == (value / pow2 (32)) % 256",
        "value < pow2 (40)"
      ],
      "ensures_clauses": [
        "byte0 as nat * pow2 (0) + byte1 as nat * pow2 (8) + byte2 as nat * pow2 (16) + byte3 as nat * pow2 (24) + byte4 as nat * pow2 (32) == value"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_5_bytes_reconstruct().",
      "source": "project"
    },
    {
      "name": "lemma_div_basics_2",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": null,
      "documentation": "Proof for basic property that `x` divided by 1 is `x`.",
      "signature": "pub fn lemma_div_basics_2(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x / 1) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_div_basics_2().",
      "source": "project"
    },
    {
      "name": "lemma_boundary_byte_combines",
      "file_path": "src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs",
      "line_number": 1929,
      "documentation": "",
      "signature": "fn lemma_boundary_byte_combines(low_limb: u64, high_limb: u64, byte: u8, low_shift: nat, low_bits: nat)",
      "requires_clauses": [
        "low_limb < pow2 (51)",
        "high_limb < pow2 (51)",
        "low_bits < 8",
        "low_shift + low_bits == 51",
        "byte == ((low_limb >> low_shift) | (high_limb << low_bits)) as u8"
      ],
      "ensures_clauses": [
        "byte as nat == (low_limb as nat / pow2 (low_shift)) % pow2 (low_bits) + (high_limb as nat % pow2 ((8 - low_bits) as nat)) * pow2 (low_bits)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 limbs_to_bytes_lemmas/field_lemmas/lemmas/lemma_boundary_byte_combines().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_plus_version_rec_is_bounded",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 59,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)",
      "requires_clauses": [
        "k <= 7"
      ],
      "ensures_clauses": [
        "load8_at_plus_version_rec (input , i , k) < pow2 (8 * (k + 1))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_rec_is_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_plus_version_is_spec_aux",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 130,
      "documentation": "",
      "signature": "fn lemma_load8_at_plus_version_is_spec_aux(input: &[u8], i: usize, j: nat)",
      "requires_clauses": [
        "1 <= j <= 7"
      ],
      "ensures_clauses": [
        "(input [i + j] as u64) << 8 * j == pow2 (j * 8) * input [i + j]",
        "input [i + j] * pow2 (j * 8) <= u64 :: MAX",
        "pow2 (8 * (j + 1)) - 1 <= pow2 (64) - 1",
        "pow2 (8) * pow2 (8 * j) == pow2 (8 * (j + 1))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_version_is_spec_aux().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_plus_fits_u64",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 260,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_plus_fits_u64(input: &[u8], i: usize, k: nat)",
      "requires_clauses": [
        "i + k < input . len ()",
        "0 < k <= 7"
      ],
      "ensures_clauses": [
        "load8_at_plus_version_rec (input , i , (k - 1) as nat) + pow2 (k * 8) * input [i + k] <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_plus_fits_u64().",
      "source": "project"
    },
    {
      "name": "lemma_load8_plus_ver_div_mod",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 300,
      "documentation": "",
      "signature": "pub fn lemma_load8_plus_ver_div_mod(input: &[u8], i: usize, k: nat, s: nat)",
      "requires_clauses": [
        "i + 7 < input . len ()",
        "0 < k <= 7",
        "s < 64"
      ],
      "ensures_clauses": [
        "load8_at_plus_version_rec (input , i , k) / (pow2 (s) as u64) == load8_at_plus_version_rec (input , i , (k - 1) as nat ,) / (pow2 (s) as u64) + (pow2 (k * 8) * input [i + k]) as u64 / (pow2 (s) as u64)",
        "load8_at_plus_version_rec (input , i , k) % (pow2 (s) as u64) == load8_at_plus_version_rec (input , i , (k - 1) as nat ,) % (pow2 (s) as u64) + (pow2 (k * 8) * input [i + k]) as u64 % (pow2 (s) as u64)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_plus_ver_div_mod().",
      "source": "project"
    },
    {
      "name": "lemma_load8_shift_mod_aux",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 367,
      "documentation": "",
      "signature": "fn lemma_load8_shift_mod_aux(s_jplus1: u64, s_j: u64, a_jplus1: u64, x: u8, j: nat, s: nat, t: nat)",
      "requires_clauses": [
        "s_j < pow2 (j * 8)",
        "s_j + x * pow2 (j * 8) <= u64 :: MAX",
        "a_jplus1 == (x * pow2 (j * 8)) as u64",
        "s_jplus1 == s_j + a_jplus1",
        "s_jplus1 / (pow2 (s) as u64) == s_j / (pow2 (s) as u64) + a_jplus1 / (pow2 (s) as u64)",
        "0 <= j <= 7",
        "s < 64",
        "t < 64",
        "0 < pow2 (s) <= u64 :: MAX",
        "0 < pow2 (t) <= u64 :: MAX"
      ],
      "ensures_clauses": [
        "(s_jplus1 / (pow2 (s) as u64)) % (pow2 (t) as u64) == (s_j / (pow2 (s) as u64)) % (pow2 (t ,) as u64) + (a_jplus1 / (pow2 (s) as u64)) % (pow2 (t) as u64)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod_aux().",
      "source": "project"
    },
    {
      "name": "lemma_load8_shift_mod",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 436,
      "documentation": "",
      "signature": "pub fn lemma_load8_shift_mod(input: &[u8], i: usize, s64: u64, t: nat)",
      "requires_clauses": [
        "i + 7 < input . len ()",
        "s64 < 64",
        "t < 64"
      ],
      "ensures_clauses": [
        "(spec_load8_at (input , i) as u64 >> s64) & (low_bits_mask (t) as u64) == ((pow2 (0 * 8) * input [i + 0]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (1 * 8) * input [i + 1]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (2 * 8) * input [i + 2]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (3 * 8) * input [i + 3]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (4 * 8) * input [i + 4]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (5 * 8) * input [i + 5]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (6 * 8) * input [i + 6]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64) + ((pow2 (7 * 8) * input [i + 7]) as u64 / (pow2 (s64 as nat) as u64)) % (pow2 (t) as u64)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_shift_mod().",
      "source": "project"
    },
    {
      "name": "lemma_mul_basics_4",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": null,
      "documentation": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
      "signature": "pub fn lemma_mul_basics_4(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (1 * x) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_basics_4().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb_base",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 662,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb_base(input: &[u8], i: usize, k: u64)",
      "requires_clauses": [
        "i + 7 < input . len ()",
        "k < 64"
      ],
      "ensures_clauses": [
        "0 < pow2 (51) <= u64 :: MAX",
        "spec_load8_at (input , i) <= u64 :: MAX",
        "((spec_load8_at (input , i) as u64) >> k) & mask51 == (((input [i + 0] * pow2 (0 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 1] * pow2 (1 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 2] * pow2 (2 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 3] * pow2 (3 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 4] * pow2 (4 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 5] * pow2 (5 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 6] * pow2 (6 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 7] * pow2 (7 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_base().",
      "source": "project"
    },
    {
      "name": "lemma_load8_at_limb_X",
      "file_path": "src/lemmas/field_lemmas/load8_lemmas.rs",
      "line_number": 735,
      "documentation": "",
      "signature": "pub fn lemma_load8_at_limb_X(input: &[u8], i: usize, k: nat, j_div: nat, j_id: nat, j_shift: nat)",
      "requires_clauses": [
        "i + 7 < input . len ()",
        "k <= 12",
        "forall | j : nat | 0 <= j < j_div ==> pow2_mul_div_mod_small_mul_u8_t51_cond (k , j)",
        "forall | j : nat | j_div <= j < j_id ==> pow2_mul_div_mod_small_div_u8_t51_cond (k , j)",
        "forall | j : nat | j_id <= j < j_shift ==> pow2_mul_div_mod_close_mod_u8_t51_cond (k , j)",
        "forall | j : nat | j_shift <= j < 8 ==> pow2_mul_div_mod_small_mod_u8_t51_cond (k , j)"
      ],
      "ensures_clauses": [
        "forall | j : nat | 0 <= j < j_div ==> # [trigger] ((input [(i + j) as int] * pow2 (j * 8)) as u64 / (pow2 (k ,) as u64)) % (pow2 (51) as u64) == (input [(i + j) as int]) as nat / pow2 ((k - j * 8) as nat ,)",
        "forall | j : nat | j_div <= j < j_id ==> # [trigger] ((input [(i + j) as int] * pow2 (j * 8)) as u64 / (pow2 (k ,) as u64)) % (pow2 (51) as u64) == (input [(i + j) as int]) * pow2 ((j * 8 - k) as nat)",
        "forall | j : nat | j_id <= j < j_shift ==> # [trigger] ((input [(i + j) as int] * pow2 (j * 8)) as u64 / (pow2 (k) as u64)) % (pow2 (51) as u64) == (input [(i + j) as int] as nat % pow2 ((51 - (j * 8 - k)) as nat ,)) * pow2 ((j * 8 - k) as nat)",
        "forall | j : nat | j_shift <= j < 8 ==> # [trigger] ((input [(i + j) as int] * pow2 (j * 8)) as u64 / (pow2 (k ,) as u64)) % (pow2 (51) as u64) == 0",
        "(spec_load8_at (input , i) as u64 >> k) & mask51 == (((input [i + 0] * pow2 (0 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 1] * pow2 (1 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 2] * pow2 (2 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 3] * pow2 (3 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 4] * pow2 (4 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 5] * pow2 (5 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 6] * pow2 (6 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64) + (((input [i + 7] * pow2 (7 * 8)) as u64) / (pow2 (k as nat) as u64)) % (pow2 (51) as u64)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 load8_lemmas/field_lemmas/lemmas/lemma_load8_at_limb_X().",
      "source": "project"
    },
    {
      "name": "lemma_as_nat_prefix_bounded",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 34,
      "documentation": "Helper: Bound as_nat_prefix - geometric series bound\nEach byte contributes at most 255 * pow2(j*8) < pow2((j+1)*8)",
      "signature": "pub fn lemma_as_nat_prefix_bounded(bytes: &[u8; 32], n: nat)",
      "requires_clauses": [
        "n <= 32"
      ],
      "ensures_clauses": [
        "as_nat_prefix (bytes , n) < pow2 ((n * 8) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_decomposition_prefix_rec",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 81,
      "documentation": "Lemma: Decomposition of u8_32_as_nat_rec into prefix and suffix\nThis is the key structural insight: the recursive sum can be split at any point",
      "signature": "pub fn lemma_decomposition_prefix_rec(bytes: &[u8; 32], n: nat)",
      "requires_clauses": [
        "n <= 32"
      ],
      "ensures_clauses": [
        "u8_32_as_nat_rec (bytes , 0) == as_nat_prefix (bytes , n) + u8_32_as_nat_rec (bytes , n)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_decomposition_prefix_rec().",
      "source": "project"
    },
    {
      "name": "lemma_rec_suffix_divisible",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 110,
      "documentation": "Lemma: The suffix u8_32_as_nat_rec(bytes, n) is divisible by pow2(n*8)\nEvery term in the sum has a factor of pow2(j*8) where j >= n, so the whole sum is divisible by pow2(n*8)\n\nNOTE: Uses lemma_mod_breakdown and lemma_mod_sum_both_divisible from vstd/common_lemmas",
      "signature": "pub fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)",
      "requires_clauses": [
        "n <= 32"
      ],
      "ensures_clauses": [
        "u8_32_as_nat_rec (bytes , n) % pow2 ((n * 8) as nat) == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_rec_suffix_divisible().",
      "source": "project"
    },
    {
      "name": "lemma_u8_32_as_nat_mod_truncates",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 169,
      "documentation": "Lemma 1: Modulo truncates u8_32_as_nat to the first n bytes\n\nThis is the KEY lemma: taking modulo pow2(n*8) naturally truncates all bytes\nbeyond index n-1, leaving only the contribution of the first n bytes.",
      "signature": "pub fn lemma_u8_32_as_nat_mod_truncates(bytes: &[u8; 32], n: nat)",
      "requires_clauses": [
        "n <= 32"
      ],
      "ensures_clauses": [
        "u8_32_as_nat (bytes) % pow2 (n * 8) == as_nat_prefix (bytes , n)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_u8_32_as_nat_mod_truncates().",
      "source": "project"
    },
    {
      "name": "lemma_as_nat_prefix_div_extracts_byte",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 248,
      "documentation": "Lemma 2: Division extracts a specific byte from a prefix\n\nOnce we have the first i+1 bytes via modulo, dividing by pow2(i*8)\nshifts right by i bytes, leaving byte i in the lowest position.",
      "signature": "pub fn lemma_as_nat_prefix_div_extracts_byte(bytes: &[u8; 32], i: nat)",
      "requires_clauses": [
        "i < 32"
      ],
      "ensures_clauses": [
        "(as_nat_prefix (bytes , i + 1) / pow2 (i * 8)) % pow2 (8) == bytes [i as int] as nat"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_as_nat_prefix_div_extracts_byte().",
      "source": "project"
    },
    {
      "name": "lemma_extract_byte_at_index",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 302,
      "documentation": "Main Theorem: Extract byte i using modulo approach\n\nUsing lemma_pow2_div_mod and the modulo truncation approach,\nwe can extract any byte from u8_32_as_nat via division and modulo.",
      "signature": "pub fn lemma_extract_byte_at_index(bytes: &[u8; 32], i: nat)",
      "requires_clauses": [
        "i < 32"
      ],
      "ensures_clauses": [
        "bytes [i as int] as nat == (u8_32_as_nat (bytes) / pow2 (i * 8)) % pow2 (8)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_extract_byte_at_index().",
      "source": "project"
    },
    {
      "name": "lemma_canonical_bytes_equal",
      "file_path": "src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs",
      "line_number": 343,
      "documentation": "Main theorem: u8_32_as_nat is injective\n\nIf two 32-byte arrays have the same u8_32_as_nat value, then they are\nequal byte-by-byte. This is proven by extracting each byte using\nlemma_extract_byte_at_index and showing they must be equal.",
      "signature": "pub fn lemma_canonical_bytes_equal(bytes1: &[u8; 32], bytes2: &[u8; 32])",
      "requires_clauses": [
        "u8_32_as_nat (bytes1) == u8_32_as_nat (bytes2)"
      ],
      "ensures_clauses": [
        "forall | i : int | 0 <= i < 32 ==> bytes1 [i] == bytes2 [i]"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 u8_32_as_nat_injectivity_lemmas/field_lemmas/lemmas/lemma_canonical_bytes_equal().",
      "source": "project"
    },
    {
      "name": "lemma_mod_multiples_vanish",
      "file_path": "src/lemmas/field_lemmas/reduce_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that adding any multiple of the divisor to the dividend will produce the\nsame remainder. In other words, `(m * a + b) % m == b % m`.",
      "signature": "pub fn lemma_mod_multiples_vanish(a: int, b: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "# [trigger] ((m * a + b) % m) == b % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "source": "project"
    },
    {
      "name": "lemma_bounded_shr_51",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 23,
      "documentation": "",
      "signature": "pub fn lemma_bounded_shr_51(x: u64)",
      "requires_clauses": [
        "x < 3 * pow2 (51)"
      ],
      "ensures_clauses": [
        "(x >> 51) < 3"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_bounded_shr_51().",
      "source": "project"
    },
    {
      "name": "lemma_radix51_telescoping_expansion",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 39,
      "documentation": "Helper lemma: Proves the algebraic expansion and cancellation of intermediate terms\nShows that when expanding the substituted limbs, q0, q1, q2, q3 all cancel out",
      "signature": "fn lemma_radix51_telescoping_expansion(q0: int, q1: int, q2: int, q3: int, q4: int, r0: int, r1: int, r2: int, r3: int, r4: int)",
      "requires_clauses": [
        "true"
      ],
      "ensures_clauses": [
        "(q0 * pow2 (51) as int + r0 - 19) + (q1 * pow2 (51) as int + r1 - q0) * pow2 (51) as int + (q2 * pow2 (51) as int + r2 - q1) * pow2 (102) as int + (q3 * pow2 (51) as int + r3 - q2) * pow2 (153) as int + (q4 * pow2 (51) as int + r4 - q3) * pow2 (204) as int + 19 == q4 * pow2 (51) as int * pow2 (204) as int + r0 + r1 * pow2 (51) as int + r2 * pow2 (102) as int + r3 * pow2 (153) as int + r4 * pow2 (204) as int"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_expansion().",
      "source": "project"
    },
    {
      "name": "lemma_radix51_telescoping_direct",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 138,
      "documentation": "Direct proof of telescoping division for radix-51 representation\nUses repeated substitution to show q4 = (u64_5_as_nat(limbs) + 19) / 2^255\n\nProof strategy:\n1. Express u64_5_as_nat(limbs) + 19 as a sum using radix-51: \u03a3 limbs[i] * 2^(51*i) + 19\n2. Substitute each limb using the division theorem equations (from requires clause)\n3. Expand and observe that intermediate q_i terms telescope (cancel out):\n   - q0 appears as: +q0*2^51 - q0*2^51 = 0\n   - q1 appears as: +q1*2^102 - q1*2^102 = 0  (and so on)\n4. After cancellation: value = q4 * 2^255 + remainder, where remainder < 2^255\n5. By uniqueness of division, q4 = value / 2^255",
      "signature": "pub fn lemma_radix51_telescoping_direct(limbs: [u64; 5], q0: int, q1: int, q2: int, q3: int, q4: int, r0: int, r1: int, r2: int, r3: int, r4: int)",
      "requires_clauses": [
        "limbs [0] as int + 19 == q0 * pow2 (51) as int + r0",
        "limbs [1] as int + q0 == q1 * pow2 (51) as int + r1",
        "limbs [2] as int + q1 == q2 * pow2 (51) as int + r2",
        "limbs [3] as int + q2 == q3 * pow2 (51) as int + r3",
        "limbs [4] as int + q3 == q4 * pow2 (51) as int + r4",
        "0 <= r0 < pow2 (51) as int",
        "0 <= r1 < pow2 (51) as int",
        "0 <= r2 < pow2 (51) as int",
        "0 <= r3 < pow2 (51) as int",
        "0 <= r4 < pow2 (51) as int"
      ],
      "ensures_clauses": [
        "q4 == (u64_5_as_nat (limbs) as int + 19) / pow2 (255) as int"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_telescoping_direct().",
      "source": "project"
    },
    {
      "name": "lemma_radix51_remainder_bound",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 249,
      "documentation": "Helper: Proves the remainder from radix-51 representation is bounded by 2^255",
      "signature": "pub fn lemma_radix51_remainder_bound(r0: int, r1: int, r2: int, r3: int, r4: int)",
      "requires_clauses": [
        "0 <= r0 < (pow2 (51) as int)",
        "0 <= r1 < (pow2 (51) as int)",
        "0 <= r2 < (pow2 (51) as int)",
        "0 <= r3 < (pow2 (51) as int)",
        "0 <= r4 < (pow2 (51) as int)"
      ],
      "ensures_clauses": [
        "r0 + r1 * (pow2 (51) as int) + r2 * (pow2 (102) as int) + r3 * (pow2 (153) as int) + r4 * (pow2 (204) as int) < (pow2 (255) as int)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_radix51_remainder_bound().",
      "source": "project"
    },
    {
      "name": "lemma_carry_propagation_setup",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 290,
      "documentation": "Helper: Establishes basic power-of-2 facts needed for carry propagation",
      "signature": "pub fn lemma_carry_propagation_setup()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(1u64 << 51) == pow2 (51)",
        "(1u64 << 52) == pow2 (52)",
        "pow2 (52) == 2 * pow2 (51)",
        "19 < pow2 (51)",
        "3 * pow2 (51) <= u64 :: MAX"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_setup().",
      "source": "project"
    },
    {
      "name": "lemma_single_stage_division",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 321,
      "documentation": "Helper: Proves the division relationship for a single carry propagation stage\nGiven limb_i and carry_in q_{i-1}, computes q_i = (limb_i + q_{i-1}) >> 51\nand establishes the division theorem relationship\n\nNote: carry_in is typically < 3 for stages 1-4, but equals 19 for stage 0",
      "signature": "pub fn lemma_single_stage_division(limb: u64, carry_in: u64, stage_input: u64, carry_out: u64)",
      "requires_clauses": [
        "limb < (1u64 << 52)",
        "limb + carry_in <= u64 :: MAX",
        "stage_input == (limb + carry_in) as u64",
        "stage_input < 3 * pow2 (51)",
        "carry_out == (stage_input >> 51) as u64"
      ],
      "ensures_clauses": [
        "carry_out < 3",
        "carry_out as int == (limb as int + carry_in as int) / pow2 (51) as int"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_single_stage_division().",
      "source": "project"
    },
    {
      "name": "lemma_stage_division_theorem",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 346,
      "documentation": "Helper: Establishes division theorem for a single stage\nGiven the inputs and outputs of a stage, proves the division/modulo relationship\n\nNote: carry_in is typically < 3 for stages 1-4, but equals 19 for stage 0",
      "signature": "pub fn lemma_stage_division_theorem(limb: u64, carry_in: int, carry_out: int) -> int",
      "requires_clauses": [
        "limb < (1u64 << 52)",
        "carry_out == (limb as int + carry_in) / pow2 (51) as int"
      ],
      "ensures_clauses": [
        "(limb as int + carry_in) == carry_out * pow2 (51) as int + r",
        "0 <= r < pow2 (51) as int"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_stage_division_theorem().",
      "source": "project"
    },
    {
      "name": "lemma_carry_propagation_is_division",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 367,
      "documentation": "Helper lemma: proves that the carry propagation computes the division by 2^255\nThis shows that q represents (u64_5_as_nat(limbs) + 19) / 2^255\n\nRefactored into smaller pieces for better readability and maintainability.",
      "signature": "pub fn lemma_carry_propagation_is_division(limbs: [u64; 5], q: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)",
        "q == compute_q_spec (limbs)"
      ],
      "ensures_clauses": [
        "q as nat == (u64_5_as_nat (limbs) + 19) / pow2 (255)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_carry_propagation_is_division().",
      "source": "project"
    },
    {
      "name": "lemma_all_carries_bounded_by_3",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 428,
      "documentation": "Helper: Proves all intermediate carries are bounded by 3",
      "signature": "pub fn lemma_all_carries_bounded_by_3(limbs: [u64; 5])",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)"
      ],
      "ensures_clauses": [
        "({ let q0 = ((limbs [0] + 19) as u64 >> 51) as u64 ; let q1 = ((limbs [1] + q0) as u64 >> 51) as u64 ; let q2 = ((limbs [2] + q1) as u64 >> 51) as u64 ; let q3 = ((limbs [3] + q2) as u64 >> 51) as u64 ; let q4 = ((limbs [4] + q3) as u64 >> 51) as u64 ; q0 < 3 && q1 < 3 && q2 < 3 && q3 < 3 && q4 < 3 })"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_all_carries_bounded_by_3().",
      "source": "project"
    },
    {
      "name": "lemma_q_is_binary",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 472,
      "documentation": "Helper: Proves q can only be 0 or 1 (not 2)\nAlso establishes the division relationship for reuse",
      "signature": "pub fn lemma_q_is_binary(limbs: [u64; 5], q: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)",
        "u64_5_as_nat (limbs) < 2 * p ()",
        "q == compute_q_spec (limbs)",
        "q < 3"
      ],
      "ensures_clauses": [
        "q == 0 || q == 1",
        "q as nat == (u64_5_as_nat (limbs) + 19) / pow2 (255)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_is_binary().",
      "source": "project"
    },
    {
      "name": "lemma_q_biconditional",
      "file_path": "src/lemmas/field_lemmas/compute_q_lemmas.rs",
      "line_number": 508,
      "documentation": "Unified helper: Proves the biconditional relationship between u64_5_as_nat and q\n\nWith the tight bound u64_5_as_nat(limbs) < 2*p(), the value is either in [0, p) or [p, 2*p),\nwhich maps directly to q=0 or q=1. This makes the biconditional proofs straightforward.",
      "signature": "pub fn lemma_q_biconditional(limbs: [u64; 5], q: u64)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < 5 ==> limbs [i] < (1u64 << 52)",
        "u64_5_as_nat (limbs) < 2 * p ()",
        "q == compute_q_spec (limbs)",
        "q as nat == (u64_5_as_nat (limbs) + 19) / pow2 (255)",
        "q == 0 || q == 1"
      ],
      "ensures_clauses": [
        "u64_5_as_nat (limbs) >= p () <==> q == 1",
        "u64_5_as_nat (limbs) < p () <==> q == 0"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 compute_q_lemmas/field_lemmas/lemmas/lemma_q_biconditional().",
      "source": "project"
    },
    {
      "name": "lemma_reorder_mul",
      "file_path": "src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "line_number": 24,
      "documentation": "",
      "signature": "pub fn lemma_reorder_mul(a: int, b: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "2 * (a * (19 * b)) == 19 * (2 * (a * b))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_reorder_mul().",
      "source": "project"
    },
    {
      "name": "lemma_term_product_bounds",
      "file_path": "src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "line_number": 138,
      "documentation": "",
      "signature": "pub fn lemma_term_product_bounds(a: [u64; 5], bound: u64)",
      "requires_clauses": [
        "19 * bound <= u64 :: MAX",
        "forall | i : int | 0 <= i < 5 ==> a [i] < bound"
      ],
      "ensures_clauses": [
        "term_product_bounds_spec (a , bound)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_term_product_bounds().",
      "source": "project"
    },
    {
      "name": "lemma_c_i_0_bounded",
      "file_path": "src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "line_number": 166,
      "documentation": "",
      "signature": "pub fn lemma_c_i_0_bounded(a: [u64; 5], bound: u64)",
      "requires_clauses": [
        "19 * bound <= u64 :: MAX",
        "forall | i : int | 0 <= i < 5 ==> a [i] < bound"
      ],
      "ensures_clauses": [
        "ci_0_val_boundaries (a , bound)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_0_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_c_i_shift_bounded",
      "file_path": "src/lemmas/field_lemmas/pow2k_lemmas.rs",
      "line_number": 184,
      "documentation": "",
      "signature": "pub fn lemma_c_i_shift_bounded(a: [u64; 5], bound: u64)",
      "requires_clauses": [
        "19 * bound <= u64 :: MAX",
        "77 * (bound * bound) + u64 :: MAX <= ((u64 :: MAX as u128) << 51)",
        "ci_0_val_boundaries (a , bound)"
      ],
      "ensures_clauses": [
        "ci_val_boundaries (a)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 pow2k_lemmas/field_lemmas/lemmas/lemma_c_i_shift_bounded().",
      "source": "project"
    },
    {
      "name": "lemma_seq_from32_equals_spec_bytes",
      "file_path": "src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "line_number": 188,
      "documentation": "Helper lemma: Converting bytes to seq equals spec when both represent same value\n\nKey insight: as_bytes() and spec_fe51_to_bytes() follow the EXACT same algorithm:\n1. Both call spec_reduce on the limbs\n2. Both compute q using identical formulas\n3. Both pack bytes identically (matching bytes_match_limbs_packing)\nTherefore, they produce identical bytes!",
      "signature": "fn lemma_seq_from32_equals_spec_bytes(fe: &FieldElement51, bytes: &[u8; 32])",
      "requires_clauses": [
        "u8_32_as_nat (bytes) == u64_5_as_nat (fe . limbs) % p ()",
        "u8_32_as_nat (bytes) < p ()"
      ],
      "ensures_clauses": [
        "seq_from32 (bytes) == spec_fe51_to_bytes (fe)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_seq_from32_equals_spec_bytes().",
      "source": "project"
    },
    {
      "name": "lemma_spec_fe51_to_bytes_matches_array",
      "file_path": "src/lemmas/field_lemmas/as_bytes_lemmas.rs",
      "line_number": 230,
      "documentation": "Lemma: spec_fe51_to_bytes produces the same bytes as as_bytes, element by element",
      "signature": "fn lemma_spec_fe51_to_bytes_matches_array(fe: &FieldElement51, bytes: &[u8; 32])",
      "requires_clauses": [
        "u8_32_as_nat (bytes) == u64_5_as_nat (fe . limbs) % p ()"
      ],
      "ensures_clauses": [
        "forall | i : int | 0 <= i < 32 ==> spec_fe51_to_bytes (fe) [i] == bytes [i]"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 as_bytes_lemmas/field_lemmas/lemmas/lemma_spec_fe51_to_bytes_matches_array().",
      "source": "project"
    },
    {
      "name": "lemma_mod_is_zero",
      "file_path": "src/lemmas/field_lemmas/negate_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that if `x % m` is zero and `x` is positive, then `x >= m`.",
      "signature": "pub fn lemma_mod_is_zero(x: nat, m: nat)",
      "requires_clauses": [
        "x > 0 && m > 0",
        "# [trigger] (x % m) == 0"
      ],
      "ensures_clauses": [
        "x >= m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_is_zero().",
      "source": "project"
    },
    {
      "name": "lemma_verify_invert_correct",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 36,
      "documentation": "Verification: scalar * scalar.invert() \u2261 1 mod L",
      "signature": "fn lemma_verify_invert_correct(x: Scalar52)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_verify_invert_correct().",
      "source": "project"
    },
    {
      "name": "lemma_nine_limbs_equals_slice128_to_nat",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 172,
      "documentation": "",
      "signature": "pub fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])",
      "requires_clauses": [],
      "ensures_clauses": [
        "nine_limbs_to_nat_aux (limbs) == slice128_to_nat (limbs)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_nine_limbs_equals_slice128_to_nat().",
      "source": "project"
    },
    {
      "name": "lemma_mul_strict_inequality_converse",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that since `x * z < y * z` and `z >= 0`, we know `x < y`.",
      "signature": "pub fn lemma_mul_strict_inequality_converse(x: int, y: int, z: int)",
      "requires_clauses": [
        "# [trigger] (x * z) < # [trigger] (y * z)",
        "z >= 0"
      ],
      "ensures_clauses": [
        "x < y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "source": "project"
    },
    {
      "name": "lemma_montgomery_inverse",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 448,
      "documentation": "",
      "signature": "pub fn lemma_montgomery_inverse()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(montgomery_radix () * inv_montgomery_radix ()) % group_order () == 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_montgomery_inverse().",
      "source": "project"
    },
    {
      "name": "lemma_seq_u64_to_nat_subrange_extend",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 546,
      "documentation": "Need to use induction because the postcondition expands\nseq_u64_to_nat in the opposite way from how it's defined.\nThe base case is straightforward, but it takes a few steps\nto get Verus to prove it.\nInduction case: Take off the first element using definition of\nseq_u64_to_nat, apply induction hypothesis to the remaining sequence,\nthen put the first element back on and simplify all the powers.",
      "signature": "pub fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)",
      "requires_clauses": [
        "0 <= i < seq . len ()"
      ],
      "ensures_clauses": [
        "seq_u64_to_nat (seq . subrange (0 , i + 1)) == seq_u64_to_nat (seq . subrange (0 , i)) + seq [i] * pow2 (52 * i as nat)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_seq_u64_to_nat_subrange_extend().",
      "source": "project"
    },
    {
      "name": "lemma_mod_cancel",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 652,
      "documentation": "Using lemma_mod_add_multiples_vanish in a big proof made the proof hang",
      "signature": "pub fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(group_order () + to_nat (& a . limbs) - to_nat (& b . limbs)) % (group_order () as int) == (to_nat (& a . limbs ,) - to_nat (& b . limbs)) % (group_order () as int)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_mod_cancel().",
      "source": "project"
    },
    {
      "name": "lemma_mod_add_multiples_vanish",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that adding the divisor to the dividend doesn't change the\nremainder. Specifically, `(m + b) % m == b % m`.",
      "signature": "pub fn lemma_mod_add_multiples_vanish(b: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(m + b) % m == # [trigger] (b % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "source": "project"
    },
    {
      "name": "lemma_bound_scalar",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 665,
      "documentation": "The corollary of limbs_bounded(a)",
      "signature": "pub fn lemma_bound_scalar(a: &Scalar52)",
      "requires_clauses": [
        "limbs_bounded (a)"
      ],
      "ensures_clauses": [
        "to_nat (& a . limbs) < pow2 ((52 * (5) as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bound_scalar().",
      "source": "project"
    },
    {
      "name": "lemma_general_bound",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 676,
      "documentation": "The general case of lemma_bound_scalar so we\ncan prove via straightforward induction.",
      "signature": "pub fn lemma_general_bound(a: Seq<u64>)",
      "requires_clauses": [
        "forall | i : int | 0 <= i < a . len () ==> a [i] < (1u64 << 52)"
      ],
      "ensures_clauses": [
        "seq_u64_to_nat (a) < pow2 ((52 * a . len () as nat))"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_general_bound().",
      "source": "project"
    },
    {
      "name": "lemma_decompose",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 759,
      "documentation": "",
      "signature": "pub fn lemma_decompose(a: u64, mask: u64)",
      "requires_clauses": [
        "mask == (1u64 << 52) - 1"
      ],
      "ensures_clauses": [
        "a == (a >> 52) * pow2 (52) + (a & mask)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_decompose().",
      "source": "project"
    },
    {
      "name": "lemma_pow252",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1032,
      "documentation": "",
      "signature": "pub fn lemma_pow252()",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (252) == 0x1000000000000000000000000000000000000000000000000000000000000000"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow252().",
      "source": "project"
    },
    {
      "name": "lemma_pow2_260_greater_than_2_group_order",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1044,
      "documentation": "",
      "signature": "pub fn lemma_pow2_260_greater_than_2_group_order()",
      "requires_clauses": [],
      "ensures_clauses": [
        "pow2 (260) > 2 * group_order ()"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_pow2_260_greater_than_2_group_order().",
      "source": "project"
    },
    {
      "name": "lemma_bytes_to_nat_rec_bound",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1572,
      "documentation": "Helper lemma showing that bytes_to_nat_rec is >= a specific term",
      "signature": "fn lemma_bytes_to_nat_rec_bound(bytes: &[u8; 32], start: usize, target: usize)",
      "requires_clauses": [
        "start <= target < 32"
      ],
      "ensures_clauses": [
        "bytes_to_nat_rec (bytes , start as int) >= (bytes [target as int] as nat) * pow2 ((target * 8) as nat ,)"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_bytes_to_nat_rec_bound().",
      "source": "project"
    },
    {
      "name": "lemma_group_order_is_odd",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": 1656,
      "documentation": "",
      "signature": "pub fn lemma_group_order_is_odd()",
      "requires_clauses": [],
      "ensures_clauses": [
        "group_order () % 2 == 1"
      ],
      "symbol_id": "rust-analyzer cargo curve25519-dalek 4.1.3 scalar_lemmas/lemmas/lemma_group_order_is_odd().",
      "source": "project"
    },
    {
      "name": "lemma_fundamental_div_mod_converse",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": null,
      "documentation": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `q` is the quotient `x / d` and `r` is the remainder `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod_converse(x: int, d: int, q: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d",
        "x == q * d + r"
      ],
      "ensures_clauses": [
        "r == x % d",
        "q == x / d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse().",
      "source": "project"
    },
    {
      "name": "lemma_pow_distributes",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that `a * b` to the power of `e` is equal to the product of\n`a` to the power of `e` and `b` to the power of `e`.",
      "signature": "pub fn lemma_pow_distributes(a: int, b: int, e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (a * b , e) == pow (a , e) * pow (b , e)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power/arithmetic/lemma_pow_distributes().",
      "source": "project"
    },
    {
      "name": "lemma_pow2",
      "file_path": "src/lemmas/scalar_lemmas.rs",
      "line_number": null,
      "documentation": "Proof that `pow2(e)` is equivalent to `pow(2, e)`.",
      "signature": "pub fn lemma_pow2(e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow2 (e) == pow (2 , e) as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-23-0053 power2/arithmetic/lemma_pow2().",
      "source": "project"
    }
  ],
  "has_embeddings": true
}