{
  "version": "1.0",
  "repo_root": "/home/lacra/git_repos/verus/source/vstd",
  "lemmas": [
    {
      "name": "all_spec_ensures",
      "file_path": "vstd.rs",
      "line_number": null,
      "documentation": "",
      "signature": "pub fn all_spec_ensures(r: Range<int>, p: spec_fn(int) -> bool)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 compute/all_spec_ensures().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_by_zero_is_zero",
      "file_path": "arithmetic/overflow.rs",
      "line_number": null,
      "documentation": "Proof that any integer multiplied by 0 results in a product of 0.",
      "signature": "pub fn lemma_mul_by_zero_is_zero(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_by_zero_is_zero().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_inequality",
      "file_path": "arithmetic/overflow.rs",
      "line_number": null,
      "documentation": "Proof that, since `x <= y` and `z >= 0`, `x * z <= y * z`.",
      "signature": "pub fn lemma_mul_inequality(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_inequality().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_commutative",
      "file_path": "arithmetic/overflow.rs",
      "line_number": null,
      "documentation": "Proof that multiplication is commutative, specifically that\n`x * y == y * x`.",
      "signature": "pub fn lemma_mul_is_commutative(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_commutative().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_mul_recursive",
      "file_path": "arithmetic/mul.rs",
      "line_number": 25,
      "documentation": "Proof that multiplication using `*` is equivalent to\nmultiplication using a recursive definition. Specifically,\n`x * y` is equivalent in that way.",
      "signature": "pub fn lemma_mul_is_mul_recursive(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) == mul_recursive (x , y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_mul_recursive().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_mul_pos",
      "file_path": "arithmetic/mul.rs",
      "line_number": 43,
      "documentation": "Proof that multiplying two positive integers with `*` results in\nthe same product as would be achieved by recursive addition.\nSpecifically, `x * y == mul_pos(x, y)`.",
      "signature": "pub fn lemma_mul_is_mul_pos(x: int, y: int)",
      "requires_clauses": [
        "x >= 0"
      ],
      "ensures_clauses": [
        "x * y == mul_pos (x , y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_mul_pos().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_associative",
      "file_path": "arithmetic/mul.rs",
      "line_number": 123,
      "documentation": "Proof that multiplication is associative, specifically that\n`x * (y * z) == (x * y) * z`.",
      "signature": "pub fn lemma_mul_is_associative(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x * (y * z) == (x * y) * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_associative().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_induction_auto",
      "file_path": "arithmetic/mul.rs",
      "line_number": null,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate `f`, proves\nthe predicate holds in the base case of 0, and proves correctness\nof inductive steps both upward and downward from the base case.\nThis lemma invokes induction to establish that the predicate holds\nfor the given integer `x`.\n\nTo prove inductive steps upward from the base case, the caller\nmust establish that, for any `i`, `is_le(0, i)` implies `f(i) ==>\nf(i + 1)`.\n\nTo prove inductive steps downward from the base case, the caller\nmust establish that, for any `i`, `is_le(i, 0)` implies `f(i) ==>\nf(i - 1)`.",
      "signature": "pub fn lemma_mul_induction_auto(x: int, f: spec_fn(int) -> bool)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_induction_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_basics",
      "file_path": "arithmetic/mul.rs",
      "line_number": 53,
      "documentation": "",
      "signature": "pub fn lemma_mul_basics(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 * x == 0",
        "x * 0 == 0",
        "x * 1 == x",
        "1 * x == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_basics().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_basics_1",
      "file_path": "arithmetic/mul.rs",
      "line_number": 64,
      "documentation": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
      "signature": "pub fn lemma_mul_basics_1(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (0 * x) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_basics_1().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_basics_2",
      "file_path": "arithmetic/mul.rs",
      "line_number": 72,
      "documentation": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
      "signature": "pub fn lemma_mul_basics_2(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * 0) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_basics_2().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_basics_3",
      "file_path": "arithmetic/mul.rs",
      "line_number": 80,
      "documentation": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
      "signature": "pub fn lemma_mul_basics_3(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * 1) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_basics_3().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_basics_4",
      "file_path": "arithmetic/mul.rs",
      "line_number": 88,
      "documentation": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
      "signature": "pub fn lemma_mul_basics_4(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (1 * x) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_basics_4().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_nonzero",
      "file_path": "arithmetic/mul.rs",
      "line_number": 102,
      "documentation": "Proof that `x * y` is nonzero if and only if both `x` and `y` are nonzero.",
      "signature": "pub fn lemma_mul_nonzero(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) != 0 <==> x != 0 && y != 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_nonzero().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_nonzero",
      "file_path": "arithmetic/mul.rs",
      "line_number": 101,
      "documentation": "Proof that `x` and `y` are both nonzero if and only if `x * y` is nonzero",
      "signature": "pub fn lemma_mul_nonzero(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) != 0 <==> x != 0 && y != 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals_nonlinear/internals/arithmetic/lemma_mul_nonzero().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_associative",
      "file_path": "arithmetic/mul.rs",
      "line_number": 121,
      "documentation": "Proof that multiplication is associative in this specific case,\ni.e., that `x * y * z` is the same no matter which of the two\nmultiplications is done first",
      "signature": "pub fn lemma_mul_is_associative(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x * (y * z) == (x * y) * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals_nonlinear/internals/arithmetic/lemma_mul_is_associative().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_ordering",
      "file_path": "arithmetic/mul.rs",
      "line_number": 143,
      "documentation": "Proof that, since the product of the two integers `x` and `y` is\nnonnegative, that product is greater than or equal to each of `x`\nand `y`",
      "signature": "pub fn lemma_mul_ordering(x: int, y: int)",
      "requires_clauses": [
        "x != 0",
        "y != 0",
        "0 <= x * y"
      ],
      "ensures_clauses": [
        "# [trigger] (x * y) >= x && x * y >= y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_ordering().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_ordering",
      "file_path": "arithmetic/mul.rs",
      "line_number": 140,
      "documentation": "Proof that the if the product of two nonzero integers `x` and `y`\nis nonnegative, then it's greater than or equal to each of `x` and\n`y`",
      "signature": "pub fn lemma_mul_ordering(x: int, y: int)",
      "requires_clauses": [
        "x != 0",
        "y != 0",
        "0 <= x * y"
      ],
      "ensures_clauses": [
        "# [trigger] (x * y) >= x && x * y >= y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals_nonlinear/internals/arithmetic/lemma_mul_ordering().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strict_inequality",
      "file_path": "arithmetic/mul.rs",
      "line_number": 175,
      "documentation": "Proof that since `x < y` and `z > 0`, `x * z < y * z`.",
      "signature": "pub fn lemma_mul_strict_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "x < y",
        "z > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (x * z) < # [trigger] (y * z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_strict_inequality().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strict_inequality",
      "file_path": "arithmetic/mul.rs",
      "line_number": 174,
      "documentation": "Proof that multiplying by a positive integer preserves inequality\nin this specific case, i.e., that since `x < y` and `z > 0` we can\nconclude that `x * z < y * z`.",
      "signature": "pub fn lemma_mul_strict_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "x < y",
        "z > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (x * z) < # [trigger] (y * z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals_nonlinear/internals/arithmetic/lemma_mul_strict_inequality().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_upper_bound",
      "file_path": "arithmetic/mul.rs",
      "line_number": 188,
      "documentation": "Proof that since `x` is bounded above by `xbound` and `y` is\nbounded above by `ybound`, the product of `x` and `y` is bounded\nabove by the product of the bounds.",
      "signature": "pub fn lemma_mul_upper_bound(x: int, xbound: int, y: int, ybound: int)",
      "requires_clauses": [
        "x <= xbound",
        "y <= ybound",
        "0 <= x",
        "0 <= y"
      ],
      "ensures_clauses": [
        "# [trigger] (x * y) <= # [trigger] (xbound * ybound)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_upper_bound().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strict_upper_bound",
      "file_path": "arithmetic/mul.rs",
      "line_number": 205,
      "documentation": "Proof that when `x` has an exclusive upper bound `xbound` and `y`\nhas an exclusive upper bound `ybound`, that the product of `x` and\n`y` is bounded above by the product of the predecessors of their\nupper bounds. In other words, `x * y <= (xbound - 1) * (ybound - 1)`.",
      "signature": "pub fn lemma_mul_strict_upper_bound(x: int, xbound: int, y: int, ybound: int)",
      "requires_clauses": [
        "x < xbound",
        "y < ybound",
        "0 < x",
        "0 < y"
      ],
      "ensures_clauses": [
        "# [trigger] (x * y) <= # [trigger] ((xbound - 1) * (ybound - 1))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_strict_upper_bound().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_left_inequality",
      "file_path": "arithmetic/mul.rs",
      "line_number": 221,
      "documentation": "Proof that multiplying the positive integer `x` by respectively\n`y` and `z` maintains the order of `y` and `z`. Specifically, `y\n<= z ==> x * y <= x * z` and `y < z ==> x * y < x * z`.",
      "signature": "pub fn lemma_mul_left_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 < x"
      ],
      "ensures_clauses": [
        "y <= z ==> # [trigger] (x * y) <= # [trigger] (x * z)",
        "y < z ==> x * y < x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_left_inequality().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_equality_converse",
      "file_path": "arithmetic/mul.rs",
      "line_number": 234,
      "documentation": "Proof that if `x` and `y` have equal results when multiplied by\nnonzero `m`, then they're equal.",
      "signature": "pub fn lemma_mul_equality_converse(m: int, x: int, y: int)",
      "requires_clauses": [
        "m != 0",
        "# [trigger] (m * x) == # [trigger] (m * y)"
      ],
      "ensures_clauses": [
        "x == y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_equality_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_inequality_converse",
      "file_path": "arithmetic/mul.rs",
      "line_number": 248,
      "documentation": "Proof that since `x * z <= y * z` and `z > 0`, that `x <= y`.",
      "signature": "pub fn lemma_mul_inequality_converse(x: int, y: int, z: int)",
      "requires_clauses": [
        "# [trigger] (x * z) <= # [trigger] (y * z)",
        "z > 0"
      ],
      "ensures_clauses": [
        "x <= y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_inequality_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strict_inequality_converse",
      "file_path": "arithmetic/mul.rs",
      "line_number": 259,
      "documentation": "Proof that since `x * z < y * z` and `z >= 0`, we know `x < y`.",
      "signature": "pub fn lemma_mul_strict_inequality_converse(x: int, y: int, z: int)",
      "requires_clauses": [
        "# [trigger] (x * z) < # [trigger] (y * z)",
        "z >= 0"
      ],
      "ensures_clauses": [
        "x < y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_strict_inequality_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_distributive_add",
      "file_path": "arithmetic/mul.rs",
      "line_number": 271,
      "documentation": "Proof that multiplication distributes over addition, specifically that\n`x * (y + z) == x * y + x * z`.",
      "signature": "pub fn lemma_mul_is_distributive_add(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * (y + z)) == x * y + x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_distributive_add().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_distributive_add",
      "file_path": "arithmetic/mul.rs",
      "line_number": 269,
      "documentation": "Proof that multiplication distributes over addition in this\nspecific case, i.e., that `x * (y + z)` equals `x * y` plus `x * z`",
      "signature": "pub fn lemma_mul_is_distributive_add(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * (y + z)) == x * y + x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals_nonlinear/internals/arithmetic/lemma_mul_is_distributive_add().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_distributive_add_other_way",
      "file_path": "arithmetic/mul.rs",
      "line_number": 280,
      "documentation": "Proof that multiplication distributes over addition, specifically that\n`(y + z) * x == y * x + z * x`.",
      "signature": "pub fn lemma_mul_is_distributive_add_other_way(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] ((y + z) * x) == y * x + z * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_distributive_add_other_way().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_distributive_sub",
      "file_path": "arithmetic/mul.rs",
      "line_number": 290,
      "documentation": "Proof that multiplication distributes over subtraction, specifically that\n`x * (y - z) == x * y - x * z`.",
      "signature": "pub fn lemma_mul_is_distributive_sub(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * (y - z)) == x * y - x * z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_distributive_sub().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_distributive_sub_other_way",
      "file_path": "arithmetic/mul.rs",
      "line_number": 301,
      "documentation": "Proof that multiplication distributes over subtraction when the\nsubtraction happens in the multiplicand (i.e., in the left-hand\nargument to `*`). Specifically, `(y - z) * x == y * x - z * x`.",
      "signature": "pub fn lemma_mul_is_distributive_sub_other_way(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] ((y - z) * x) == y * x - z * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_distributive_sub_other_way().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_is_distributive",
      "file_path": "arithmetic/mul.rs",
      "line_number": 327,
      "documentation": "Proof that multiplication is commutative, distributes over\naddition, and distributes over subtraction, in the specific cases\nwhere one of the arguments to the multiplication is `x` and the\nother arguments are `y` and `z`.",
      "signature": "fn lemma_mul_is_distributive(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x * (y + z) == x * y + x * z",
        "x * (y - z) == x * y - x * z",
        "(y + z) * x == y * x + z * x",
        "(y - z) * x == y * x - z * x",
        "x * (y + z) == (y + z) * x",
        "x * (y - z) == (y - z) * x",
        "x * y == y * x",
        "x * z == z * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_is_distributive().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strictly_positive",
      "file_path": "arithmetic/mul.rs",
      "line_number": 358,
      "documentation": "Proof that multiplication distributes over addition and\nsubtraction, whether the addition or subtraction happens in the\nfirst or the second argument to the multiplication.\nProof that if `x` and `y` are both positive, then their product is\nalso positive.",
      "signature": "pub fn lemma_mul_strictly_positive(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(0 < x && 0 < y) ==> (0 < # [trigger] (x * y))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_strictly_positive().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strictly_positive",
      "file_path": "arithmetic/mul.rs",
      "line_number": 342,
      "documentation": "Proof that multiplying two positive integers `x` and `y` will result in a positive integer",
      "signature": "pub fn lemma_mul_strictly_positive(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(0 < x && 0 < y) ==> (0 < # [trigger] (x * y))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals_nonlinear/internals/arithmetic/lemma_mul_strictly_positive().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_strictly_increases",
      "file_path": "arithmetic/mul.rs",
      "line_number": 366,
      "documentation": "Proof that since `x > 1` and `y > 0`, `y < x * y`.",
      "signature": "pub fn lemma_mul_strictly_increases(x: int, y: int)",
      "requires_clauses": [
        "1 < x",
        "0 < y"
      ],
      "ensures_clauses": [
        "y < # [trigger] (x * y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_strictly_increases().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_increases",
      "file_path": "arithmetic/mul.rs",
      "line_number": 378,
      "documentation": "Proof that since `x` and `y` are both positive, their product is\ngreater than or equal to `y`.",
      "signature": "pub fn lemma_mul_increases(x: int, y: int)",
      "requires_clauses": [
        "0 < x",
        "0 < y"
      ],
      "ensures_clauses": [
        "y <= # [trigger] (x * y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_increases().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_nonnegative",
      "file_path": "arithmetic/mul.rs",
      "line_number": 390,
      "documentation": "Proof that since `x` and `y` are non-negative, their product is\nnon-negative.",
      "signature": "pub fn lemma_mul_nonnegative(x: int, y: int)",
      "requires_clauses": [
        "0 <= x",
        "0 <= y"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x * y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_nonnegative().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_unary_negation",
      "file_path": "arithmetic/mul.rs",
      "line_number": 402,
      "documentation": "Proof that negating `x` or `y` before multiplying them together\nproduces the negation of the product of `x` and `y`.",
      "signature": "pub fn lemma_mul_unary_negation(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(- x) * y == - (x * y) == x * (- y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_unary_negation().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_cancels_negatives",
      "file_path": "arithmetic/mul.rs",
      "line_number": 413,
      "documentation": "Proof that multiplying `-x` and `-y` produces the same product as\nmultiplying `x` and `y`.",
      "signature": "pub fn lemma_mul_cancels_negatives(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) == (- x) * (- y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_cancels_negatives().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_properties_prove_mul_properties_auto",
      "file_path": "arithmetic/mul.rs",
      "line_number": 434,
      "documentation": "",
      "signature": "fn lemma_mul_properties_prove_mul_properties_auto()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : int , y : int | # [trigger] (x * y) == y * x",
        "forall | x : int | # ! [trigger x * 1] # ! [trigger 1 * x] x * 1 == 1 * x == x",
        "forall | x : int , y : int , z : int | x < y && z > 0 ==> # [trigger] (x * z) < # [trigger] (y * z)",
        "forall | x : int , y : int , z : int | x <= y && z >= 0 ==> # [trigger] (x * z) <= # [trigger] (y * z)",
        "forall | x : int , y : int , z : int | # [trigger] (x * (y + z)) == x * y + x * z",
        "forall | x : int , y : int , z : int | # [trigger] (x * (y - z)) == x * y - x * z",
        "forall | x : int , y : int , z : int | # [trigger] ((y + z) * x) == y * x + z * x",
        "forall | x : int , y : int , z : int | # [trigger] ((y - z) * x) == y * x - z * x",
        "forall | x : int , y : int , z : int | # ! [trigger x * (y * z)] # ! [trigger (x * y) * z] x * (y * z) == (x * y) * z",
        "forall | x : int , y : int | # [trigger] (x * y) != 0 <==> x != 0 && y != 0",
        "forall | x : int , y : int | 0 <= x && 0 <= y ==> 0 <= # [trigger] (x * y)",
        "forall | x : int , y : int | 0 < x && 0 < y && 0 <= x * y ==> x <= # [trigger] (x * y) && y <= (x * y)",
        "forall | x : int , y : int | (1 < x && 0 < y) ==> (y < # [trigger] (x * y))",
        "forall | x : int , y : int | (0 < x && 0 < y) ==> (y <= # [trigger] (x * y))",
        "forall | x : int , y : int | (0 < x && 0 < y) ==> (0 < # [trigger] (x * y))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul/arithmetic/lemma_mul_properties_prove_mul_properties_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_positive",
      "file_path": "arithmetic/power2.rs",
      "line_number": null,
      "documentation": "Proof that taking the given positive integer `b` to the power of\nthe given natural number `n` produces a positive result.",
      "signature": "pub fn lemma_pow_positive(b: int, e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_positive().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_adds",
      "file_path": "arithmetic/power2.rs",
      "line_number": null,
      "documentation": "Proof that taking an integer `b` to the power of the sum of two\nnatural numbers `e1` and `e2` is equivalent to multiplying `b` to\nthe power of `e1` by `b` to the power of `e2`.",
      "signature": "pub fn lemma_pow_adds(b: int, e1: nat, e2: nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_adds().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_strictly_increases",
      "file_path": "arithmetic/power2.rs",
      "line_number": null,
      "documentation": "Proof that a number greater than 1 raised to a power strictly\nincreases as the power strictly increases. Specifically, given\nthat `b > 1` and `e1 < e2`, we can conclude that `pow(b, e1) <\npow(b, e2)`.",
      "signature": "pub fn lemma_pow_strictly_increases(b: nat, e1: nat, e2: nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_strictly_increases().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_subtracts",
      "file_path": "arithmetic/power2.rs",
      "line_number": null,
      "documentation": "Proof that, as long as `e1 <= e2`, taking a positive integer `b`\nto the power of `e2 - e1` is equivalent to dividing `b` to the\npower of `e2` by `b` to the power of `e1`.",
      "signature": "pub fn lemma_pow_subtracts(b: int, e1: nat, e2: nat)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_subtracts().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow2_pos",
      "file_path": "arithmetic/power2.rs",
      "line_number": 47,
      "documentation": "Proof that 2 to the power of any natural number (specifically,\n`e`) is positive.",
      "signature": "pub fn lemma_pow2_pos(e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow2 (e) > 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power2/arithmetic/lemma_pow2_pos().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow2",
      "file_path": "arithmetic/power2.rs",
      "line_number": 56,
      "documentation": "Proof that `pow2(e)` is equivalent to `pow(2, e)`.",
      "signature": "pub fn lemma_pow2(e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow2 (e) == pow (2 , e) as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power2/arithmetic/lemma_pow2().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow2_unfold",
      "file_path": "arithmetic/power2.rs",
      "line_number": 69,
      "documentation": "Proof relating 2^e to 2^(e-1).",
      "signature": "pub fn lemma_pow2_unfold(e: nat)",
      "requires_clauses": [
        "e > 0"
      ],
      "ensures_clauses": [
        "# [trigger] pow2 (e) == 2 * pow2 ((e - 1) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power2/arithmetic/lemma_pow2_unfold().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow2_adds",
      "file_path": "arithmetic/power2.rs",
      "line_number": 81,
      "documentation": "Proof that `2^(e1 + e2)` is equivalent to `2^e1 * 2^e2`.",
      "signature": "pub fn lemma_pow2_adds(e1: nat, e2: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow2 (e1 + e2) == pow2 (e1) * pow2 (e2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power2/arithmetic/lemma_pow2_adds().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow2_subtracts",
      "file_path": "arithmetic/power2.rs",
      "line_number": 92,
      "documentation": "Proof that, as long as `e1 <= e2`, `2^(e2 - e1)` is equivalent to `2^e2 / 2^e1`.",
      "signature": "pub fn lemma_pow2_subtracts(e1: nat, e2: nat)",
      "requires_clauses": [
        "e1 <= e2"
      ],
      "ensures_clauses": [
        "# [trigger] pow2 ((e2 - e1) as nat) == pow2 (e2) / pow2 (e1) > 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power2/arithmetic/lemma_pow2_subtracts().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow2_strictly_increases",
      "file_path": "arithmetic/power2.rs",
      "line_number": 105,
      "documentation": "Proof that if `e1 < e2` then `2^e1 < 2^e2`.",
      "signature": "pub fn lemma_pow2_strictly_increases(e1: nat, e2: nat)",
      "requires_clauses": [
        "e1 < e2"
      ],
      "ensures_clauses": [
        "# [trigger] pow2 (e1) < # [trigger] pow2 (e2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power2/arithmetic/lemma_pow2_strictly_increases().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow0",
      "file_path": "arithmetic/power.rs",
      "line_number": 54,
      "documentation": "Proof that the given integer `b` to the power of 0 is 1.",
      "signature": "pub fn lemma_pow0(b: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (b , 0) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow0().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow1",
      "file_path": "arithmetic/power.rs",
      "line_number": 62,
      "documentation": "Proof that the given integer `b` to the power of 1 is `b`.",
      "signature": "pub fn lemma_pow1(b: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (b , 1) == b"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow1().",
      "source": "vstd"
    },
    {
      "name": "lemma_square_is_pow2",
      "file_path": "arithmetic/power.rs",
      "line_number": 113,
      "documentation": "Proof that taking the given number `x` to the power of 2 produces `x * x`.",
      "signature": "pub fn lemma_square_is_pow2(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (x , 2) == x * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_square_is_pow2().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_sub_add_cancel",
      "file_path": "arithmetic/power.rs",
      "line_number": 179,
      "documentation": "Proof that if `e1 >= e2`, then `b` to the power of `e1` is equal\nto the product of `b` to the power of `e1 - e2` and `b` to the\npower of `e2`.",
      "signature": "pub fn lemma_pow_sub_add_cancel(b: int, e1: nat, e2: nat)",
      "requires_clauses": [
        "e1 >= e2"
      ],
      "ensures_clauses": [
        "# [trigger] pow (b , (e1 - e2) as nat) * pow (b , e2) == pow (b , e1)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_sub_add_cancel().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_multiplies",
      "file_path": "arithmetic/power.rs",
      "line_number": 217,
      "documentation": "Proof that `a` to the power of `b * c` is equal to the result of\ntaking `a` to the power of `b`, then taking that to the power of\n`c`.",
      "signature": "pub fn lemma_pow_multiplies(a: int, b: nat, c: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= b * c",
        "# [trigger] pow (pow (a , b) , c) == pow (a , b * c)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_multiplies().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_distributes",
      "file_path": "arithmetic/power.rs",
      "line_number": 272,
      "documentation": "Proof that `a * b` to the power of `e` is equal to the product of\n`a` to the power of `e` and `b` to the power of `e`.",
      "signature": "pub fn lemma_pow_distributes(a: int, b: int, e: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] pow (a * b , e) == pow (a , e) * pow (b , e)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_distributes().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_properties_prove_pow_auto",
      "file_path": "arithmetic/power.rs",
      "line_number": 317,
      "documentation": "Proof of various useful properties of [`pow`] (exponentiation)",
      "signature": "fn lemma_pow_properties_prove_pow_auto()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : int | pow (x , 0) == 1",
        "forall | x : int | # [trigger] pow (x , 1) == x",
        "forall | x : int , y : int | y == 0 ==> # [trigger] pow (x , y as nat) == 1",
        "forall | x : int , y : int | y == 1 ==> # [trigger] pow (x , y as nat) == x",
        "forall | x : int , y : int | 0 < x && 0 < y ==> x <= # [trigger] (x * y as nat)",
        "forall | x : int , y : int | 0 < x && 1 < y ==> x < # [trigger] (x * y as nat)",
        "forall | x : int , y : nat , z : nat | # [trigger] pow (x , y + z) == pow (x , y) * pow (x , z)",
        "forall | x : int , y : nat , z : nat | y >= z ==> # [trigger] pow (x , (y - z) as nat) * pow (x , z) == pow (x , y)",
        "forall | x : int , y : nat , z : nat | # [trigger] pow (x * y , z) == pow (x , z) * pow (y as int , z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_properties_prove_pow_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_increases",
      "file_path": "arithmetic/power.rs",
      "line_number": 384,
      "documentation": "Proof that a positive number raised to a power increases as the\npower increases. Specifically, since `e1 <= e2`, we know `pow(b,\ne1) <= pow(b, e2)`.",
      "signature": "pub fn lemma_pow_increases(b: nat, e1: nat, e2: nat)",
      "requires_clauses": [
        "b > 0",
        "e1 <= e2"
      ],
      "ensures_clauses": [
        "# [trigger] pow (b as int , e1) <= # [trigger] pow (b as int , e2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_increases().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_strictly_increases_converse",
      "file_path": "arithmetic/power.rs",
      "line_number": 404,
      "documentation": "Proof that if an exponentiation result strictly increases when the\nexponent changes, then the change is an increase. Specifically, if\nwe know `pow(b, e1) < pow(b, e2)`, then we can conclude `e1 < e2`.",
      "signature": "pub fn lemma_pow_strictly_increases_converse(b: nat, e1: nat, e2: nat)",
      "requires_clauses": [
        "b > 0",
        "# [trigger] pow (b as int , e1) < # [trigger] pow (b as int , e2)"
      ],
      "ensures_clauses": [
        "e1 < e2"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_strictly_increases_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_increases_converse",
      "file_path": "arithmetic/power.rs",
      "line_number": 421,
      "documentation": "Proof that if the exponentiation of a number greater than 1\ndoesn't decrease when the exponent changes, then the change isn't\na decrease. Specifically, given that `b > 1` and `pow(b, e1) <=\npow(b, e2)`, we can conclude that `e1 <= e2`.",
      "signature": "pub fn lemma_pow_increases_converse(b: nat, e1: nat, e2: nat)",
      "requires_clauses": [
        "1 < b",
        "# [trigger] pow (b as int , e1) <= # [trigger] pow (b as int , e2)"
      ],
      "ensures_clauses": [
        "e1 <= e2"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_increases_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_pull_out_pows",
      "file_path": "arithmetic/power.rs",
      "line_number": 436,
      "documentation": "Proof that `(b^(xy))^z = (b^x)^(yz)`, given that `x * y` and `y *\nz` are nonnegative and `b` is positive.",
      "signature": "pub fn lemma_pull_out_pows(b: nat, x: nat, y: nat, z: nat)",
      "requires_clauses": [
        "b > 0"
      ],
      "ensures_clauses": [
        "0 <= x * y",
        "0 <= y * z",
        "# [trigger] pow (pow (b as int , x * y) , z) == pow (pow (b as int , x) , y * z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pull_out_pows().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_division_inequality",
      "file_path": "arithmetic/power.rs",
      "line_number": 461,
      "documentation": "Proof that if `e2 <= e1` and `x < pow(b, e1)`, then dividing `x`\nby `pow(b, e2)` produces a result less than `pow(b, e1 - e2)`.",
      "signature": "pub fn lemma_pow_division_inequality(x: nat, b: nat, e1: nat, e2: nat)",
      "requires_clauses": [
        "b > 0",
        "e2 <= e1",
        "x < pow (b as int , e1)"
      ],
      "ensures_clauses": [
        "pow (b as int , e2) > 0",
        "# [trigger] (x as int / pow (b as int , e2)) < # [trigger] pow (b as int , (e1 - e2) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_division_inequality().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod",
      "file_path": "arithmetic/power.rs",
      "line_number": null,
      "documentation": "Proof of the fundamental theorem of division and modulo, namely\nthat `x` can be expressed as `d` times the quotient `x / d` plus\nthe remainder `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod(x: int, d: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_fundamental_div_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_mod",
      "file_path": "arithmetic/power.rs",
      "line_number": 490,
      "documentation": "Proof that `pow(b, e)` modulo `b` is 0.",
      "signature": "pub fn lemma_pow_mod(b: nat, e: nat)",
      "requires_clauses": [
        "b > 0",
        "e > 0"
      ],
      "ensures_clauses": [
        "# [trigger] pow (b as int , e) % b as int == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_multiples_basic",
      "file_path": "arithmetic/power.rs",
      "line_number": null,
      "documentation": "Proof that multiplying by a number then dividing by that same\nnumber produces a remainder of 0. Specifically, `(x * m) % m == 0`.",
      "signature": "pub fn lemma_mod_multiples_basic(x: int, m: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_multiples_basic().",
      "source": "vstd"
    },
    {
      "name": "lemma_pow_mod_noop",
      "file_path": "arithmetic/power.rs",
      "line_number": 528,
      "documentation": "Proof that exponentiation then modulo produces the same result as\ndoing the modulo first, then doing the exponentiation, then doing\nthe modulo again. Specifically, `((b % m)^e) % m == b^e % m`.",
      "signature": "pub fn lemma_pow_mod_noop(b: int, e: nat, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] pow (b % m , e) % m == pow (b , e) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 power/arithmetic/lemma_pow_mod_noop().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_pos_is_pos",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": null,
      "documentation": "Proof that dividing a whole number by a natural number will result\nin a quotient that is greater than or equal to 0. Specifically,\n`x / d >= 0`.",
      "signature": "pub fn lemma_div_pos_is_pos(x: int, d: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_pos_is_pos().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_decreases",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": null,
      "documentation": "Proof that dividing an integer by 2 or more results in a quotient\nthat is smaller than the original dividend. Specifically, `x / d < x`.",
      "signature": "pub fn lemma_div_decreases(x: int, d: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_decreases().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_is_ordered",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": null,
      "documentation": "Proof that numerical order is preserved when dividing two seperate\nintegers by a common positive divisor. Specifically, given that\n`z > 0` and `x <= y`, we know `x / z <= y / z`.",
      "signature": "pub fn lemma_div_is_ordered(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_is_ordered().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_multiples_vanish",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": null,
      "documentation": "Proof that multiplying an integer by a common numerator and\ndenominator results in the original integer. Specifically,\n`(d * x) / d == x`.",
      "signature": "pub fn lemma_div_multiples_vanish(x: int, d: int)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_multiples_vanish().",
      "source": "vstd"
    },
    {
      "name": "lemma_log0",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": 56,
      "documentation": "Proof that since `pow` is less than `base`, its logarithm in that base is 0.",
      "signature": "pub fn lemma_log0(base: int, pow: int)",
      "requires_clauses": [
        "base > 1",
        "0 <= pow < base"
      ],
      "ensures_clauses": [
        "log (base , pow) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 logarithm/arithmetic/lemma_log0().",
      "source": "vstd"
    },
    {
      "name": "lemma_log_s",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": 69,
      "documentation": "Proof that since `pow` is greater than or equal to `base`, its\nlogarithm in that base is 1 more than the logarithm of `pow /\nbase`.",
      "signature": "pub fn lemma_log_s(base: int, pow: int)",
      "requires_clauses": [
        "base > 1",
        "pow >= base"
      ],
      "ensures_clauses": [
        "pow / base >= 0",
        "log (base , pow) == 1 + log (base , pow / base)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 logarithm/arithmetic/lemma_log_s().",
      "source": "vstd"
    },
    {
      "name": "lemma_log_nonnegative",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": 85,
      "documentation": "Proof that the integer logarithm is always nonnegative. Specifically,\n`log(base, pow) >= 0`.",
      "signature": "pub fn lemma_log_nonnegative(base: int, pow: int)",
      "requires_clauses": [
        "base > 1",
        "0 <= pow"
      ],
      "ensures_clauses": [
        "log (base , pow) >= 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 logarithm/arithmetic/lemma_log_nonnegative().",
      "source": "vstd"
    },
    {
      "name": "lemma_log_is_ordered",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": 102,
      "documentation": "Proof that since `pow1` is less than or equal to `pow2`, the\ninteger logarithm of `pow1` in base `base` is less than or equal\nto that of `pow2`.",
      "signature": "pub fn lemma_log_is_ordered(base: int, pow1: int, pow2: int)",
      "requires_clauses": [
        "base > 1",
        "0 <= pow1 <= pow2"
      ],
      "ensures_clauses": [
        "log (base , pow1) <= log (base , pow2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 logarithm/arithmetic/lemma_log_is_ordered().",
      "source": "vstd"
    },
    {
      "name": "lemma_log_pow",
      "file_path": "arithmetic/logarithm.rs",
      "line_number": 124,
      "documentation": "Proof that the integer logarithm of `pow(base, n)` in base `base` is `n`.",
      "signature": "pub fn lemma_log_pow(base: int, n: nat)",
      "requires_clauses": [
        "base > 1"
      ],
      "ensures_clauses": [
        "log (base , pow (base , n)) == n"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 logarithm/arithmetic/lemma_log_pow().",
      "source": "vstd"
    },
    {
      "name": "lemma_induction_helper_pos",
      "file_path": "arithmetic/internals/general_internals.rs",
      "line_number": 32,
      "documentation": "This proof, local to this module, aids in the process of proving\n[`lemma_induction_helper`] by covering only the case of nonnegative\nvalues of `x`.",
      "signature": "fn lemma_induction_helper_pos(n: int, f: spec_fn(int) -> bool, x: int)",
      "requires_clauses": [
        "x >= 0",
        "n > 0",
        "forall | i : int | 0 <= i < n ==> # [trigger] f (i)",
        "forall | i : int | i >= 0 && # [trigger] f (i) ==> # [trigger] f (add1 (i , n))",
        "forall | i : int | i < n && # [trigger] f (i) ==> # [trigger] f (sub1 (i , n))"
      ],
      "ensures_clauses": [
        "f (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 general_internals/internals/arithmetic/lemma_induction_helper_pos().",
      "source": "vstd"
    },
    {
      "name": "lemma_induction_helper_neg",
      "file_path": "arithmetic/internals/general_internals.rs",
      "line_number": 54,
      "documentation": "This proof, local to this module, aids in the process of proving\n[`lemma_induction_helper`] by covering only the case of negative\nvalues of `x`.",
      "signature": "fn lemma_induction_helper_neg(n: int, f: spec_fn(int) -> bool, x: int)",
      "requires_clauses": [
        "x < 0",
        "n > 0",
        "forall | i : int | 0 <= i < n ==> # [trigger] f (i)",
        "forall | i : int | i >= 0 && # [trigger] f (i) ==> # [trigger] f (add1 (i , n))",
        "forall | i : int | i < n && # [trigger] f (i) ==> # [trigger] f (sub1 (i , n))"
      ],
      "ensures_clauses": [
        "f (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 general_internals/internals/arithmetic/lemma_induction_helper_neg().",
      "source": "vstd"
    },
    {
      "name": "lemma_induction_helper",
      "file_path": "arithmetic/internals/general_internals.rs",
      "line_number": 100,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nthe given arbitrary input `x`.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `0 <= i < n`.\n\n`x`: The desired case established by this lemma. Its postcondition\nis thus simply `f(x)`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i >= 0`, `f(i) ==> f(add1(i, n))`.\n`add1(i, n)` is just `i + n`, but written in a functional style\nso that it can be used where functional triggers are required.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i < n`, `f(i) ==> f(sub1(i, n))`.\n`sub1(i, n)` is just `i - n`, but written in a functional style\nso that it can be used where functional triggers are required.",
      "signature": "pub fn lemma_induction_helper(n: int, f: spec_fn(int) -> bool, x: int)",
      "requires_clauses": [
        "n > 0",
        "forall | i : int | 0 <= i < n ==> # [trigger] f (i)",
        "forall | i : int | i >= 0 && # [trigger] f (i) ==> # [trigger] f (add1 (i , n))",
        "forall | i : int | i < n && # [trigger] f (i) ==> # [trigger] f (sub1 (i , n))"
      ],
      "ensures_clauses": [
        "f (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 general_internals/internals/arithmetic/lemma_induction_helper().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_of_zero_is_zero",
      "file_path": "arithmetic/internals/mod_internals_nonlinear.rs",
      "line_number": 29,
      "documentation": "Proof that 0 modulo any positive integer `m` is 0",
      "signature": "fn lemma_mod_of_zero_is_zero(m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "0 as int % m == 0 as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals_nonlinear/internals/arithmetic/lemma_mod_of_zero_is_zero().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod",
      "file_path": "arithmetic/internals/mod_internals_nonlinear.rs",
      "line_number": 41,
      "documentation": "Proof of the fundamental theorem of division and modulo: That for\nany positive divisor `d` and any integer `x`, `x` is equal to `d`\ntimes `x / d` plus `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod(x: int, d: int)",
      "requires_clauses": [
        "d != 0"
      ],
      "ensures_clauses": [
        "x == d * (x / d) + (x % d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals_nonlinear/internals/arithmetic/lemma_fundamental_div_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_0_mod_anything",
      "file_path": "arithmetic/internals/mod_internals_nonlinear.rs",
      "line_number": 50,
      "documentation": "Proof that 0 modulo any integer is 0",
      "signature": "fn lemma_0_mod_anything()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | m : int | m > 0 ==> # [trigger] modulus (0 , m) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals_nonlinear/internals/arithmetic/lemma_0_mod_anything().",
      "source": "vstd"
    },
    {
      "name": "lemma_small_mod",
      "file_path": "arithmetic/internals/mod_internals_nonlinear.rs",
      "line_number": 59,
      "documentation": "Proof that a natural number `x` divided by a larger natural number\n`m` gives a remainder equal to `x`",
      "signature": "pub fn lemma_small_mod(x: nat, m: nat)",
      "requires_clauses": [
        "x < m",
        "0 < m"
      ],
      "ensures_clauses": [
        "# [trigger] modulus (x as int , m as int) == x as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals_nonlinear/internals/arithmetic/lemma_small_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_range",
      "file_path": "arithmetic/internals/mod_internals_nonlinear.rs",
      "line_number": 71,
      "documentation": "Proof of Euclid's division lemma, i.e., that any integer `x`\nmodulo any positive integer `m` is in the half-open range `[0, m)`.",
      "signature": "pub fn lemma_mod_range(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] modulus (x , m) < m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals_nonlinear/internals/arithmetic/lemma_mod_range().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_induction",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 67,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in the base case of 0, and proves correctness of\ninductive steps both upward and downward from the base case. This\nlemma invokes induction to establish that the predicate holds for\nall integers.\n\nTo prove inductive steps upward from the base case, the caller\nmust establish that, for any `i >= 0`, `f(i) ==> f(add1(i, 1))`.\n`add1(i, 1)` is just `i + 1`, but written in a functional style\nso that it can be used where functional triggers are required.\n\nTo prove inductive steps downward from the base case, the caller\nmust establish that, for any `i <= 0`, `f(i) ==> f(sub1(i, 1))`.\n`sub1(i, 1)` is just `i - 1`, but written in a functional style\nso that it can be used where functional triggers are required.",
      "signature": "pub fn lemma_mul_induction(f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "f (0)",
        "forall | i : int | i >= 0 && # [trigger] f (i) ==> # [trigger] f (add1 (i , 1))",
        "forall | i : int | i <= 0 && # [trigger] f (i) ==> # [trigger] f (sub1 (i , 1))"
      ],
      "ensures_clauses": [
        "forall | i : int | # [trigger] f (i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_induction().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_commutes",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 79,
      "documentation": "Proof that multiplication is always commutative",
      "signature": "pub fn lemma_mul_commutes(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x * y) == y * x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_commutes().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_successor",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 87,
      "documentation": "Proof that multiplication distributes over addition by 1 and\nover subtraction by 1",
      "signature": "fn lemma_mul_successor()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : int , y : int | # [trigger] ((x + 1) * y) == x * y + y",
        "forall | x : int , y : int | # [trigger] ((x - 1) * y) == x * y - y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_successor().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_distributes_plus",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 107,
      "documentation": "Proof that multiplication distributes over addition and over\nsubtraction",
      "signature": "pub fn lemma_mul_distributes_plus(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] ((x + y) * z) == (x * z + y * z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_distributes_plus().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_distributes_minus",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 127,
      "documentation": "",
      "signature": "pub fn lemma_mul_distributes_minus(x: int, y: int, z: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] ((x - y) * z) == (x * z - y * z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_distributes_minus().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_properties_internal_prove_mul_auto",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 161,
      "documentation": "",
      "signature": "fn lemma_mul_properties_internal_prove_mul_auto()",
      "requires_clauses": [],
      "ensures_clauses": [
        "mul_auto ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_properties_internal_prove_mul_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_induction_auto_forall",
      "file_path": "arithmetic/internals/mul_internals.rs",
      "line_number": 216,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate `f`, proves\nthe predicate holds in the base case of 0, and proves correctness\nof inductive steps both upward and downward from the base case.\nThis lemma invokes induction to establish that the predicate holds\nfor all integers.\n\nTo prove inductive steps upward from the base case, the caller\nmust establish that, for any `i`, `is_le(0, i)` implies `f(i) ==>\nf(i + 1)`.\n\nTo prove inductive steps downward from the base case, the caller\nmust establish that, for any `i`, `is_le(i, 0)` implies `f(i) ==>\nf(i - 1)`.",
      "signature": "pub fn lemma_mul_induction_auto_forall(f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "mul_auto () ==> { &&& f (0) &&& (forall | i | # [trigger] is_le (0 , i) && f (i) ==> f (i + 1)) &&& (forall | i | # [trigger] is_le (i , 0) && f (i) ==> f (i - 1)) }"
      ],
      "ensures_clauses": [
        "mul_auto ()",
        "forall | i | # [trigger] f (i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mul_internals/internals/arithmetic/lemma_mul_induction_auto_forall().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_induction_forall",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 79,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nall possible inputs.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `0 <= i < n`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i >= 0`, `f(i) ==> f(add1(i, n))`.\n`add1(i, n)` is just `i + n`, but written in a functional style\nso that it can be used where functional triggers are required.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i < n`, `f(i) ==> f(sub1(i, n))`.\n`sub1(i, n)` is just `i - n`, but written in a functional style\nso that it can be used where functional triggers are required.",
      "signature": "pub fn lemma_mod_induction_forall(n: int, f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "n > 0",
        "forall | i : int | 0 <= i < n ==> # [trigger] f (i)",
        "forall | i : int | i >= 0 && # [trigger] f (i) ==> # [trigger] f (add1 (i , n))",
        "forall | i : int | i < n && # [trigger] f (i) ==> # [trigger] f (sub1 (i , n))"
      ],
      "ensures_clauses": [
        "forall | i | # [trigger] f (i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_induction_forall().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_induction_forall2",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 120,
      "documentation": "This utility function helps prove a mathematical property of a\npair of integers by induction. The caller supplies a predicate\nover a pair of integers, proves the predicate holds in certain\nbase cases, and proves correctness of inductive steps both upward\nand downward from the base cases. This lemma invokes induction to\nestablish that the predicate holds for all possible inputs.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i, j)` for every pair of values `i, j` satisfying\n`0 <= i < n` and `0 <= j < n`.\n\nTo prove inductive steps from the base cases, the caller must\nestablish that:\n\n1) For any `i >= 0`, `f(i, j) ==> f(add1(i, n), j)`. `add1(i, n)`\nis just `i + n`, but written in a functional style so that it can\nbe used where functional triggers are required.\n\n2) For any `j >= 0`, `f(i, j) ==> f(i, add1(j, n))`\n\n3) For any `i < n`, `f(i) ==> f(sub1(i, n))`. `sub1(i, n)` is just\n`i - n`, but written in a functional style so that it can be used\nwhere functional triggers are required.\n\n4) For any `j < n`, `f(j) ==> f(i, sub1(j, n))`.",
      "signature": "pub fn lemma_mod_induction_forall2(n: int, f: spec_fn(int, int) -> bool)",
      "requires_clauses": [
        "n > 0",
        "forall | i : int , j : int | 0 <= i < n && 0 <= j < n ==> # [trigger] f (i , j)",
        "forall | i : int , j : int | i >= 0 && # [trigger] f (i , j) ==> # [trigger] f (add1 (i , n) , j)",
        "forall | i : int , j : int | j >= 0 && # [trigger] f (i , j) ==> # [trigger] f (i , add1 (j , n))",
        "forall | i : int , j : int | i < n && # [trigger] f (i , j) ==> # [trigger] f (sub1 (i , n) , j)",
        "forall | i : int , j : int | j < n && # [trigger] f (i , j) ==> # [trigger] f (i , sub1 (j , n))"
      ],
      "ensures_clauses": [
        "forall | i : int , j : int | # [trigger] f (i , j)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_induction_forall2().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_add_denominator",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 147,
      "documentation": "Proof that when dividing, adding the denominator to the numerator\nincreases the result by 1. Specifically, for the given `n` and `x`,\n`(x + n) / n == x / n + 1`.",
      "signature": "pub fn lemma_div_add_denominator(n: int, x: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "(x + n) / n == x / n + 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_div_add_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_sub_denominator",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 171,
      "documentation": "Proof that when dividing, subtracting the denominator from the numerator\ndecreases the result by 1. Specifically, for the given `n` and `x`,\n`(x - n) / n == x / n - 1`.",
      "signature": "pub fn lemma_div_sub_denominator(n: int, x: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "(x - n) / n == x / n - 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_div_sub_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_add_denominator",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 196,
      "documentation": "Proof that when dividing, adding the denominator to the numerator\ndoesn't change the remainder. Specifically, for the given `n` and\n`x`, `(x + n) % n == x % n`.",
      "signature": "pub fn lemma_mod_add_denominator(n: int, x: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "(x + n) % n == x % n"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_add_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_sub_denominator",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 228,
      "documentation": "Proof that when dividing, subtracting the denominator from the\nnumerator doesn't change the remainder. Specifically, for the\ngiven `n` and `x`, `(x - n) % n == x % n`.",
      "signature": "pub fn lemma_mod_sub_denominator(n: int, x: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "(x - n) % n == x % n"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_sub_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_below_denominator",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 253,
      "documentation": "Proof that for the given `n` and `x`, `x % n == x` if and only if\n`0 <= x < n`.",
      "signature": "pub fn lemma_mod_below_denominator(n: int, x: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "0 <= x < n <==> x % n == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_below_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_basics",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 277,
      "documentation": "Proof of basic properties of the division given the divisor `n`:\n\n1) Adding the denominator to the numerator increases the quotient\nby 1 and doesn't change the remainder.\n\n2) Subtracting the denominator from the numerator decreases the\nquotient by 1 and doesn't change the remainder.\n\n3) The numerator is the same as the result if and only if the\nnumerator is in the half-open range `[0, n)`.",
      "signature": "pub fn lemma_mod_basics(n: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "forall | x : int | # [trigger] ((x + n) % n) == x % n",
        "forall | x : int | # [trigger] ((x - n) % n) == x % n",
        "forall | x : int | # [trigger] ((x + n) / n) == x / n + 1",
        "forall | x : int | # [trigger] ((x - n) / n) == x / n - 1",
        "forall | x : int | 0 <= x < n <==> # [trigger] (x % n) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_basics().",
      "source": "vstd"
    },
    {
      "name": "lemma_quotient_and_remainder",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 308,
      "documentation": "Proof that if `x == q * r + n` and `0 <= r < n`, then `q == x / n`\nand `r == x % n`. Essentially, this is the converse of the\nfundamental theorem of division and modulo.",
      "signature": "pub fn lemma_quotient_and_remainder(x: int, q: int, r: int, n: int)",
      "requires_clauses": [
        "n > 0",
        "0 <= r < n",
        "x == q * n + r"
      ],
      "ensures_clauses": [
        "q == x / n",
        "r == x % n"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_quotient_and_remainder().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_auto",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 390,
      "documentation": "Proof of `mod_auto(n)`, which states various useful properties\nabout the modulo operator when the divisor is the positive number\n`n`",
      "signature": "pub fn lemma_mod_auto(n: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "mod_auto (n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_induction_auto",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 468,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nthe given arbitrary input `x`.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\n`x`: The desired case established by this lemma. Its postcondition\nthus includes `f(x)`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
      "signature": "pub fn lemma_mod_induction_auto(n: int, x: int, f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "n > 0",
        "mod_auto (n) ==> { &&& (forall | i : int | # [trigger] is_le (0 , i) && i < n ==> f (i)) &&& (forall | i : int | # [trigger] is_le (0 , i) && f (i) ==> f (i + n)) &&& (forall | i : int | # [trigger] is_le (i + 1 , n) && f (i) ==> f (i - n)) }"
      ],
      "ensures_clauses": [
        "mod_auto (n)",
        "f (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_induction_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_induction_auto_forall",
      "file_path": "arithmetic/internals/mod_internals.rs",
      "line_number": 515,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nall integer values.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
      "signature": "pub fn lemma_mod_induction_auto_forall(n: int, f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "n > 0",
        "mod_auto (n) ==> { &&& (forall | i : int | # [trigger] is_le (0 , i) && i < n ==> f (i)) &&& (forall | i : int | # [trigger] is_le (0 , i) && f (i) ==> f (i + n)) &&& (forall | i : int | # [trigger] is_le (i + 1 , n) && f (i) ==> f (i - n)) }"
      ],
      "ensures_clauses": [
        "mod_auto (n)",
        "forall | i | # [trigger] f (i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 mod_internals/internals/arithmetic/lemma_mod_induction_auto_forall().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics",
      "file_path": "arithmetic/internals/div_internals.rs",
      "line_number": 77,
      "documentation": "Proof of basic properties of integer division when the divisor is\nthe given positive integer `n`",
      "signature": "pub fn lemma_div_basics(n: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "(n / n) == 1 && - ((- n) / n) == 1",
        "forall | x : int | 0 <= x < n <==> # [trigger] (x / n) == 0",
        "forall | x : int | # [trigger] ((x + n) / n) == x / n + 1",
        "forall | x : int | # [trigger] ((x - n) / n) == x / n - 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals/internals/arithmetic/lemma_div_basics().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_auto_plus",
      "file_path": "arithmetic/internals/div_internals.rs",
      "line_number": 140,
      "documentation": "Proof of `div_auto_plus(n)`, not exported publicly because it's\njust used as part of [`lemma_div_auto`] to prove `div_auto(n)`",
      "signature": "fn lemma_div_auto_plus(n: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "div_auto_plus (n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals/internals/arithmetic/lemma_div_auto_plus().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_auto_minus",
      "file_path": "arithmetic/internals/div_internals.rs",
      "line_number": 189,
      "documentation": "Proof of `div_auto_mius(n)`, not exported publicly because it's\njust used as part of [`lemma_div_auto`] to prove `div_auto(n)`",
      "signature": "fn lemma_div_auto_minus(n: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "div_auto_minus (n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals/internals/arithmetic/lemma_div_auto_minus().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_auto",
      "file_path": "arithmetic/internals/div_internals.rs",
      "line_number": 234,
      "documentation": "Proof of `div_auto(n)`, which expresses many useful properties of\ndivision when the denominator is the given positive integer `n`.",
      "signature": "pub fn lemma_div_auto(n: int)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "div_auto (n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals/internals/arithmetic/lemma_div_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_induction_auto",
      "file_path": "arithmetic/internals/div_internals.rs",
      "line_number": 278,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nthe given arbitrary input `x`.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\n`x`: The desired case established by this lemma. Its postcondition\nthus includes `f(x)`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
      "signature": "pub fn lemma_div_induction_auto(n: int, x: int, f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "n > 0",
        "div_auto (n) ==> { &&& (forall | i : int | # [trigger] is_le (0 , i) && i < n ==> f (i)) &&& (forall | i : int | # [trigger] is_le (0 , i) && f (i) ==> f (i + n)) &&& (forall | i : int | # [trigger] is_le (i + 1 , n) && f (i) ==> f (i - n)) }"
      ],
      "ensures_clauses": [
        "div_auto (n)",
        "f (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals/internals/arithmetic/lemma_div_induction_auto().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_induction_auto_forall",
      "file_path": "arithmetic/internals/div_internals.rs",
      "line_number": 328,
      "documentation": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nall integer values.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
      "signature": "pub fn lemma_div_induction_auto_forall(n: int, f: spec_fn(int) -> bool)",
      "requires_clauses": [
        "n > 0",
        "div_auto (n) ==> { &&& (forall | i : int | # [trigger] is_le (0 , i) && i < n ==> f (i)) &&& (forall | i : int | # [trigger] is_le (0 , i) && f (i) ==> f (i + n)) &&& (forall | i : int | # [trigger] is_le (i + 1 , n) && f (i) ==> f (i - n)) }"
      ],
      "ensures_clauses": [
        "div_auto (n)",
        "forall | i | # [trigger] f (i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals/internals/arithmetic/lemma_div_induction_auto_forall().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_of0",
      "file_path": "arithmetic/internals/div_internals_nonlinear.rs",
      "line_number": 22,
      "documentation": "Proof that 0 divided by any given integer `d` is 0",
      "signature": "pub fn lemma_div_of0(d: int)",
      "requires_clauses": [
        "d != 0 as int"
      ],
      "ensures_clauses": [
        "0 as int / d == 0 as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals_nonlinear/internals/arithmetic/lemma_div_of0().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_by_self",
      "file_path": "arithmetic/internals/div_internals_nonlinear.rs",
      "line_number": 31,
      "documentation": "Proof that any given integer `d` divided by itself is 1",
      "signature": "pub fn lemma_div_by_self(d: int)",
      "requires_clauses": [
        "d != 0"
      ],
      "ensures_clauses": [
        "d / d == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals_nonlinear/internals/arithmetic/lemma_div_by_self().",
      "source": "vstd"
    },
    {
      "name": "lemma_small_div",
      "file_path": "arithmetic/internals/div_internals_nonlinear.rs",
      "line_number": 41,
      "documentation": "Proof that dividing a non-negative integer by a larger integer results in a quotient of 0",
      "signature": "pub fn lemma_small_div()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : int , d : int | 0 <= x < d && d > 0 ==> # [trigger] (x / d) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_internals_nonlinear/internals/arithmetic/lemma_small_div().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_is_div_recursive",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 55,
      "documentation": "Proof that, for the case of `x / d`, division using `/` is\nequivalent to a recursive definition of division.",
      "signature": "pub fn lemma_div_is_div_recursive(x: int, d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "div_recursive (x , d) == # [trigger] (x / d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_is_div_recursive().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_by_self",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 68,
      "documentation": "Proof that the quotient of an integer divided by itself is 1,\nspecifically that `d / d == 1`.",
      "signature": "pub fn lemma_div_by_self(d: int)",
      "requires_clauses": [
        "d != 0"
      ],
      "ensures_clauses": [
        "d / d == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_by_self().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_of0",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 78,
      "documentation": "Proof that 0 divided by a nonzero integer is 0, specifically `0 / d == 0`.",
      "signature": "pub fn lemma_div_of0(d: int)",
      "requires_clauses": [
        "d != 0"
      ],
      "ensures_clauses": [
        "0 as int / d == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_of0().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 90,
      "documentation": "Proof establishing basic properties of division using `x`: 0\ndivided by `x` is 0; `x` divided by 1 is itself; and `x` divided\nby itself is 1.",
      "signature": "pub fn lemma_div_basics(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x != 0 as int ==> 0 as int / x == 0",
        "x / 1 == x",
        "x != 0 ==> x / x == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_basics().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics_1",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 103,
      "documentation": "Proof for basic property that 0 divided by `x` is 0.",
      "signature": "pub fn lemma_div_basics_1(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x != 0 as int ==> # [trigger] (0int / x) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_basics_1().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics_2",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 111,
      "documentation": "Proof for basic property that `x` divided by 1 is `x`.",
      "signature": "pub fn lemma_div_basics_2(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x / 1) == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_basics_2().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics_3",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 119,
      "documentation": "Proof for basic property that `x` divided by `x` is 1.",
      "signature": "pub fn lemma_div_basics_3(x: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x != 0 ==> # [trigger] (x / x) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_basics_3().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics_4",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 127,
      "documentation": "Proof that dividing any non-negative integer by a positive integer is non-zero.",
      "signature": "pub fn lemma_div_basics_4(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x >= 0 && y > 0 ==> # [trigger] (x / y) >= 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_basics_4().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_basics_5",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 135,
      "documentation": "Proof that the quotient produced by dividing any non-negative integer `x`\nby a positive integer `y` is at most `x`.",
      "signature": "pub fn lemma_div_basics_5(x: int, y: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x >= 0 && y > 0 ==> # [trigger] (x / y) <= x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_basics_5().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_is_ordered_by_denominator",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 187,
      "documentation": "Proof that given two fractions with the same numerator, the order\nof the fractions is determined by the denominators. However, if\nthe numerator is 0, the fractions are equal regardless of the\ndenominators' values. Specifically, given that `1 <= y <= z`, we\nknow `x / y >= x / z`.",
      "signature": "pub fn lemma_div_is_ordered_by_denominator(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "1 <= y <= z"
      ],
      "ensures_clauses": [
        "# [trigger] (x / y) >= # [trigger] (x / z)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_is_ordered_by_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_small_div_converse",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 156,
      "documentation": "Proof that if a dividend is a whole number, the divisor is a\nnatural number, and their quotient is 0, then the dividend is\nsmaller than the divisor.",
      "signature": "pub fn lemma_small_div_converse(x: int, d: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= x && 0 < d && # [trigger] (x / d) == 0 ==> x < d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_small_div_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_non_zero",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 168,
      "documentation": "Proof that division of a positive integer by a positive integer\nless than or equal to it is nonzero. Specifically,\ngiven that `x >= d`, we can conclude that `x / d > 0`.",
      "signature": "pub fn lemma_div_non_zero(x: int, d: int)",
      "requires_clauses": [
        "x >= d > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (x / d) > 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_non_zero().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_is_strictly_smaller",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 213,
      "documentation": "Proof that a number gets strictly smaller when divided by a number\ngreater than one. Specifically, `x / d < x`.",
      "signature": "pub fn lemma_div_is_strictly_smaller(x: int, d: int)",
      "requires_clauses": [
        "0 < x",
        "1 < d"
      ],
      "ensures_clauses": [
        "# [trigger] (x / d) < x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_is_strictly_smaller().",
      "source": "vstd"
    },
    {
      "name": "lemma_dividing_sums",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 226,
      "documentation": "Proof that, given `r == a % d + b % d - (a + b) % d`, `r` can also\nbe expressed as `d * ((a + b) / d) - d * (a / d) - d * (b / d)`.",
      "signature": "pub fn lemma_dividing_sums(a: int, b: int, d: int, r: int)",
      "requires_clauses": [
        "0 < d",
        "r == a % d + b % d - (a + b) % d"
      ],
      "ensures_clauses": [
        "d * ((a + b) / d) - r == d * (a / d) + d * (b / d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_dividing_sums().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_plus_one",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 261,
      "documentation": "Proof that dividing a number then adding 1 gives the same result\nas adding the divisor and then doing the division. Specifically,\n`1 + (x / d)` is equal to `(d + x) / d`.",
      "signature": "pub fn lemma_div_plus_one(x: int, d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "1 + x / d == (d + x) / d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_plus_one().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_minus_one",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 274,
      "documentation": "Proof that dividing a number then subtracting 1 gives the same result\nas subtracting the divisor and then doing the division. Specifically,\n`-1 + (x / d)` is equal to `(-d + x) / d`.",
      "signature": "pub fn lemma_div_minus_one(x: int, d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "- 1 + x / d == (- d + x) / d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_minus_one().",
      "source": "vstd"
    },
    {
      "name": "lemma_basic_div_specific_divisor",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 286,
      "documentation": "Proof that dividing any non-negative integer less than `d` by `d`\nproduces a quotient of 0.",
      "signature": "pub fn lemma_basic_div_specific_divisor(d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "forall | x : int | 0 <= x < d ==> # [trigger] (x / d) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_basic_div_specific_divisor().",
      "source": "vstd"
    },
    {
      "name": "lemma_basic_div",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 297,
      "documentation": "Proof that dividing any non-negative integer by a larger integer\nproduces a quotient of 0.",
      "signature": "pub fn lemma_basic_div(x: int, d: int)",
      "requires_clauses": [
        "0 <= x < d"
      ],
      "ensures_clauses": [
        "# [trigger] (x / d) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_basic_div().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_nonincreasing",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 350,
      "documentation": "Proof that dividing an integer by 1 or more results in a quotient\nthat is less than or equal to the original dividend. Specifically,\n`x / d <= x`.",
      "signature": "pub fn lemma_div_nonincreasing(x: int, d: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < d"
      ],
      "ensures_clauses": [
        "# [trigger] (x / d) <= x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_nonincreasing().",
      "source": "vstd"
    },
    {
      "name": "lemma_small_mod",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 363,
      "documentation": "Proof that a natural number x divided by a larger natural number\ngives a remainder equal to x. Specifically, because `x < m`, we\nknow `x % m == x`.",
      "signature": "pub fn lemma_small_mod(x: nat, m: nat)",
      "requires_clauses": [
        "x < m",
        "0 < m"
      ],
      "ensures_clauses": [
        "x % m == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_small_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_breakdown",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 377,
      "documentation": "The remainder of a nonnegative integer `x` divided by the product of two positive integers\n`y` and `z` is equivalent to dividing `x` by `y`, dividing the quotient by `z`, multiplying\nthe remainder by `y`, and then adding the product to the remainder of `x` divided by `y`.\nIn mathematical terms, `(x % (y * z)) == y * ((x / y) % z) + x % y`.",
      "signature": "pub fn lemma_breakdown(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < y",
        "0 < z"
      ],
      "ensures_clauses": [
        "0 < y * z",
        "(x % (y * z)) == y * ((x / y) % z) + x % y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_breakdown().",
      "source": "vstd"
    },
    {
      "name": "lemma_remainder_upper",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 442,
      "documentation": "Proof that the difference between a nonnegative integer `x` and a\npositive integer `d` must be strictly less than the quotient of\n`x` divided by `d` and then multiplied by `d`.",
      "signature": "pub fn lemma_remainder_upper(x: int, d: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < d"
      ],
      "ensures_clauses": [
        "x - d < x / d * d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_remainder_upper().",
      "source": "vstd"
    },
    {
      "name": "lemma_remainder_lower",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 458,
      "documentation": "Proof that the division of a nonnegative integer `x` by a positive\ninteger `d` multiplied by `d` is less than or equal to the value\nof `x`.",
      "signature": "pub fn lemma_remainder_lower(x: int, d: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < d"
      ],
      "ensures_clauses": [
        "x >= # [trigger] (x / d * d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_remainder_lower().",
      "source": "vstd"
    },
    {
      "name": "lemma_remainder",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 474,
      "documentation": "Proof that the difference between a nonnegative integer `x` and\nthe division of `x` by a positive integer `d` multiplied by `d` is\nlower bounded (inclusively) by 0 and upper bounded (exclusively)\nby `d`.",
      "signature": "pub fn lemma_remainder(x: int, d: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < d"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x - (x / d * d)) < d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_remainder().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_denominator",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 502,
      "documentation": "Proof that dividing `x` by `c * d` is equivalent to first dividing\n`x` by `c` and then dividing the result by `d`.",
      "signature": "pub fn lemma_div_denominator(x: int, c: int, d: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < c",
        "0 < d"
      ],
      "ensures_clauses": [
        "c * d != 0",
        "# [trigger] ((x / c) / d) == x / (c * d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod_converse",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1338,
      "documentation": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `q` is the quotient `x / d` and `r` is the remainder `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod_converse(x: int, d: int, q: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d",
        "x == q * d + r"
      ],
      "ensures_clauses": [
        "r == x % d",
        "q == x / d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_hoist_inequality",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 601,
      "documentation": "Proof that multiplying an integer by a fraction is equivalent to\nmultiplying the fraction's numerator by the integer. Specifically,\n`x * (y / z) == (x * y) / z`.",
      "signature": "pub fn lemma_mul_hoist_inequality(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < z"
      ],
      "ensures_clauses": [
        "x * (y / z) <= (x * y) / z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mul_hoist_inequality().",
      "source": "vstd"
    },
    {
      "name": "lemma_indistinguishable_quotients",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 636,
      "documentation": "Proof that for a positive integer `d`, if `a - a % d` is less than\nor equal to `b` and `b` is less than `a + d - a % d`, then the\nquotient of `a` divided by `d` is equivalent to the quotient of\n`b` divided by `d`.\n\nIn other words, if `a` and `b` occur between the same two\nmultiples of `d`, then their quotient with `d` is equivalent.",
      "signature": "pub fn lemma_indistinguishable_quotients(a: int, b: int, d: int)",
      "requires_clauses": [
        "0 < d",
        "0 <= a - a % d <= b < a + d - a % d"
      ],
      "ensures_clauses": [
        "a / d == b / d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_indistinguishable_quotients().",
      "source": "vstd"
    },
    {
      "name": "lemma_truncate_middle",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 658,
      "documentation": "Proof that common factors from the dividend and divisor of a\nmodulus operation can be factored out. Specifically,\n`(b * x) % (b * c) == b * (x % c)`.",
      "signature": "pub fn lemma_truncate_middle(x: int, b: int, c: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < b",
        "0 < c"
      ],
      "ensures_clauses": [
        "0 < b * c",
        "(b * x) % (b * c) == b * (x % c)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_truncate_middle().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_multiples_vanish_quotient",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 695,
      "documentation": "Proof that multiplying the numerator and denominator by an integer\ndoes not change the quotient. Specifically,\n`a / d == (x * a) / (x * d)`.",
      "signature": "pub fn lemma_div_multiples_vanish_quotient(x: int, a: int, d: int)",
      "requires_clauses": [
        "0 < x",
        "0 <= a",
        "0 < d"
      ],
      "ensures_clauses": [
        "0 < x * d",
        "a / d == (x * a) / (x * d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_multiples_vanish_quotient().",
      "source": "vstd"
    },
    {
      "name": "lemma_round_down",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 721,
      "documentation": "Proof that, since `a % d == 0` and `0 <= r < d`, we can conclude\n`a == d * (a + r) / d`.",
      "signature": "pub fn lemma_round_down(a: int, r: int, d: int)",
      "requires_clauses": [
        "0 < d",
        "a % d == 0",
        "0 <= r < d"
      ],
      "ensures_clauses": [
        "a == d * ((a + r) / d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_round_down().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_multiples_vanish_fancy",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 736,
      "documentation": "Proof that, since `0 <= b < d`, we have `(d * x + b) / d == x`.",
      "signature": "pub fn lemma_div_multiples_vanish_fancy(x: int, b: int, d: int)",
      "requires_clauses": [
        "0 < d",
        "0 <= b < d"
      ],
      "ensures_clauses": [
        "(d * x + b) / d == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_multiples_vanish_fancy().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_by_multiple",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 788,
      "documentation": "Proof that multiplying a whole number by a common numerator and\ndenominator results in the original integer. Specifically,\n`(b * d) / d == b`.",
      "signature": "pub fn lemma_div_by_multiple(b: int, d: int)",
      "requires_clauses": [
        "0 <= b",
        "0 < d"
      ],
      "ensures_clauses": [
        "(b * d) / d == b"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_by_multiple().",
      "source": "vstd"
    },
    {
      "name": "lemma_div_by_multiple_is_strongly_ordered",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 804,
      "documentation": "Proof that a dividend that is a positive multiple of a divisor\nwill always yield a greater quotient than a smaller dividend.\nSpecifically, `x / z < y / z` because `y == m * z` and `x < y`.",
      "signature": "pub fn lemma_div_by_multiple_is_strongly_ordered(x: int, y: int, m: int, z: int)",
      "requires_clauses": [
        "x < y",
        "y == m * z",
        "0 < z"
      ],
      "ensures_clauses": [
        "x / z < y / z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_div_by_multiple_is_strongly_ordered().",
      "source": "vstd"
    },
    {
      "name": "lemma_multiply_divide_le",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 829,
      "documentation": "Proof that if an integer is less than or equal to the product of\ntwo other integers, then the quotient with one of them will be\nless than or equal to the other of them. Specifically, because\n`a <= b * c`, we know `a / b <= c`.",
      "signature": "pub fn lemma_multiply_divide_le(a: int, b: int, c: int)",
      "requires_clauses": [
        "0 < b",
        "a <= b * c"
      ],
      "ensures_clauses": [
        "a / b <= c"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_multiply_divide_le().",
      "source": "vstd"
    },
    {
      "name": "lemma_multiply_divide_lt",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 846,
      "documentation": "Proof that if an integer is less than the product of two other\nintegers, then the quotient with one of them will be less than the\nother. Specifically, because `a < b * c`, we know `a / b < c`.",
      "signature": "pub fn lemma_multiply_divide_lt(a: int, b: int, c: int)",
      "requires_clauses": [
        "0 < b",
        "a < b * c"
      ],
      "ensures_clauses": [
        "a / b < c"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_multiply_divide_lt().",
      "source": "vstd"
    },
    {
      "name": "lemma_hoist_over_denominator",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 872,
      "documentation": "Proof that adding an integer to a fraction is equivalent to adding\nthat integer times the denominator to the numerator. Specifically,\n`x / d + j == (x + j * d) / d`.",
      "signature": "pub fn lemma_hoist_over_denominator(x: int, j: int, d: nat)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "x / d as int + j == (x + j * d) / d as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_hoist_over_denominator().",
      "source": "vstd"
    },
    {
      "name": "lemma_part_bound1",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 899,
      "documentation": "Proof that, for nonnegative integer `a` and positive integers `b` and `c`,\nthe remainder of `b * (a / b)` divided by `b * c` is less than or equal to `b * (c - 1)`.\nThis accounts for the rounding down that occurs in integer division.",
      "signature": "pub fn lemma_part_bound1(a: int, b: int, c: int)",
      "requires_clauses": [
        "0 <= a",
        "0 < b",
        "0 < c"
      ],
      "ensures_clauses": [
        "0 < b * c",
        "(b * (a / b) % (b * c)) <= b * (c - 1)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_part_bound1().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_is_mod_recursive",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 940,
      "documentation": "Proof that computing the modulus using `%` is equivalent to\ncomputing it with a recursive definition of modulus. Specifically,\n`x % m` is equivalent in that way.",
      "signature": "pub fn lemma_mod_is_mod_recursive(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "mod_recursive (x , m) == # [trigger] (x % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_is_mod_recursive().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_self_0",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 999,
      "documentation": "Proof that any integer divided by itself produces a remainder of 0.",
      "signature": "pub fn lemma_mod_self_0(m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (m % m) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_self_0().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_twice",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1009,
      "documentation": "Proof that performing `(x % m) % m` gives the same result as simply perfoming `x % m`.",
      "signature": "pub fn lemma_mod_twice(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "# [trigger] ((x % m) % m) == x % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_twice().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_division_less_than_divisor",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1024,
      "documentation": "Proof that the remainder of any division will be less than the divisor's value.",
      "signature": "pub fn lemma_mod_division_less_than_divisor(x: int, m: int)",
      "requires_clauses": [
        "m > 0"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x % m) < m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_division_less_than_divisor().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_decreases",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1040,
      "documentation": "Proof that when natural number `x` is divided by natural number\n`m`, the remainder will be less than or equal to `x`.",
      "signature": "pub fn lemma_mod_decreases(x: nat, m: nat)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "# [trigger] (x % m) <= x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_decreases().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_is_zero",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1050,
      "documentation": "Proof that if `x % m` is zero and `x` is positive, then `x >= m`.",
      "signature": "pub fn lemma_mod_is_zero(x: nat, m: nat)",
      "requires_clauses": [
        "x > 0 && m > 0",
        "# [trigger] (x % m) == 0"
      ],
      "ensures_clauses": [
        "x >= m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_is_zero().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_add_multiples_vanish",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1081,
      "documentation": "Proof that adding the divisor to the dividend doesn't change the\nremainder. Specifically, `(m + b) % m == b % m`.",
      "signature": "pub fn lemma_mod_add_multiples_vanish(b: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(m + b) % m == # [trigger] (b % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_add_multiples_vanish().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_sub_multiples_vanish",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1092,
      "documentation": "Proof that subtracting the divisor from the dividend doesn't\nchange the remainder. Specifically, `(-m + b) % m == b % m`.",
      "signature": "pub fn lemma_mod_sub_multiples_vanish(b: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(- m + b) % m == # [trigger] (b % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_sub_multiples_vanish().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_multiples_vanish",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1104,
      "documentation": "Proof that adding any multiple of the divisor to the dividend will produce the\nsame remainder. In other words, `(m * a + b) % m == b % m`.",
      "signature": "pub fn lemma_mod_multiples_vanish(a: int, b: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "# [trigger] ((m * a + b) % m) == b % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_multiples_vanish().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_subtraction",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1128,
      "documentation": "Proof that modulo distributes over subtraction if the subtracted value is\nless than or equal to the modulo of the number it's being subtracted from.\nSpecifically, because `0 <= s <= x % d`, we can conclude that\n`x % d - s % d == (x - s) % d`.",
      "signature": "pub fn lemma_mod_subtraction(x: nat, s: nat, d: nat)",
      "requires_clauses": [
        "0 < d",
        "0 <= s <= x % d"
      ],
      "ensures_clauses": [
        "x % d - s % d == (x - s) % d as int"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_subtraction().",
      "source": "vstd"
    },
    {
      "name": "lemma_add_mod_noop",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1142,
      "documentation": "Proof that modulo distributes over addition, provided you do an\nextra modulo after adding the remainders. Specifically,\n`((x % m) + (y % m)) % m == (x + y) % m`.",
      "signature": "pub fn lemma_add_mod_noop(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "((x % m) + (y % m)) % m == (x + y) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_add_mod_noop().",
      "source": "vstd"
    },
    {
      "name": "lemma_add_mod_noop_right",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1155,
      "documentation": "Proof that describes an expanded and succinct version of modulus\noperator in relation to addition. Specifically,\n`(x + (y % m)) % m == (x + y) % m`.",
      "signature": "pub fn lemma_add_mod_noop_right(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(x + (y % m)) % m == (x + y) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_add_mod_noop_right().",
      "source": "vstd"
    },
    {
      "name": "lemma_sub_mod_noop",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1168,
      "documentation": "Proof that modulo distributes over subtraction provided you do an\nextra modulo operation after subtracting the remainders.\nSpecifically, `((x % m) - (y % m)) % m == (x - y) % m`.",
      "signature": "pub fn lemma_sub_mod_noop(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "((x % m) - (y % m)) % m == (x - y) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_sub_mod_noop().",
      "source": "vstd"
    },
    {
      "name": "lemma_sub_mod_noop_right",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1181,
      "documentation": "Proof that describes an expanded and succinct version of modulus\noperator in relation to subtraction. Specifically,\n`(x - (y % m)) % m == (x - y) % m`.",
      "signature": "pub fn lemma_sub_mod_noop_right(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(x - (y % m)) % m == (x - y) % m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_sub_mod_noop_right().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_adds",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1194,
      "documentation": "Proof of two properties of the sum of two remainders with the same dividend:\n1) `a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)`.\n2) `(a % d + b % d) < d ==> a % d + b % d == (a + b) % d`.",
      "signature": "pub fn lemma_mod_adds(a: int, b: int, d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)",
        "(a % d + b % d) < d ==> a % d + b % d == (a + b) % d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_adds().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_neg_neg",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1211,
      "documentation": "Proof that the remainder when dividing integer `x` by positive\ninteger `d` is equivalent to the remainder of `x * (1 - d)` by\n`d`.",
      "signature": "pub fn lemma_mod_neg_neg(x: int, d: int)",
      "requires_clauses": [
        "0 < d"
      ],
      "ensures_clauses": [
        "x % d == (x * (1 - d)) % d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_neg_neg().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod_converse_helper_1",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1233,
      "documentation": "This proof isn't exported from this module. It's just used in\nthe proof of [`lemma_fundamental_div_mod_converse`].",
      "signature": "fn lemma_fundamental_div_mod_converse_helper_1(u: int, d: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d"
      ],
      "ensures_clauses": [
        "u == (u * d + r) / d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_helper_1().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod_converse_helper_2",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1266,
      "documentation": "This proof isn't exported from this module. It's just used in\nthe proof of [`lemma_fundamental_div_mod_converse`].",
      "signature": "fn lemma_fundamental_div_mod_converse_helper_2(u: int, d: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d"
      ],
      "ensures_clauses": [
        "r == (u * d + r) % d"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_helper_2().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod_converse_mod",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1306,
      "documentation": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `r` is the remainder `x % d`.",
      "signature": "pub fn lemma_fundamental_div_mod_converse_mod(x: int, d: int, q: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d",
        "x == # [trigger] (q * d + r)"
      ],
      "ensures_clauses": [
        "r == # [trigger] (x % d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_fundamental_div_mod_converse_div",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1322,
      "documentation": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `q` is the quotient `x / d`.",
      "signature": "pub fn lemma_fundamental_div_mod_converse_div(x: int, d: int, q: int, r: int)",
      "requires_clauses": [
        "d != 0",
        "0 <= r < d",
        "x == # [trigger] (q * d + r)"
      ],
      "ensures_clauses": [
        "q == # [trigger] (x / d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_fundamental_div_mod_converse_div().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_pos_bound",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1358,
      "documentation": "Proof that the remainder, when natural number `x` is divided by\npositive integer `m`, is less than `m`.",
      "signature": "pub fn lemma_mod_pos_bound(x: int, m: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < m"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x % m) < m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_pos_bound().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_bound",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1370,
      "documentation": "Proof that when integer `x` is divided by positive integer `m`,\nthe remainder is nonegative and less than `m`.",
      "signature": "pub fn lemma_mod_bound(x: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "0 <= # [trigger] (x % m) < m"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_bound().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_mod_noop_left",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1381,
      "documentation": "Proof that the remainder when `x * y` is divided by `m` is\nequivalent to the remainder when `(x % m) * y` is divided by `m`.",
      "signature": "pub fn lemma_mul_mod_noop_left(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(x % m) * y % m == # [trigger] (x * y % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mul_mod_noop_left().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_mod_noop_right",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1393,
      "documentation": "Proof that the remainder when `x * y` is divided by `m` is\nequivalent to the remainder when `x * (y % m)` is divided by `m`.",
      "signature": "pub fn lemma_mul_mod_noop_right(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "x * (y % m) % m == # [trigger] ((x * y) % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mul_mod_noop_right().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_mod_noop_general",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1406,
      "documentation": "Proof of various properties about modulo equivalence with respect\nto multiplication, specifically various expressions that `(x * y)\n% m` is equivalent to.",
      "signature": "pub fn lemma_mul_mod_noop_general(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "((x % m) * y) % m == (x * y) % m",
        "(x * (y % m)) % m == (x * y) % m",
        "((x % m) * (y % m)) % m == # [trigger] ((x * y) % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mul_mod_noop_general().",
      "source": "vstd"
    },
    {
      "name": "lemma_mul_mod_noop",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1422,
      "documentation": "Proof that modulo distributes over multiplication, provided you do\nan extra modulo operation after multiplying the remainders. Specifically,\n`(x % m) * (y % m) % m == (x * y) % m`.",
      "signature": "pub fn lemma_mul_mod_noop(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "(x % m) * (y % m) % m == # [trigger] ((x * y) % m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mul_mod_noop().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_equivalence",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1438,
      "documentation": "Proof that `x` and `y` are congruent modulo `m` if and only if `x\n- y` is congruent to 0 modulo `m`. In other words, `x % m == y % m\n<==> (x - y) % m == 0`.\n\nNote: The Dafny standard library uses the triggers `x % m, y % m`\nfor the broadcasted forall quantifier. But this can lead to a trigger loop,\nso we don't do that here.",
      "signature": "pub fn lemma_mod_equivalence(x: int, y: int, m: int)",
      "requires_clauses": [
        "0 < m"
      ],
      "ensures_clauses": [
        "x % m == y % m <==> (x - y) % m == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_equivalence().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_mul_equivalent",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1459,
      "documentation": "Proof that if `is_mod_equivalent` holds for `x`, `y`, and `m`,\nthen it holds for `x * z`, `y * z`, and `m`.",
      "signature": "pub fn lemma_mod_mul_equivalent(x: int, y: int, z: int, m: int)",
      "requires_clauses": [
        "m > 0",
        "is_mod_equivalent (x , y , m)"
      ],
      "ensures_clauses": [
        "# [trigger] is_mod_equivalent (x * z , y * z , m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_mul_equivalent().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_ordering",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1475,
      "documentation": "Proof that multiplying the divisor by a positive number can't\ndecrease the remainder. Specifically, because `k > 0`, we have\n`x % d <= x % (d * k)`.",
      "signature": "pub fn lemma_mod_ordering(x: int, k: int, d: int)",
      "requires_clauses": [
        "1 < d",
        "0 < k"
      ],
      "ensures_clauses": [
        "0 < d * k",
        "x % d <= # [trigger] (x % (d * k))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_ordering().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_mod",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1524,
      "documentation": "Proof that the remainder when `x` is divided by `a * b`, taken\nmodulo `a`, is equivalent to `x` modulo `a`. That is,\n`(x % (a * b)) % a == x % a`.",
      "signature": "pub fn lemma_mod_mod(x: int, a: int, b: int)",
      "requires_clauses": [
        "0 < a",
        "0 < b"
      ],
      "ensures_clauses": [
        "0 < a * b",
        "(x % (a * b)) % a == x % a"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_mod().",
      "source": "vstd"
    },
    {
      "name": "lemma_part_bound2",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1564,
      "documentation": "Proof that `(x % y) % (y * z) < y`.",
      "signature": "pub fn lemma_part_bound2(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < y",
        "0 < z"
      ],
      "ensures_clauses": [
        "y * z > 0",
        "# [trigger] (x % y) % # [trigger] (y * z) < y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_part_bound2().",
      "source": "vstd"
    },
    {
      "name": "lemma_mod_breakdown",
      "file_path": "arithmetic/div_mod.rs",
      "line_number": 1589,
      "documentation": "Proof of the validity of an expanded form of the modulus operation.\nSpecifically, `x % (y * z) == y * ((x / y) % z) + x % y`.",
      "signature": "pub fn lemma_mod_breakdown(x: int, y: int, z: int)",
      "requires_clauses": [
        "0 <= x",
        "0 < y",
        "0 < z"
      ],
      "ensures_clauses": [
        "y * z > 0",
        "x % (y * z) == y * ((x / y) % z) + x % y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 div_mod/arithmetic/lemma_mod_breakdown().",
      "source": "vstd"
    },
    {
      "name": "range_all_spec_rec",
      "file_path": "compute.rs",
      "line_number": 13,
      "documentation": "",
      "signature": "pub fn range_all_spec_rec(r: Range<int>, p: spec_fn(int) -> bool) -> bool",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 compute/range_all_spec_rec().",
      "source": "vstd"
    },
    {
      "name": "spec_u16_to_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 16,
      "documentation": "",
      "signature": "pub fn spec_u16_to_le_bytes(x: u16) -> Seq<u8>",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u16_to_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u16_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 24,
      "documentation": "",
      "signature": "pub fn spec_u16_from_le_bytes(s: Seq<u8>) -> u16",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u16_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "lemma_auto_spec_u16_to_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 32,
      "documentation": "",
      "signature": "pub fn lemma_auto_spec_u16_to_from_le_bytes()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : u16 | { &&& # [trigger] spec_u16_to_le_bytes (x) . len () == 2 &&& spec_u16_from_le_bytes (spec_u16_to_le_bytes (x)) == x }",
        "forall | s : Seq < u8 > | s . len () == 2 ==> # [trigger] spec_u16_to_le_bytes (spec_u16_from_le_bytes (s)) == s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/lemma_auto_spec_u16_to_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u32_to_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 100,
      "documentation": "",
      "signature": "pub fn spec_u32_to_le_bytes(x: u32) -> Seq<u8>",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u32_to_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u32_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 110,
      "documentation": "",
      "signature": "pub fn spec_u32_from_le_bytes(s: Seq<u8>) -> u32",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u32_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "lemma_auto_spec_u32_to_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 117,
      "documentation": "",
      "signature": "pub fn lemma_auto_spec_u32_to_from_le_bytes()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : u32 | { &&& # [trigger] spec_u32_to_le_bytes (x) . len () == 4 &&& spec_u32_from_le_bytes (spec_u32_to_le_bytes (x)) == x }",
        "forall | s : Seq < u8 > | s . len () == 4 ==> # [trigger] spec_u32_to_le_bytes (spec_u32_from_le_bytes (s)) == s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/lemma_auto_spec_u32_to_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u64_to_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 195,
      "documentation": "",
      "signature": "pub fn spec_u64_to_le_bytes(x: u64) -> Seq<u8>",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u64_to_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u64_to_le_bytes_open",
      "file_path": "bytes.rs",
      "line_number": 216,
      "documentation": "",
      "signature": "pub fn spec_u64_to_le_bytes_open(x: u64) -> Seq<u8>",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u64_to_le_bytes_open().",
      "source": "vstd"
    },
    {
      "name": "spec_u64_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 230,
      "documentation": "",
      "signature": "pub fn spec_u64_from_le_bytes(s: Seq<u8>) -> u64",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u64_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "lemma_auto_spec_u64_to_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 246,
      "documentation": "",
      "signature": "pub fn lemma_auto_spec_u64_to_from_le_bytes()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : u64 | # ! [trigger spec_u64_to_le_bytes (x)] { &&& spec_u64_to_le_bytes (x) . len () == 8 &&& spec_u64_from_le_bytes (spec_u64_to_le_bytes (x)) == x }",
        "forall | s : Seq < u8 > | # ! [trigger spec_u64_to_le_bytes (spec_u64_from_le_bytes (s))] s . len () == 8 ==> spec_u64_to_le_bytes (spec_u64_from_le_bytes (s)) == s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/lemma_auto_spec_u64_to_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u64_to_le_bytes_to_open",
      "file_path": "bytes.rs",
      "line_number": 324,
      "documentation": "",
      "signature": "pub fn spec_u64_to_le_bytes_to_open(x: u64)",
      "requires_clauses": [],
      "ensures_clauses": [
        "spec_u64_to_le_bytes (x) == spec_u64_to_le_bytes_open (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u64_to_le_bytes_to_open().",
      "source": "vstd"
    },
    {
      "name": "spec_u128_to_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 352,
      "documentation": "",
      "signature": "pub fn spec_u128_to_le_bytes(x: u128) -> Seq<u8>",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u128_to_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "spec_u128_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 374,
      "documentation": "",
      "signature": "pub fn spec_u128_from_le_bytes(s: Seq<u8>) -> u128",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/spec_u128_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "lemma_auto_spec_u128_to_from_le_bytes",
      "file_path": "bytes.rs",
      "line_number": 398,
      "documentation": "",
      "signature": "pub fn lemma_auto_spec_u128_to_from_le_bytes()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | x : u128 | { &&& # [trigger] spec_u128_to_le_bytes (x) . len () == 16 &&& spec_u128_from_le_bytes (spec_u128_to_le_bytes (x)) == x }",
        "forall | s : Seq < u8 > | s . len () == 16 ==> # [trigger] spec_u128_to_le_bytes (spec_u128_from_le_bytes (s)) == s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bytes/lemma_auto_spec_u128_to_from_le_bytes().",
      "source": "vstd"
    },
    {
      "name": "lemma_array_index",
      "file_path": "array.rs",
      "line_number": 50,
      "documentation": "",
      "signature": "pub fn lemma_array_index<T, const N: usize>(a: [T; N], i: int)",
      "requires_clauses": [
        "0 <= i < N"
      ],
      "ensures_clauses": [
        "a [i] == array_view (a) [i]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 array/lemma_array_index().",
      "source": "vstd"
    },
    {
      "name": "spec_array_as_slice",
      "file_path": "array.rs",
      "line_number": 87,
      "documentation": "",
      "signature": "pub fn spec_array_as_slice<T, const N: usize>(ar: &[T; N]) -> &[T]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 array/spec_array_as_slice().",
      "source": "vstd"
    },
    {
      "name": "axiom_spec_array_as_slice",
      "file_path": "array.rs",
      "line_number": 89,
      "documentation": "",
      "signature": "pub fn axiom_spec_array_as_slice<T, const N: usize>(ar: &[T; N])",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] spec_array_as_slice (ar)) @ == ar @"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 array/axiom_spec_array_as_slice().",
      "source": "vstd"
    },
    {
      "name": "spec_array_fill_for_copy_type",
      "file_path": "array.rs",
      "line_number": 111,
      "documentation": "",
      "signature": "pub fn spec_array_fill_for_copy_type<T, const N: usize>(t: T) -> [T; N]\nwhere\n    T: Copy,",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 array/spec_array_fill_for_copy_type().",
      "source": "vstd"
    },
    {
      "name": "axiom_spec_array_fill_for_copy_type",
      "file_path": "array.rs",
      "line_number": 113,
      "documentation": "",
      "signature": "pub fn axiom_spec_array_fill_for_copy_type<T, const N: usize>(t: T)\nwhere\n    T: Copy,",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | i : int | 0 <= i < N ==> spec_array_fill_for_copy_type :: < T , N > (t) . view () [i] == t"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 array/axiom_spec_array_fill_for_copy_type().",
      "source": "vstd"
    },
    {
      "name": "axiom_array_ext_equal",
      "file_path": "array.rs",
      "line_number": 134,
      "documentation": "",
      "signature": "pub fn axiom_array_ext_equal<T, const N: usize>(a1: [T; N], a2: [T; N])",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (a1 =~= a2) <==> (forall | i : int | 0 <= i < N ==> a1 [i] == a2 [i])"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 array/axiom_array_ext_equal().",
      "source": "vstd"
    },
    {
      "name": "axiom_proof_fn_requires",
      "file_path": "function.rs",
      "line_number": 80,
      "documentation": "",
      "signature": "pub fn axiom_proof_fn_requires<F, ArgModes, OutMode, Args, Output>(f: FnProof<F, ArgModes, OutMode, Args, Output>, args: Args)\nwhere\n    Args: core::marker::Tuple,\n    F: ProofFnOnce + ProofFnReqEnsAssoc,\n    <F as ProofFnReqEnsAssoc>::ReqEns: ProofFnReqEnsDef<Args, Output>,",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] f . requires (args) <==> < F as ProofFnReqEnsAssoc > :: ReqEns :: req (args)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 function/axiom_proof_fn_requires().",
      "source": "vstd"
    },
    {
      "name": "axiom_proof_fn_ensures",
      "file_path": "function.rs",
      "line_number": 96,
      "documentation": "",
      "signature": "pub fn axiom_proof_fn_ensures<F, ArgModes, OutMode, Args, Output>(f: FnProof<F, ArgModes, OutMode, Args, Output>, args: Args, output: Output)\nwhere\n    Args: core::marker::Tuple,\n    F: ProofFnOnce + ProofFnReqEnsAssoc,\n    <F as ProofFnReqEnsAssoc>::ReqEns: ProofFnReqEnsDef<Args, Output>,",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] f . ensures (args , output) <==> < F as ProofFnReqEnsAssoc > :: ReqEns :: ens (args , output ,)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 function/axiom_proof_fn_ensures().",
      "source": "vstd"
    },
    {
      "name": "proof_fn_as_req_ens",
      "file_path": "function.rs",
      "line_number": 115,
      "documentation": "Retype a proof_fn, introducing `ReqEns<R>`",
      "signature": "pub fn proof_fn_as_req_ens<R, const USAGE: u8, ReqEns, const COPY: u8, const SEND: u8, const SYNC: u8, ArgModes, OutMode, Args, Output>(f: FnProof<FOpts<USAGE, ReqEns, COPY, SEND, SYNC>, ArgModes, OutMode, Args, Output>) -> FnProof<FOpts<USAGE, RqEn<R>, COPY, SEND, SYNC>, ArgModes, OutMode, Args, Output>\nwhere\n    R: ProofFnReqEnsDef<Args, Output>,\n    Args: core::marker::Tuple,",
      "requires_clauses": [
        "forall | args : Args | # [trigger] R :: req (args) ==> f . requires (args)",
        "forall | args : Args , output : Output | f . ensures (args , output) ==> # [trigger] R :: ens (args , output)"
      ],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 function/proof_fn_as_req_ens().",
      "source": "vstd"
    },
    {
      "name": "lemma_len_intersect",
      "file_path": "set_lib.rs",
      "line_number": 848,
      "documentation": "The size of the intersection of finite set `s1` and set `s2` is less than or equal to the size of `s1`.",
      "signature": "pub fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite ()"
      ],
      "ensures_clauses": [
        "s1 . intersect (s2) . len () <= s1 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_len_intersect().",
      "source": "vstd"
    },
    {
      "name": "lemma_len_subset",
      "file_path": "set_lib.rs",
      "line_number": 866,
      "documentation": "If `s1` is a subset of finite set `s2`, then the size of `s1` is less than or equal to\nthe size of `s2` and `s1` must be finite.",
      "signature": "pub fn lemma_len_subset<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s2 . finite ()",
        "s1 . subset_of (s2)"
      ],
      "ensures_clauses": [
        "s1 . len () <= s2 . len ()",
        "s1 . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_len_subset().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_empty_equivalency_len",
      "file_path": "set_lib.rs",
      "line_number": 1077,
      "documentation": "Set `s` has length 0 if and only if it is equal to the empty set. If `s` has length greater than 0,\nThen there must exist an element `x` such that `s` contains `x`.",
      "signature": "pub fn lemma_set_empty_equivalency_len<A>(s: Set<A>)",
      "requires_clauses": [
        "s . finite ()"
      ],
      "ensures_clauses": [
        "(s . len () == 0 <==> s == Set :: < A > :: empty ()) && (s . len () != 0 ==> exists | x : A | s . contains (x))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_empty_equivalency_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_sets_eq_iff_injective_map_eq",
      "file_path": "set_lib.rs",
      "line_number": 710,
      "documentation": "Two sets are equal iff mapping `f` results in equal sets, if `f` is injective.",
      "signature": "pub fn lemma_sets_eq_iff_injective_map_eq<T, S>(s1: Set<T>, s2: Set<T>, f: spec_fn(T) -> S)",
      "requires_clauses": [
        "super :: relations :: injective (f)"
      ],
      "ensures_clauses": [
        "(s1 == s2) <==> (s1 . map (f) == s2 . map (f))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_sets_eq_iff_injective_map_eq().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_insert_finite_iff",
      "file_path": "set_lib.rs",
      "line_number": 732,
      "documentation": "The result of inserting an element `a` into a set `s` is finite iff `s` is finite.",
      "signature": "pub fn lemma_set_insert_finite_iff<A>(s: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . insert (a) . finite () <==> s . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_insert_finite_iff().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_remove_finite_iff",
      "file_path": "set_lib.rs",
      "line_number": 747,
      "documentation": "The result of removing an element `a` into a set `s` is finite iff `s` is finite.",
      "signature": "pub fn lemma_set_remove_finite_iff<A>(s: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . remove (a) . finite () <==> s . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_remove_finite_iff().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_union_finite_iff",
      "file_path": "set_lib.rs",
      "line_number": 761,
      "documentation": "The union of two sets is finite iff both sets are finite.",
      "signature": "pub fn lemma_set_union_finite_iff<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s1 . union (s2) . finite () <==> s1 . finite () && s2 . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_union_finite_iff().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_union_finite_implies_sets_finite",
      "file_path": "set_lib.rs",
      "line_number": 770,
      "documentation": "",
      "signature": "pub fn lemma_set_union_finite_implies_sets_finite<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . union (s2) . finite ()"
      ],
      "ensures_clauses": [
        "s1 . finite ()",
        "s2 . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_union_finite_implies_sets_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_remove_len",
      "file_path": "set_lib.rs",
      "line_number": null,
      "documentation": "The result of removing an element `a` from a finite set `s` has length\n`s.len() - 1` if `a` is in `s` and length `s.len()` otherwise.",
      "signature": "pub fn axiom_set_remove_len<A>(s: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_remove_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_len_union",
      "file_path": "set_lib.rs",
      "line_number": 800,
      "documentation": "The size of a union of two sets is less than or equal to the size of\nboth individual sets combined.",
      "signature": "pub fn lemma_len_union<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite ()",
        "s2 . finite ()"
      ],
      "ensures_clauses": [
        "s1 . union (s2) . len () <= s1 . len () + s2 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_len_union().",
      "source": "vstd"
    },
    {
      "name": "lemma_len_union_ind",
      "file_path": "set_lib.rs",
      "line_number": 823,
      "documentation": "The size of a union of two sets is greater than or equal to the size of\nboth individual sets.",
      "signature": "pub fn lemma_len_union_ind<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite ()",
        "s2 . finite ()"
      ],
      "ensures_clauses": [
        "s1 . union (s2) . len () >= s1 . len ()",
        "s1 . union (s2) . len () >= s2 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_len_union_ind().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_subset_finite",
      "file_path": "set_lib.rs",
      "line_number": 879,
      "documentation": "A subset of a finite set `s` is finite.",
      "signature": "pub fn lemma_set_subset_finite<A>(s: Set<A>, sub: Set<A>)",
      "requires_clauses": [
        "s . finite ()",
        "sub . subset_of (s)"
      ],
      "ensures_clauses": [
        "sub . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_subset_finite().",
      "source": "vstd"
    },
    {
      "name": "lemma_len_difference",
      "file_path": "set_lib.rs",
      "line_number": 892,
      "documentation": "The size of the difference of finite set `s1` and set `s2` is less than or equal to the size of `s1`.",
      "signature": "pub fn lemma_len_difference<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite ()"
      ],
      "ensures_clauses": [
        "s1 . difference (s2) . len () <= s1 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_len_difference().",
      "source": "vstd"
    },
    {
      "name": "lemma_int_range",
      "file_path": "set_lib.rs",
      "line_number": 915,
      "documentation": "If a set solely contains integers in the range [a, b), then its size is\nbounded by b - a.",
      "signature": "pub fn lemma_int_range(lo: int, hi: int)",
      "requires_clauses": [
        "lo <= hi"
      ],
      "ensures_clauses": [
        "set_int_range (lo , hi) . finite ()",
        "set_int_range (lo , hi) . len () == hi - lo"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_int_range().",
      "source": "vstd"
    },
    {
      "name": "lemma_subset_equality",
      "file_path": "set_lib.rs",
      "line_number": 932,
      "documentation": "If x is a subset of y and the size of x is equal to the size of y, x is equal to y.",
      "signature": "pub fn lemma_subset_equality<A>(x: Set<A>, y: Set<A>)",
      "requires_clauses": [
        "x . subset_of (y)",
        "x . finite ()",
        "y . finite ()",
        "x . len () == y . len ()"
      ],
      "ensures_clauses": [
        "x =~= y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_subset_equality().",
      "source": "vstd"
    },
    {
      "name": "lemma_map_size",
      "file_path": "set_lib.rs",
      "line_number": 953,
      "documentation": "If an injective function is applied to each element of a set to construct\nanother set, the two sets have the same size.",
      "signature": "pub fn lemma_map_size<A, B>(x: Set<A>, y: Set<B>, f: spec_fn(A) -> B)",
      "requires_clauses": [
        "x . finite ()",
        "injective_on (f , x)",
        "x . map (f) == y"
      ],
      "ensures_clauses": [
        "y . finite ()",
        "x . len () == y . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_map_size().",
      "source": "vstd"
    },
    {
      "name": "lemma_map_size_bound",
      "file_path": "set_lib.rs",
      "line_number": 979,
      "documentation": "If any function is applied to each element of a set to construct\nanother set, the constructed set's length is at most the original's",
      "signature": "pub fn lemma_map_size_bound<A, B>(x: Set<A>, y: Set<B>, f: spec_fn(A) -> B)",
      "requires_clauses": [
        "x . finite ()",
        "x . map (f) == y"
      ],
      "ensures_clauses": [
        "y . finite ()",
        "y . len () <= x . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_map_size_bound().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_union_again1",
      "file_path": "set_lib.rs",
      "line_number": 1016,
      "documentation": "Taking the union of sets `a` and `b` and then taking the union of the result with `b`\nis the same as taking the union of `a` and `b` once.",
      "signature": "pub fn lemma_set_union_again1<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] a . union (b) . union (b) =~= a . union (b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_union_again1().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_union_again2",
      "file_path": "set_lib.rs",
      "line_number": 1025,
      "documentation": "Taking the union of sets `a` and `b` and then taking the union of the result with `a`\nis the same as taking the union of `a` and `b` once.",
      "signature": "pub fn lemma_set_union_again2<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] a . union (b) . union (a) =~= a . union (b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_union_again2().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_intersect_again1",
      "file_path": "set_lib.rs",
      "line_number": 1034,
      "documentation": "Taking the intersection of sets `a` and `b` and then taking the intersection of the result with `b`\nis the same as taking the intersection of `a` and `b` once.",
      "signature": "pub fn lemma_set_intersect_again1<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(a . intersect (b)) . intersect (b) =~= a . intersect (b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_intersect_again1().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_intersect_again2",
      "file_path": "set_lib.rs",
      "line_number": 1044,
      "documentation": "Taking the intersection of sets `a` and `b` and then taking the intersection of the result with `a`\nis the same as taking the intersection of `a` and `b` once.",
      "signature": "pub fn lemma_set_intersect_again2<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(a . intersect (b)) . intersect (a) =~= a . intersect (b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_intersect_again2().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_difference2",
      "file_path": "set_lib.rs",
      "line_number": 1053,
      "documentation": "If set `s2` contains element `a`, then the set difference of `s1` and `s2` does not contain `a`.",
      "signature": "pub fn lemma_set_difference2<A>(s1: Set<A>, s2: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "s2 . contains (a) ==> ! s1 . difference (s2) . contains (a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_difference2().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_disjoint",
      "file_path": "set_lib.rs",
      "line_number": 1063,
      "documentation": "If sets `a` and `b` are disjoint, meaning they have no elements in common, then the set difference\nof `a + b` and `b` is equal to `a` and the set difference of `a + b` and `a` is equal to `b`.",
      "signature": "pub fn lemma_set_disjoint<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "a . disjoint (b) ==> ((a + b) . difference (a) =~= b && (a + b) . difference (b) =~= a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_disjoint().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_disjoint_lens",
      "file_path": "set_lib.rs",
      "line_number": 1104,
      "documentation": "If sets `a` and `b` are disjoint, meaning they share no elements in common, then the length\nof the union `a + b` is equal to the sum of the lengths of `a` and `b`.",
      "signature": "pub fn lemma_set_disjoint_lens<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [
        "a . finite ()",
        "b . finite ()"
      ],
      "ensures_clauses": [
        "a . disjoint (b) ==> # [trigger] (a + b) . len () == a . len () + b . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_disjoint_lens().",
      "source": "vstd"
    },
    {
      "name": "lemma_disjoint_iff_empty_intersection",
      "file_path": "set_lib.rs",
      "line_number": 1125,
      "documentation": "Two sets are disjoint iff their intersection is empty",
      "signature": "pub fn lemma_disjoint_iff_empty_intersection<T>(a: Set<T>, b: Set<T>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "a . disjoint (b) <==> a . intersect (b) . is_empty ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_disjoint_iff_empty_intersection().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_intersect_union_lens",
      "file_path": "set_lib.rs",
      "line_number": 1151,
      "documentation": "The length of the union between two sets added to the length of the intersection between the\ntwo sets is equal to the sum of the lengths of the two sets.",
      "signature": "pub fn lemma_set_intersect_union_lens<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [
        "a . finite ()",
        "b . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] (a + b) . len () + # [trigger] a . intersect (b) . len () == a . len () + b . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_intersect_union_lens().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_difference_len",
      "file_path": "set_lib.rs",
      "line_number": 1183,
      "documentation": "The length of the set difference `A \\ B` added to the length of the set difference `B \\ A` added to\nthe length of the intersection `A \u2229 B` is equal to the length of the union `A + B`.\n\nThe length of the set difference `A \\ B` is equal to the length of `A` minus the length of the\nintersection `A \u2229 B`.",
      "signature": "pub fn lemma_set_difference_len<A>(a: Set<A>, b: Set<A>)",
      "requires_clauses": [
        "a . finite ()",
        "b . finite ()"
      ],
      "ensures_clauses": [
        "(# [trigger] a . difference (b) . len () + b . difference (a) . len () + a . intersect (b) . len () == (a + b) . len ()) && (a . difference (b) . len () == a . len () - a . intersect (b) . len ())"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_difference_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_set_properties",
      "file_path": "set_lib.rs",
      "line_number": 1217,
      "documentation": "Properties of sets from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
      "signature": "pub fn lemma_set_properties<A>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | a : Set < A > , b : Set < A > | # [trigger] a . union (b) . union (b) == a . union (b)",
        "forall | a : Set < A > , b : Set < A > | # [trigger] a . union (b) . union (a) == a . union (b)",
        "forall | a : Set < A > , b : Set < A > | # [trigger] (a . intersect (b)) . intersect (b) == a . intersect (b)",
        "forall | a : Set < A > , b : Set < A > | # [trigger] (a . intersect (b)) . intersect (a) == a . intersect (b)",
        "forall | s1 : Set < A > , s2 : Set < A > , a : A | s2 . contains (a) ==> ! s1 . difference (s2) . contains (a)",
        "forall | a : Set < A > , b : Set < A > | # ! [trigger (a + b) . difference (a)] a . disjoint (b) ==> ((a + b) . difference (a) =~= b && (a + b) . difference (b) =~= a)",
        "forall | s : Set < A > | # [trigger] s . len () != 0 && s . finite () ==> exists | a : A | s . contains (a)",
        "forall | a : Set < A > , b : Set < A > | (a . finite () && b . finite () && a . disjoint (b)) ==> # [trigger] (a + b) . len () == a . len () + b . len ()",
        "forall | a : Set < A > , b : Set < A > | (a . finite () && b . finite ()) ==> # [trigger] (a + b) . len () + # [trigger] a . intersect (b ,) . len () == a . len () + b . len ()",
        "forall | a : Set < A > , b : Set < A > | (a . finite () && b . finite ()) ==> ((# [trigger] a . difference (b) . len () + b . difference (a ,) . len () + a . intersect (b) . len () == (a + b) . len ()) && (a . difference (b) . len () == a . len () - a . intersect (b) . len ()))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/lemma_set_properties().",
      "source": "vstd"
    },
    {
      "name": "axiom_is_empty",
      "file_path": "set_lib.rs",
      "line_number": 1264,
      "documentation": "",
      "signature": "pub fn axiom_is_empty<A>(s: Set<A>)",
      "requires_clauses": [
        "! (# [trigger] s . is_empty ())"
      ],
      "ensures_clauses": [
        "exists | a : A | s . contains (a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/axiom_is_empty().",
      "source": "vstd"
    },
    {
      "name": "axiom_is_empty_len0",
      "file_path": "set_lib.rs",
      "line_number": 1273,
      "documentation": "",
      "signature": "pub fn axiom_is_empty_len0<A>(s: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . is_empty () <==> (s . finite () && s . len () == 0)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set_lib/axiom_is_empty_len0().",
      "source": "vstd"
    },
    {
      "name": "axiom_hash_set_with_view_spec_len",
      "file_path": "hash_set.rs",
      "line_number": 162,
      "documentation": "",
      "signature": "pub fn axiom_hash_set_with_view_spec_len<Key>(m: &HashSetWithView<Key>)\nwhere\n    Key: View + Eq + Hash,",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . spec_len () == m @ . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 hash_set/axiom_hash_set_with_view_spec_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_string_hash_set_spec_len",
      "file_path": "hash_set.rs",
      "line_number": 305,
      "documentation": "",
      "signature": "pub fn axiom_string_hash_set_spec_len(m: &StringHashSet)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . spec_len () == m @ . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 hash_set/axiom_string_hash_set_spec_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_submap_of_trans",
      "file_path": "tokens/map.rs",
      "line_number": null,
      "documentation": "submap_of (<=) is transitive.",
      "signature": "pub fn lemma_submap_of_trans<K, V>(m1: Map<K, V>, m2: Map<K, V>, m3: Map<K, V>)",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_submap_of_trans().",
      "source": "vstd"
    },
    {
      "name": "lemma_submap_of_op_frac",
      "file_path": "tokens/map.rs",
      "line_number": 261,
      "documentation": "",
      "signature": "fn lemma_submap_of_op_frac<K, V>(a: MapCarrier<K, V>, b: MapCarrier<K, V>)",
      "requires_clauses": [
        "MapCarrier :: op (a , b) . valid ()"
      ],
      "ensures_clauses": [
        "a . frac . owning_map () <= MapCarrier :: op (a , b) . frac . owning_map ()",
        "a . frac . dup_map () <= MapCarrier :: op (a , b) . frac . dup_map ()",
        "b . frac . owning_map () <= MapCarrier :: op (a , b) . frac . owning_map ()",
        "b . frac . dup_map () <= MapCarrier :: op (a , b) . frac . dup_map ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/tokens/lemma_submap_of_op_frac().",
      "source": "vstd"
    },
    {
      "name": "lemma_submap_of_op",
      "file_path": "tokens/map.rs",
      "line_number": 276,
      "documentation": "",
      "signature": "fn lemma_submap_of_op<K, V>(a: MapCarrier<K, V>, b: MapCarrier<K, V>)",
      "requires_clauses": [
        "# [trigger] MapCarrier :: op (a , b) . valid ()"
      ],
      "ensures_clauses": [
        "a . frac . owning_map () <= MapCarrier :: op (a , b) . frac . owning_map ()",
        "a . frac . dup_map () <= MapCarrier :: op (a , b) . frac . dup_map ()",
        "a . auth . map () <= MapCarrier :: op (a , b) . auth . map ()",
        "b . frac . owning_map () <= MapCarrier :: op (a , b) . frac . owning_map ()",
        "b . frac . dup_map () <= MapCarrier :: op (a , b) . frac . dup_map ()",
        "b . auth . map () <= MapCarrier :: op (a , b) . auth . map ()",
        "a . valid ()",
        "b . valid ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/tokens/lemma_submap_of_op().",
      "source": "vstd"
    },
    {
      "name": "axiom_hash_map_with_view_spec_len",
      "file_path": "hash_map.rs",
      "line_number": 170,
      "documentation": "",
      "signature": "pub fn axiom_hash_map_with_view_spec_len<Key, Value>(m: &HashMapWithView<Key, Value>)\nwhere\n    Key: View + Eq + Hash,",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . spec_len () == m @ . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 hash_map/axiom_hash_map_with_view_spec_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_string_hash_map_spec_len",
      "file_path": "hash_map.rs",
      "line_number": 323,
      "documentation": "",
      "signature": "pub fn axiom_string_hash_map_spec_len<Value>(m: &StringHashMap<Value>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . spec_len () == m @ . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 hash_map/axiom_string_hash_map_spec_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_empty",
      "file_path": "multiset.rs",
      "line_number": 185,
      "documentation": "The empty multiset maps every element to multiplicity 0",
      "signature": "pub fn axiom_multiset_empty<V>(v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Multiset :: empty () . count (v) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_empty().",
      "source": "vstd"
    },
    {
      "name": "lemma_multiset_empty_len",
      "file_path": "multiset.rs",
      "line_number": 194,
      "documentation": "A multiset is equivalent to the empty multiset if and only if it has length 0.\nIf the multiset has length greater than 0, then there exists some element in the\nmultiset that has a count greater than 0.",
      "signature": "pub fn lemma_multiset_empty_len<V>(m: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . len () == 0 <==> m =~= Multiset :: empty ()",
        "# [trigger] m . len () > 0 ==> exists | v : V | 0 < m . count (v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_multiset_empty_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_contained",
      "file_path": "multiset.rs",
      "line_number": 207,
      "documentation": "A call to Multiset::new with input map `m` will return a multiset that maps\nvalue `v` to multiplicity `m[v]` if `v` is in the domain of `m`.",
      "signature": "pub fn axiom_multiset_contained<V>(m: Map<V, nat>, v: V)",
      "requires_clauses": [
        "m . dom () . finite ()",
        "m . dom () . contains (v)"
      ],
      "ensures_clauses": [
        "# [trigger] Multiset :: from_map (m) . count (v) == m [v]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_contained().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_new_not_contained",
      "file_path": "multiset.rs",
      "line_number": 217,
      "documentation": "A call to Multiset::new with input map `m` will return a multiset that maps\nvalue `v` to multiplicity 0 if `v` is not in the domain of `m`.",
      "signature": "pub fn axiom_multiset_new_not_contained<V>(m: Map<V, nat>, v: V)",
      "requires_clauses": [
        "m . dom () . finite ()",
        "! m . dom () . contains (v)"
      ],
      "ensures_clauses": [
        "# [trigger] Multiset :: from_map (m) . count (v) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_new_not_contained().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_singleton",
      "file_path": "multiset.rs",
      "line_number": 228,
      "documentation": "A call to Multiset::singleton with input value `v` will return a multiset that maps\nvalue `v` to multiplicity 1.",
      "signature": "pub fn axiom_multiset_singleton<V>(v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] Multiset :: singleton (v)) . count (v) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_singleton().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_singleton_different",
      "file_path": "multiset.rs",
      "line_number": 235,
      "documentation": "A call to Multiset::singleton with input value `v` will return a multiset that maps\nany value other than `v` to 0",
      "signature": "pub fn axiom_multiset_singleton_different<V>(v: V, w: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "v != w ==> # [trigger] Multiset :: singleton (v) . count (w) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_singleton_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_add",
      "file_path": "multiset.rs",
      "line_number": 243,
      "documentation": "The count of value `v` in the multiset `m1.add(m2)` is equal to the sum of the\ncounts of `v` in `m1` and `m2` individually.",
      "signature": "pub fn axiom_multiset_add<V>(m1: Multiset<V>, m2: Multiset<V>, v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m1 . add (m2) . count (v) == m1 . count (v) + m2 . count (v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_add().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_sub",
      "file_path": "multiset.rs",
      "line_number": 252,
      "documentation": "The count of value `v` in the multiset `m1.sub(m2)` is equal to the difference between the\ncount of `v` in `m1` and `m2` individually. However, the difference is cut off at 0 and\ncannot be negative.",
      "signature": "pub fn axiom_multiset_sub<V>(m1: Multiset<V>, m2: Multiset<V>, v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m1 . sub (m2) . count (v) == if m1 . count (v) >= m2 . count (v) { m1 . count (v) - m2 . count (v) } else { 0 }"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_sub().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_ext_equal",
      "file_path": "multiset.rs",
      "line_number": 263,
      "documentation": "Two multisets are equivalent if and only if they have the same count for every value.",
      "signature": "pub fn axiom_multiset_ext_equal<V>(m1: Multiset<V>, m2: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (m1 =~= m2) <==> (forall | v : V | m1 . count (v) == m2 . count (v))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_ext_equal().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_ext_equal_deep",
      "file_path": "multiset.rs",
      "line_number": 268,
      "documentation": "",
      "signature": "pub fn axiom_multiset_ext_equal_deep<V>(m1: Multiset<V>, m2: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (m1 =~~= m2) <==> m1 =~= m2"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_ext_equal_deep().",
      "source": "vstd"
    },
    {
      "name": "axiom_len_empty",
      "file_path": "multiset.rs",
      "line_number": 275,
      "documentation": "The length of the empty multiset is 0.",
      "signature": "pub fn axiom_len_empty<V>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] Multiset :: < V > :: empty () . len ()) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_len_empty().",
      "source": "vstd"
    },
    {
      "name": "axiom_len_singleton",
      "file_path": "multiset.rs",
      "line_number": 281,
      "documentation": "The length of a singleton multiset is 1.",
      "signature": "pub fn axiom_len_singleton<V>(v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] Multiset :: < V > :: singleton (v) . len ()) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_len_singleton().",
      "source": "vstd"
    },
    {
      "name": "axiom_len_add",
      "file_path": "multiset.rs",
      "line_number": 287,
      "documentation": "The length of the addition of two multisets is equal to the sum of the lengths of each individual multiset.",
      "signature": "pub fn axiom_len_add<V>(m1: Multiset<V>, m2: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] m1 . add (m2) . len ()) == m1 . len () + m2 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_len_add().",
      "source": "vstd"
    },
    {
      "name": "axiom_len_sub",
      "file_path": "multiset.rs",
      "line_number": 294,
      "documentation": "The length of the subtraction of two multisets is equal to the difference between the lengths of each individual multiset.",
      "signature": "pub fn axiom_len_sub<V>(m1: Multiset<V>, m2: Multiset<V>)",
      "requires_clauses": [
        "m2 . subset_of (m1)"
      ],
      "ensures_clauses": [
        "(# [trigger] m1 . sub (m2) . len ()) == m1 . len () - m2 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_len_sub().",
      "source": "vstd"
    },
    {
      "name": "axiom_count_le_len",
      "file_path": "multiset.rs",
      "line_number": 302,
      "documentation": "The count for any given value `v` in a multiset `m` must be less than or equal to the length of `m`.",
      "signature": "pub fn axiom_count_le_len<V>(m: Multiset<V>, v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . count (v) <= # [trigger] m . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_count_le_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_filter_count",
      "file_path": "multiset.rs",
      "line_number": 310,
      "documentation": "For a given value `v` and boolean predicate `f`, if `f(v)` is true, then the count of `v` in\n`m.filter(f)` is the same as the count of `v` in `m`. Otherwise, the count of `v` in `m.filter(f)` is 0.",
      "signature": "pub fn axiom_filter_count<V>(m: Multiset<V>, f: spec_fn(V) -> bool, v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] m . filter (f) . count (v)) == if f (v) { m . count (v) } else { 0 }"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_filter_count().",
      "source": "vstd"
    },
    {
      "name": "axiom_choose_count",
      "file_path": "multiset.rs",
      "line_number": 322,
      "documentation": "In a nonempty multiset `m`, the `choose` function will return a value that maps to a multiplicity\ngreater than 0 in `m`.",
      "signature": "pub fn axiom_choose_count<V>(m: Multiset<V>)",
      "requires_clauses": [
        "# [trigger] m . len () != 0"
      ],
      "ensures_clauses": [
        "# [trigger] m . count (m . choose ()) > 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_choose_count().",
      "source": "vstd"
    },
    {
      "name": "axiom_multiset_always_finite",
      "file_path": "multiset.rs",
      "line_number": 333,
      "documentation": "The domain of a multiset (the set of all values that map to a multiplicity greater than 0) is always finite.",
      "signature": "pub fn axiom_multiset_always_finite<V>(m: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . dom () . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/axiom_multiset_always_finite().",
      "source": "vstd"
    },
    {
      "name": "lemma_update_same",
      "file_path": "multiset.rs",
      "line_number": 361,
      "documentation": "The multiset resulting from updating a value `v` in a multiset `m` to multiplicity `mult` will\nhave a count of `mult` for `v`.",
      "signature": "pub fn lemma_update_same<V>(m: Multiset<V>, v: V, mult: nat)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . update (v , mult) . count (v) == mult"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_update_same().",
      "source": "vstd"
    },
    {
      "name": "lemma_update_different",
      "file_path": "multiset.rs",
      "line_number": 381,
      "documentation": "The multiset resulting from updating a value `v1` in a multiset `m` to multiplicity `mult` will\nnot change the multiplicities of any other values in `m`.",
      "signature": "pub fn lemma_update_different<V>(m: Multiset<V>, v1: V, mult: nat, v2: V)",
      "requires_clauses": [
        "v1 != v2"
      ],
      "ensures_clauses": [
        "# [trigger] m . update (v1 , mult) . count (v2) == m . count (v2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_update_different().",
      "source": "vstd"
    },
    {
      "name": "lemma_insert_containment",
      "file_path": "multiset.rs",
      "line_number": 406,
      "documentation": "If you insert element x into multiset m, then element y maps\nto a count greater than 0 if and only if x==y or y already\nmapped to a count greater than 0 before the insertion of x.",
      "signature": "pub fn lemma_insert_containment<V>(m: Multiset<V>, x: V, y: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 < # [trigger] m . insert (x) . count (y) <==> x == y || 0 < m . count (y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_insert_containment().",
      "source": "vstd"
    },
    {
      "name": "lemma_insert_increases_count_by_1",
      "file_path": "multiset.rs",
      "line_number": 416,
      "documentation": "Inserting an element `x` into multiset `m` will increase the count of `x` in `m` by 1.",
      "signature": "pub fn lemma_insert_increases_count_by_1<V>(m: Multiset<V>, x: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . insert (x) . count (x) == m . count (x) + 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_insert_increases_count_by_1().",
      "source": "vstd"
    },
    {
      "name": "lemma_insert_non_decreasing",
      "file_path": "multiset.rs",
      "line_number": 428,
      "documentation": "If multiset `m` maps element `y` to a multiplicity greater than 0, then inserting any element `x`\ninto `m` will not cause `y` to map to a multiplicity of 0. This is a way of saying that inserting `x`\nwill not cause any counts to decrease, because it accounts both for when x == y and when x != y.",
      "signature": "pub fn lemma_insert_non_decreasing<V>(m: Multiset<V>, x: V, y: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 < m . count (y) ==> 0 < # [trigger] m . insert (x) . count (y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_insert_non_decreasing().",
      "source": "vstd"
    },
    {
      "name": "lemma_insert_other_elements_unchanged",
      "file_path": "multiset.rs",
      "line_number": 438,
      "documentation": "Inserting an element `x` into a multiset `m` will not change the count of any other element `y` in `m`.",
      "signature": "pub fn lemma_insert_other_elements_unchanged<V>(m: Multiset<V>, x: V, y: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "x != y ==> m . count (y) == # [trigger] m . insert (x) . count (y)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_insert_other_elements_unchanged().",
      "source": "vstd"
    },
    {
      "name": "lemma_insert_len",
      "file_path": "multiset.rs",
      "line_number": 448,
      "documentation": "Inserting an element `x` into a multiset `m` will increase the length of `m` by 1.",
      "signature": "pub fn lemma_insert_len<V>(m: Multiset<V>, x: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . insert (x) . len () == m . len () + 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_insert_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_intersection_count",
      "file_path": "multiset.rs",
      "line_number": 460,
      "documentation": "The multiplicity of an element `x` in the intersection of multisets `a` and `b` will be the minimum\ncount of `x` in either `a` or `b`.",
      "signature": "pub fn lemma_intersection_count<V>(a: Multiset<V>, b: Multiset<V>, x: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] a . intersection_with (b) . count (x) == min (a . count (x) as int , b . count (x) as int)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_intersection_count().",
      "source": "vstd"
    },
    {
      "name": "lemma_left_pseudo_idempotence",
      "file_path": "multiset.rs",
      "line_number": 476,
      "documentation": "Taking the intersection of multisets `a` and `b` and then taking the resulting multiset's intersection\nwith `b` again is the same as just taking the intersection of `a` and `b` once.",
      "signature": "pub fn lemma_left_pseudo_idempotence<V>(a: Multiset<V>, b: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] a . intersection_with (b) . intersection_with (b) =~= a . intersection_with (b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_left_pseudo_idempotence().",
      "source": "vstd"
    },
    {
      "name": "lemma_right_pseudo_idempotence",
      "file_path": "multiset.rs",
      "line_number": 502,
      "documentation": "Taking the intersection of multiset `a` with the result of taking the intersection of `a` and `b`\nis the same as just taking the intersection of `a` and `b` once.",
      "signature": "pub fn lemma_right_pseudo_idempotence<V>(a: Multiset<V>, b: Multiset<V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] a . intersection_with (a . intersection_with (b)) =~= a . intersection_with (b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_right_pseudo_idempotence().",
      "source": "vstd"
    },
    {
      "name": "lemma_difference_count",
      "file_path": "multiset.rs",
      "line_number": 529,
      "documentation": "The multiplicity of an element `x` in the difference of multisets `a` and `b` will be\nequal to the difference of the counts of `x` in `a` and `b`, or 0 if this difference is negative.",
      "signature": "pub fn lemma_difference_count<V>(a: Multiset<V>, b: Multiset<V>, x: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] a . difference_with (b) . count (x) == clip (a . count (x) - b . count (x))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_difference_count().",
      "source": "vstd"
    },
    {
      "name": "lemma_difference_bottoms_out",
      "file_path": "multiset.rs",
      "line_number": 542,
      "documentation": "If the multiplicity of element `x` is less in multiset `a` than in multiset `b`, then the multiplicity\nof `x` in the difference of `a` and `b` will be 0.",
      "signature": "pub fn lemma_difference_bottoms_out<V>(a: Multiset<V>, b: Multiset<V>, x: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "a . count (x) <= b . count (x) ==> a . difference_with (b) . count (x) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_difference_bottoms_out().",
      "source": "vstd"
    },
    {
      "name": "lemma_multiset_properties",
      "file_path": "multiset.rs",
      "line_number": 593,
      "documentation": "Properties of multisets from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
      "signature": "pub fn lemma_multiset_properties<V>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | m : Multiset < V > , v : V , mult : nat | # [trigger] m . update (v , mult) . count (v) == mult",
        "forall | m : Multiset < V > , v1 : V , mult : nat , v2 : V | v1 != v2 ==> # [trigger] m . update (v1 , mult) . count (v2) == m . count (v2)",
        "forall | m : Multiset < V > | (# [trigger] m . len () == 0 <==> m =~= Multiset :: empty ()) && (# [trigger] m . len () > 0 ==> exists | v : V | 0 < m . count (v))",
        "forall | m : Multiset < V > , x : V , y : V | 0 < # [trigger] m . insert (x) . count (y) <==> x == y || 0 < m . count (y)",
        "forall | m : Multiset < V > , x : V | # [trigger] m . insert (x) . count (x) == m . count (x) + 1",
        "forall | m : Multiset < V > , x : V , y : V | 0 < m . count (y) ==> 0 < # [trigger] m . insert (x) . count (y)",
        "forall | m : Multiset < V > , x : V , y : V | x != y ==> # [trigger] m . count (y) == # [trigger] m . insert (x) . count (y)",
        "forall | m : Multiset < V > , x : V | # [trigger] m . insert (x) . len () == m . len () + 1",
        "forall | a : Multiset < V > , b : Multiset < V > , x : V | # [trigger] a . intersection_with (b) . count (x) == min (a . count (x) as int , b . count (x) as int)",
        "forall | a : Multiset < V > , b : Multiset < V > | # [trigger] a . intersection_with (b) . intersection_with (b) == a . intersection_with (b)",
        "forall | a : Multiset < V > , b : Multiset < V > | # [trigger] a . intersection_with (a . intersection_with (b)) == a . intersection_with (b)",
        "forall | a : Multiset < V > , b : Multiset < V > , x : V | # [trigger] a . difference_with (b) . count (x) == clip (a . count (x) - b . count (x))",
        "forall | a : Multiset < V > , b : Multiset < V > , x : V | # [trigger] a . count (x) <= # [trigger] b . count (x) ==> (# [trigger] a . difference_with (b)) . count (x) == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 multiset/lemma_multiset_properties().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_empty",
      "file_path": "set.rs",
      "line_number": 633,
      "documentation": "The empty set contains no elements",
      "signature": "pub fn axiom_set_empty<A>(a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "! (# [trigger] Set :: empty () . contains (a))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_empty().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_new",
      "file_path": "set.rs",
      "line_number": 640,
      "documentation": "A call to `Set::new` with the predicate `f` contains `a` if and only if `f(a)` is true.",
      "signature": "pub fn axiom_set_new<A>(f: spec_fn(A) -> bool, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Set :: new (f) . contains (a) == f (a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_new().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_insert_same",
      "file_path": "set.rs",
      "line_number": 647,
      "documentation": "The result of inserting element `a` into set `s` must contains `a`.",
      "signature": "pub fn axiom_set_insert_same<A>(s: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . insert (a) . contains (a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_insert_same().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_insert_different",
      "file_path": "set.rs",
      "line_number": 655,
      "documentation": "If `a1` does not equal `a2`, then the result of inserting element `a2` into set `s`\nmust contain `a1` if and only if the set contained `a1` before the insertion of `a2`.",
      "signature": "pub fn axiom_set_insert_different<A>(s: Set<A>, a1: A, a2: A)",
      "requires_clauses": [
        "a1 != a2"
      ],
      "ensures_clauses": [
        "# [trigger] s . insert (a2) . contains (a1) == s . contains (a1)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_insert_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_remove_same",
      "file_path": "set.rs",
      "line_number": 664,
      "documentation": "The result of removing element `a` from set `s` must not contain `a`.",
      "signature": "pub fn axiom_set_remove_same<A>(s: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "! (# [trigger] s . remove (a) . contains (a))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_remove_same().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_remove_insert",
      "file_path": "set.rs",
      "line_number": 672,
      "documentation": "Removing an element `a` from a set `s` and then inserting `a` back into the set`\nis equivalent to the original set `s`.",
      "signature": "pub fn axiom_set_remove_insert<A>(s: Set<A>, a: A)",
      "requires_clauses": [
        "s . contains (a)"
      ],
      "ensures_clauses": [
        "(# [trigger] s . remove (a)) . insert (a) == s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_remove_insert().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_remove_different",
      "file_path": "set.rs",
      "line_number": 702,
      "documentation": "If `a1` does not equal `a2`, then the result of removing element `a2` from set `s`\nmust contain `a1` if and only if the set contained `a1` before the removal of `a2`.",
      "signature": "pub fn axiom_set_remove_different<A>(s: Set<A>, a1: A, a2: A)",
      "requires_clauses": [
        "a1 != a2"
      ],
      "ensures_clauses": [
        "# [trigger] s . remove (a2) . contains (a1) == s . contains (a1)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_remove_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_union",
      "file_path": "set.rs",
      "line_number": 712,
      "documentation": "The union of sets `s1` and `s2` contains element `a` if and only if\n`s1` contains `a` and/or `s2` contains `a`.",
      "signature": "pub fn axiom_set_union<A>(s1: Set<A>, s2: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s1 . union (s2) . contains (a) == (s1 . contains (a) || s2 . contains (a))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_union().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_intersect",
      "file_path": "set.rs",
      "line_number": 720,
      "documentation": "The intersection of sets `s1` and `s2` contains element `a` if and only if\nboth `s1` and `s2` contain `a`.",
      "signature": "pub fn axiom_set_intersect<A>(s1: Set<A>, s2: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s1 . intersect (s2) . contains (a) == (s1 . contains (a) && s2 . contains (a))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_intersect().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_difference",
      "file_path": "set.rs",
      "line_number": 728,
      "documentation": "The set difference between `s1` and `s2` contains element `a` if and only if\n`s1` contains `a` and `s2` does not contain `a`.",
      "signature": "pub fn axiom_set_difference<A>(s1: Set<A>, s2: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s1 . difference (s2) . contains (a) == (s1 . contains (a) && ! s2 . contains (a))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_difference().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_complement",
      "file_path": "set.rs",
      "line_number": 735,
      "documentation": "The complement of set `s` contains element `a` if and only if `s` does not contain `a`.",
      "signature": "pub fn axiom_set_complement<A>(s: Set<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . complement () . contains (a) == ! s . contains (a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_complement().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_ext_equal",
      "file_path": "set.rs",
      "line_number": 742,
      "documentation": "Sets `s1` and `s2` are equal if and only if they contain all of the same elements.",
      "signature": "pub fn axiom_set_ext_equal<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (s1 =~= s2) <==> (forall | a : A | s1 . contains (a) == s2 . contains (a))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_ext_equal().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_ext_equal_deep",
      "file_path": "set.rs",
      "line_number": 760,
      "documentation": "",
      "signature": "pub fn axiom_set_ext_equal_deep<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (s1 =~~= s2) <==> s1 =~= s2"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_ext_equal_deep().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_empty_finite",
      "file_path": "set.rs",
      "line_number": 780,
      "documentation": "The empty set is finite.",
      "signature": "pub fn axiom_set_empty_finite<A>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Set :: < A > :: empty () . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_empty_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_insert_finite",
      "file_path": "set.rs",
      "line_number": 790,
      "documentation": "The result of inserting an element `a` into a finite set `s` is also finite.",
      "signature": "pub fn axiom_set_insert_finite<A>(s: Set<A>, a: A)",
      "requires_clauses": [
        "s . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . insert (a) . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_insert_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_remove_finite",
      "file_path": "set.rs",
      "line_number": 827,
      "documentation": "The result of removing an element `a` from a finite set `s` is also finite.",
      "signature": "pub fn axiom_set_remove_finite<A>(s: Set<A>, a: A)",
      "requires_clauses": [
        "s . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . remove (a) . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_remove_finite().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_empty_intro",
      "file_path": "set.rs",
      "line_number": 298,
      "documentation": "",
      "signature": "fn lemma_fold_graph_empty_intro<A, B>(z: B, f: spec_fn(B, A) -> B)",
      "requires_clauses": [],
      "ensures_clauses": [
        "fold_graph (z , f , Set :: empty () , z , 0)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_empty_intro().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_insert_intro",
      "file_path": "set.rs",
      "line_number": 305,
      "documentation": "",
      "signature": "fn lemma_fold_graph_insert_intro<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y: B, d: nat, a: A)",
      "requires_clauses": [
        "fold_graph (z , f , s , y , d)",
        "! s . contains (a)"
      ],
      "ensures_clauses": [
        "fold_graph (z , f , s . insert (a) , f (y , a) , d + 1)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_insert_intro().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_empty_elim",
      "file_path": "set.rs",
      "line_number": 327,
      "documentation": "",
      "signature": "fn lemma_fold_graph_empty_elim<A, B>(z: B, f: spec_fn(B, A) -> B, y: B, d: nat)",
      "requires_clauses": [
        "fold_graph (z , f , Set :: empty () , y , d)"
      ],
      "ensures_clauses": [
        "z == y",
        "d == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_empty_elim().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_insert_elim",
      "file_path": "set.rs",
      "line_number": 337,
      "documentation": "",
      "signature": "fn lemma_fold_graph_insert_elim<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y: B, d: nat, a: A)",
      "requires_clauses": [
        "is_fun_commutative (f)",
        "fold_graph (z , f , s . insert (a) , y , d)",
        "! s . contains (a)"
      ],
      "ensures_clauses": [
        "d > 0",
        "exists | yp | y == f (yp , a) && # [trigger] fold_graph (z , f , s , yp , sub (d , 1))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_insert_elim().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_insert_elim_aux",
      "file_path": "set.rs",
      "line_number": 359,
      "documentation": "",
      "signature": "fn lemma_fold_graph_insert_elim_aux<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y: B, d: nat, a: A)",
      "requires_clauses": [
        "is_fun_commutative (f)",
        "fold_graph (z , f , s , y , d)",
        "s . contains (a)"
      ],
      "ensures_clauses": [
        "exists | yp | y == f (yp , a) && # [trigger] fold_graph (z , f , s . remove (a) , yp , sub (d , 1))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_insert_elim_aux().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_induct",
      "file_path": "set.rs",
      "line_number": 412,
      "documentation": "",
      "signature": "fn lemma_fold_graph_induct<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y: B, d: nat, pred: spec_fn(Set<A>, B, nat) -> bool)",
      "requires_clauses": [
        "is_fun_commutative (f)",
        "fold_graph (z , f , s , y , d)",
        "pred (Set :: empty () , z , 0)",
        "forall | a , s , y , d | pred (s , y , d) && ! s . contains (a) && # [trigger] fold_graph (z , f , s , y , d) ==> pred (# [trigger] s . insert (a) , f (y , a) , d + 1 ,)"
      ],
      "ensures_clauses": [
        "pred (s , y , d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_induct().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_finite",
      "file_path": "set.rs",
      "line_number": 464,
      "documentation": "",
      "signature": "fn lemma_fold_graph_finite<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y: B, d: nat)",
      "requires_clauses": [
        "is_fun_commutative (f)",
        "fold_graph (z , f , s , y , d)"
      ],
      "ensures_clauses": [
        "s . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_finite().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_deterministic",
      "file_path": "set.rs",
      "line_number": 477,
      "documentation": "",
      "signature": "fn lemma_fold_graph_deterministic<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y1: B, y2: B, d1: nat, d2: nat)",
      "requires_clauses": [
        "is_fun_commutative (f)",
        "fold_graph (z , f , s , y1 , d1)",
        "fold_graph (z , f , s , y2 , d2)"
      ],
      "ensures_clauses": [
        "y1 == y2",
        "d1 == d2"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_deterministic().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_is_fold_graph",
      "file_path": "set.rs",
      "line_number": 520,
      "documentation": "",
      "signature": "fn lemma_fold_is_fold_graph<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>, y: B, d: nat)",
      "requires_clauses": [
        "is_fun_commutative (f)",
        "fold_graph (z , f , s , y , d)"
      ],
      "ensures_clauses": [
        "s . fold (z , f) == y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_is_fold_graph().",
      "source": "vstd"
    },
    {
      "name": "lemma_finite_set_induct",
      "file_path": "set.rs",
      "line_number": 539,
      "documentation": "",
      "signature": "pub fn lemma_finite_set_induct<A>(s: Set<A>, pred: spec_fn(Set<A>) -> bool)",
      "requires_clauses": [
        "s . finite ()",
        "pred (Set :: empty ())",
        "forall | s , a | pred (s) && s . finite () && ! s . contains (a) ==> # [trigger] pred (s . insert (a))"
      ],
      "ensures_clauses": [
        "pred (s)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_finite_set_induct().",
      "source": "vstd"
    },
    {
      "name": "lemma_finite_set_induct_aux",
      "file_path": "set.rs",
      "line_number": 552,
      "documentation": "",
      "signature": "fn lemma_finite_set_induct_aux<A>(s: Set<A>, f: spec_fn(A) -> nat, ub: nat, pred: spec_fn(Set<A>) -> bool)",
      "requires_clauses": [
        "surj_on (f , s)",
        "s . finite ()",
        "forall | a | s . contains (a) ==> f (a) < ub",
        "pred (Set :: empty ())",
        "forall | s , a | pred (s) && s . finite () && ! s . contains (a) ==> # [trigger] pred (s . insert (a))"
      ],
      "ensures_clauses": [
        "pred (s)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_finite_set_induct_aux().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_graph_exists",
      "file_path": "set.rs",
      "line_number": 584,
      "documentation": "",
      "signature": "fn lemma_fold_graph_exists<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>)",
      "requires_clauses": [
        "s . finite ()",
        "is_fun_commutative (f)"
      ],
      "ensures_clauses": [
        "exists | y , d | fold_graph (z , f , s , y , d)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_graph_exists().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_insert",
      "file_path": "set.rs",
      "line_number": 606,
      "documentation": "",
      "signature": "pub fn lemma_fold_insert<A, B>(s: Set<A>, z: B, f: spec_fn(B, A) -> B, a: A)",
      "requires_clauses": [
        "s . finite ()",
        "! s . contains (a)",
        "is_fun_commutative (f)"
      ],
      "ensures_clauses": [
        "# [trigger] s . insert (a) . fold (z , f) == f (s . fold (z , f) , a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_insert().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_empty",
      "file_path": "set.rs",
      "line_number": 620,
      "documentation": "",
      "signature": "pub fn lemma_fold_empty<A, B>(z: B, f: spec_fn(B, A) -> B)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Set :: empty () . fold (z , f) == z"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 fold/set/lemma_fold_empty().",
      "source": "vstd"
    },
    {
      "name": "axiom_mk_map_domain",
      "file_path": "set.rs",
      "line_number": 766,
      "documentation": "",
      "signature": "pub fn axiom_mk_map_domain<K, V>(s: Set<K>, f: spec_fn(K) -> V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . mk_map (f) . dom () == s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_mk_map_domain().",
      "source": "vstd"
    },
    {
      "name": "axiom_mk_map_index",
      "file_path": "set.rs",
      "line_number": 771,
      "documentation": "",
      "signature": "pub fn axiom_mk_map_index<K, V>(s: Set<K>, f: spec_fn(K) -> V, key: K)",
      "requires_clauses": [
        "s . contains (key)"
      ],
      "ensures_clauses": [
        "# [trigger] s . mk_map (f) [key] == f (key)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_mk_map_index().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_union_finite",
      "file_path": "set.rs",
      "line_number": 855,
      "documentation": "The union of two finite sets is finite.",
      "signature": "pub fn axiom_set_union_finite<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite ()",
        "s2 . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s1 . union (s2) . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_union_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_intersect_finite",
      "file_path": "set.rs",
      "line_number": 880,
      "documentation": "The intersection of two finite sets is finite.",
      "signature": "pub fn axiom_set_intersect_finite<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite () || s2 . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s1 . intersect (s2) . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_intersect_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_difference_finite",
      "file_path": "set.rs",
      "line_number": 892,
      "documentation": "The set difference between two finite sets is finite.",
      "signature": "pub fn axiom_set_difference_finite<A>(s1: Set<A>, s2: Set<A>)",
      "requires_clauses": [
        "s1 . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s1 . difference (s2) . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_difference_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_choose_infinite",
      "file_path": "set.rs",
      "line_number": 904,
      "documentation": "An infinite set `s` contains the element `s.choose()`.",
      "signature": "pub fn axiom_set_choose_infinite<A>(s: Set<A>)",
      "requires_clauses": [
        "! s . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . contains (s . choose ())"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_choose_infinite().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_empty_len",
      "file_path": "set.rs",
      "line_number": 919,
      "documentation": "The empty set has length 0.",
      "signature": "pub fn axiom_set_empty_len<A>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Set :: < A > :: empty () . len () == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_empty_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_insert_len",
      "file_path": "set.rs",
      "line_number": 928,
      "documentation": "The result of inserting an element `a` into a finite set `s` has length\n`s.len() + 1` if `a` is not already in `s` and length `s.len()` otherwise.",
      "signature": "pub fn axiom_set_insert_len<A>(s: Set<A>, a: A)",
      "requires_clauses": [
        "s . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . insert (a) . len () == s . len () + (if s . contains (a) { 0int } else { 1 })"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_insert_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_contains_len",
      "file_path": "set.rs",
      "line_number": 967,
      "documentation": "If a finite set `s` contains any element, it has length greater than 0.",
      "signature": "pub fn axiom_set_contains_len<A>(s: Set<A>, a: A)",
      "requires_clauses": [
        "s . finite ()",
        "# [trigger] s . contains (a)"
      ],
      "ensures_clauses": [
        "# [trigger] s . len () != 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_contains_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_set_choose_len",
      "file_path": "set.rs",
      "line_number": 982,
      "documentation": "A finite set `s` contains the element `s.choose()` if it has length greater than 0.",
      "signature": "pub fn axiom_set_choose_len<A>(s: Set<A>)",
      "requires_clauses": [
        "s . finite ()",
        "# [trigger] s . len () != 0"
      ],
      "ensures_clauses": [
        "# [trigger] s . contains (s . choose ())"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 set/axiom_set_choose_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_ptr_mut_from_data",
      "file_path": "raw_ptr.rs",
      "line_number": 316,
      "documentation": "The view of a pointer constructed from `data: PtrData` should be exactly that data.",
      "signature": "pub fn axiom_ptr_mut_from_data<T>(data: PtrData<T>)\nwhere\n    T: ?Sized,",
      "requires_clauses": [],
      "ensures_clauses": [
        "(# [trigger] ptr_mut_from_data :: < T > (data)) @ == data"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 raw_ptr/axiom_ptr_mut_from_data().",
      "source": "vstd"
    },
    {
      "name": "spec_cast_ptr_to_thin_ptr",
      "file_path": "raw_ptr.rs",
      "line_number": 397,
      "documentation": "Cast a pointer to a thin pointer. Address and provenance are preserved; metadata is now thin.",
      "signature": "pub fn spec_cast_ptr_to_thin_ptr<T, U>(ptr: *mut T) -> *mut U\nwhere\n    T: ?Sized,\n    U: Sized,",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 raw_ptr/spec_cast_ptr_to_thin_ptr().",
      "source": "vstd"
    },
    {
      "name": "spec_cast_array_ptr_to_slice_ptr",
      "file_path": "raw_ptr.rs",
      "line_number": 418,
      "documentation": "Cast a pointer to an array of length `N` to a slice pointer.\nAddress and provenance are preserved; metadata has length `N`.",
      "signature": "pub fn spec_cast_array_ptr_to_slice_ptr<T, const N: usize>(ptr: *mut [T; N]) -> *mut [T]",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 raw_ptr/spec_cast_array_ptr_to_slice_ptr().",
      "source": "vstd"
    },
    {
      "name": "spec_cast_ptr_to_usize",
      "file_path": "raw_ptr.rs",
      "line_number": 439,
      "documentation": "Cast a pointer to a `usize` by extracting just the address.",
      "signature": "pub fn spec_cast_ptr_to_usize<T>(ptr: *mut T) -> usize\nwhere\n    T: Sized,",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 raw_ptr/spec_cast_ptr_to_usize().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_properties",
      "file_path": "map_lib.rs",
      "line_number": null,
      "documentation": "Properties of sequences from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
      "signature": "pub fn lemma_seq_properties<A>()",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_properties().",
      "source": "vstd"
    },
    {
      "name": "lemma_union_insert_left",
      "file_path": "map_lib.rs",
      "line_number": 666,
      "documentation": "",
      "signature": "pub fn lemma_union_insert_left<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K, v: V)",
      "requires_clauses": [
        "! m2 . contains_key (k)"
      ],
      "ensures_clauses": [
        "# [trigger] m1 . insert (k , v) . union_prefer_right (m2) == m1 . union_prefer_right (m2) . insert (k , v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_union_insert_left().",
      "source": "vstd"
    },
    {
      "name": "lemma_union_insert_right",
      "file_path": "map_lib.rs",
      "line_number": 675,
      "documentation": "",
      "signature": "pub fn lemma_union_insert_right<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K, v: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m1 . union_prefer_right (m2 . insert (k , v)) == m1 . union_prefer_right (m2) . insert (k , v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_union_insert_right().",
      "source": "vstd"
    },
    {
      "name": "lemma_union_remove_left",
      "file_path": "map_lib.rs",
      "line_number": 682,
      "documentation": "",
      "signature": "pub fn lemma_union_remove_left<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K)",
      "requires_clauses": [
        "m1 . contains_key (k)",
        "! m2 . contains_key (k)"
      ],
      "ensures_clauses": [
        "# [trigger] m1 . union_prefer_right (m2) . remove (k) == m1 . remove (k) . union_prefer_right (m2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_union_remove_left().",
      "source": "vstd"
    },
    {
      "name": "lemma_union_remove_right",
      "file_path": "map_lib.rs",
      "line_number": 692,
      "documentation": "",
      "signature": "pub fn lemma_union_remove_right<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K)",
      "requires_clauses": [
        "! m1 . contains_key (k)",
        "m2 . contains_key (k)"
      ],
      "ensures_clauses": [
        "# [trigger] m1 . union_prefer_right (m2) . remove (k) == m1 . union_prefer_right (m2 . remove (k))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_union_remove_right().",
      "source": "vstd"
    },
    {
      "name": "lemma_union_dom",
      "file_path": "map_lib.rs",
      "line_number": 702,
      "documentation": "",
      "signature": "pub fn lemma_union_dom<K, V>(m1: Map<K, V>, m2: Map<K, V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m1 . union_prefer_right (m2) . dom () == m1 . dom () . union (m2 . dom ())"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_union_dom().",
      "source": "vstd"
    },
    {
      "name": "lemma_disjoint_union_size",
      "file_path": "map_lib.rs",
      "line_number": 710,
      "documentation": "The size of the union of two disjoint maps is equal to the sum of the sizes of the individual maps",
      "signature": "pub fn lemma_disjoint_union_size<K, V>(m1: Map<K, V>, m2: Map<K, V>)",
      "requires_clauses": [
        "m1 . dom () . disjoint (m2 . dom ())",
        "m1 . dom () . finite ()",
        "m2 . dom () . finite ()"
      ],
      "ensures_clauses": [
        "# [trigger] m1 . union_prefer_right (m2) . dom () . len () == m1 . dom () . len () + m2 . dom () . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_disjoint_union_size().",
      "source": "vstd"
    },
    {
      "name": "lemma_map_new_domain",
      "file_path": "map_lib.rs",
      "line_number": 751,
      "documentation": "The domain of a map constructed with `Map::new(fk, fv)` is equivalent to the set constructed with `Set::new(fk)`.",
      "signature": "pub fn lemma_map_new_domain<K, V>(fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Map :: < K , V > :: new (fk , fv) . dom () == Set :: < K > :: new (| k : K | fk (k))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_map_new_domain().",
      "source": "vstd"
    },
    {
      "name": "lemma_map_new_values",
      "file_path": "map_lib.rs",
      "line_number": 762,
      "documentation": "The set of values of a map constructed with `Map::new(fk, fv)` is equivalent to\nthe set constructed with `Set::new(|v: V| (exists |k: K| fk(k) && fv(k) == v)`. In other words,\nthe set of all values fv(k) where fk(k) is true.",
      "signature": "pub fn lemma_map_new_values<K, V>(fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Map :: < K , V > :: new (fk , fv) . values () == Set :: < V > :: new (| v : V | (exists | k : K | # [trigger] fk (k) && # [trigger] fv (k) == v) ,)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_map_new_values().",
      "source": "vstd"
    },
    {
      "name": "lemma_map_properties",
      "file_path": "map_lib.rs",
      "line_number": 780,
      "documentation": "Properties of maps from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
      "signature": "pub fn lemma_map_properties<K, V>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | fk : spec_fn (K) -> bool , fv : spec_fn (K) -> V | # [trigger] Map :: < K , V > :: new (fk , fv) . dom () == Set :: < K > :: new (| k : K | fk (k))",
        "forall | fk : spec_fn (K) -> bool , fv : spec_fn (K) -> V | # [trigger] Map :: < K , V > :: new (fk , fv) . values () == Set :: < V > :: new (| v : V | exists | k : K | # [trigger] fk (k) && # [trigger] fv (k) == v ,)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_map_properties().",
      "source": "vstd"
    },
    {
      "name": "lemma_values_finite",
      "file_path": "map_lib.rs",
      "line_number": 809,
      "documentation": "",
      "signature": "pub fn lemma_values_finite<K, V>(m: Map<K, V>)",
      "requires_clauses": [
        "m . dom () . finite ()"
      ],
      "ensures_clauses": [
        "m . values () . finite ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map_lib/lemma_values_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_str_literal_is_ascii",
      "file_path": "string.rs",
      "line_number": 193,
      "documentation": "",
      "signature": "pub fn axiom_str_literal_is_ascii<'a>(s: &'a str)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . is_ascii () == strslice_is_ascii (s)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 string/axiom_str_literal_is_ascii().",
      "source": "vstd"
    },
    {
      "name": "axiom_str_literal_len",
      "file_path": "string.rs",
      "line_number": 198,
      "documentation": "",
      "signature": "pub fn axiom_str_literal_len<'a>(s: &'a str)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s @ . len () == strslice_len (s)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 string/axiom_str_literal_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_str_literal_get_char",
      "file_path": "string.rs",
      "line_number": 203,
      "documentation": "",
      "signature": "pub fn axiom_str_literal_get_char<'a>(s: &'a str, i: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s @ . index (i) == strslice_get_char (s , i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 string/axiom_str_literal_get_char().",
      "source": "vstd"
    },
    {
      "name": "lemma_low_bits_mask_unfold",
      "file_path": "bits.rs",
      "line_number": 241,
      "documentation": "Proof relating the n-bit mask to a function of the (n-1)-bit mask.",
      "signature": "pub fn lemma_low_bits_mask_unfold(n: nat)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "# [trigger] low_bits_mask (n) == 2 * low_bits_mask ((n - 1) as nat) + 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bits/lemma_low_bits_mask_unfold().",
      "source": "vstd"
    },
    {
      "name": "lemma_low_bits_mask_is_odd",
      "file_path": "bits.rs",
      "line_number": 262,
      "documentation": "Proof that low_bits_mask(n) is odd.",
      "signature": "pub fn lemma_low_bits_mask_is_odd(n: nat)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (low_bits_mask (n) % 2) == 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bits/lemma_low_bits_mask_is_odd().",
      "source": "vstd"
    },
    {
      "name": "lemma_low_bits_mask_div2",
      "file_path": "bits.rs",
      "line_number": 281,
      "documentation": "Proof that dividing the low n bit mask by 2 gives the low n-1 bit mask.",
      "signature": "pub fn lemma_low_bits_mask_div2(n: nat)",
      "requires_clauses": [
        "n > 0"
      ],
      "ensures_clauses": [
        "# [trigger] (low_bits_mask (n) / 2) == low_bits_mask ((n - 1) as nat)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bits/lemma_low_bits_mask_div2().",
      "source": "vstd"
    },
    {
      "name": "lemma_low_bits_mask_values",
      "file_path": "bits.rs",
      "line_number": 292,
      "documentation": "Proof establishing the concrete values of all masks of bit sizes from 0 to\n32, and 64.",
      "signature": "pub fn lemma_low_bits_mask_values()",
      "requires_clauses": [],
      "ensures_clauses": [
        "low_bits_mask (0) == 0x0",
        "low_bits_mask (1) == 0x1",
        "low_bits_mask (2) == 0x3",
        "low_bits_mask (3) == 0x7",
        "low_bits_mask (4) == 0xf",
        "low_bits_mask (5) == 0x1f",
        "low_bits_mask (6) == 0x3f",
        "low_bits_mask (7) == 0x7f",
        "low_bits_mask (8) == 0xff",
        "low_bits_mask (9) == 0x1ff",
        "low_bits_mask (10) == 0x3ff",
        "low_bits_mask (11) == 0x7ff",
        "low_bits_mask (12) == 0xfff",
        "low_bits_mask (13) == 0x1fff",
        "low_bits_mask (14) == 0x3fff",
        "low_bits_mask (15) == 0x7fff",
        "low_bits_mask (16) == 0xffff",
        "low_bits_mask (17) == 0x1ffff",
        "low_bits_mask (18) == 0x3ffff",
        "low_bits_mask (19) == 0x7ffff",
        "low_bits_mask (20) == 0xfffff",
        "low_bits_mask (21) == 0x1fffff",
        "low_bits_mask (22) == 0x3fffff",
        "low_bits_mask (23) == 0x7fffff",
        "low_bits_mask (24) == 0xffffff",
        "low_bits_mask (25) == 0x1ffffff",
        "low_bits_mask (26) == 0x3ffffff",
        "low_bits_mask (27) == 0x7ffffff",
        "low_bits_mask (28) == 0xfffffff",
        "low_bits_mask (29) == 0x1fffffff",
        "low_bits_mask (30) == 0x3fffffff",
        "low_bits_mask (31) == 0x7fffffff",
        "low_bits_mask (32) == 0xffffffff",
        "low_bits_mask (64) == 0xffffffffffffffff"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 bits/lemma_low_bits_mask_values().",
      "source": "vstd"
    },
    {
      "name": "lemma_new_first_element_still_sorted_by",
      "file_path": "relations.rs",
      "line_number": 125,
      "documentation": "",
      "signature": "pub fn lemma_new_first_element_still_sorted_by<T>(x: T, s: Seq<T>, less_than: spec_fn(T, T) -> bool)",
      "requires_clauses": [
        "sorted_by (s , less_than)",
        "s . len () == 0 || less_than (x , s [0])",
        "total_ordering (less_than)"
      ],
      "ensures_clauses": [
        "sorted_by (seq ! [x] . add (s) , less_than)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 relations/lemma_new_first_element_still_sorted_by().",
      "source": "vstd"
    },
    {
      "name": "spec_affirm",
      "file_path": "pervasive.rs",
      "line_number": 171,
      "documentation": "A tool to check one's reasoning while writing complex spec functions.\nNot intended to be used as a mechanism for instantiating quantifiers, `spec_affirm` should\nbe removed from spec functions once they are complete.\n\n## Example\n\n```rust\n#[spec(checked)] fn some_predicate(a: nat) -> bool {\n    recommends(a < 100);\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 50);\n        // let _ = spec_affirm(a < 40); would raise a recommends note here\n        a < 25\n    }\n}\n```",
      "signature": "pub fn spec_affirm(b: bool) -> bool",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 pervasive/spec_affirm().",
      "source": "vstd"
    },
    {
      "name": "proof_from_false",
      "file_path": "pervasive.rs",
      "line_number": 183,
      "documentation": "",
      "signature": "pub fn proof_from_false<A>() -> A",
      "requires_clauses": [
        "false"
      ],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 pervasive/proof_from_false().",
      "source": "vstd"
    },
    {
      "name": "spec_slice_len",
      "file_path": "slice.rs",
      "line_number": 70,
      "documentation": "",
      "signature": "pub fn spec_slice_len<T>(slice: &[T]) -> usize",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 slice/spec_slice_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_spec_len",
      "file_path": "slice.rs",
      "line_number": 74,
      "documentation": "",
      "signature": "pub fn axiom_spec_len<T>(slice: &[T])",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] spec_slice_len (slice) == slice @ . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 slice/axiom_spec_len().",
      "source": "vstd"
    },
    {
      "name": "spec_slice_get",
      "file_path": "slice.rs",
      "line_number": 118,
      "documentation": "",
      "signature": "pub fn spec_slice_get<T, I>(val: &T, idx: I) -> Option<&<I as core::slice::SliceIndex<T>>::Output>\nwhere\n    T: ?Sized,\n    I: core::slice::SliceIndex<T>,",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 slice/spec_slice_get().",
      "source": "vstd"
    },
    {
      "name": "axiom_slice_get_usize",
      "file_path": "slice.rs",
      "line_number": 123,
      "documentation": "",
      "signature": "pub fn axiom_slice_get_usize<T>(v: &[T], i: usize)",
      "requires_clauses": [],
      "ensures_clauses": [
        "i < v . len () ==> # [trigger] spec_slice_get (v , i) === Some (& v [i as int])",
        "i >= v . len () ==> spec_slice_get (v , i) . is_none ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 slice/axiom_slice_get_usize().",
      "source": "vstd"
    },
    {
      "name": "axiom_slice_ext_equal",
      "file_path": "slice.rs",
      "line_number": 129,
      "documentation": "",
      "signature": "pub fn axiom_slice_ext_equal<T>(a1: &[T], a2: &[T])",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (a1 =~= a2) <==> (a1 . len () == a2 . len () && forall | i : int | 0 <= i < a1 . len () ==> a1 [i] == a2 [i])"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 slice/axiom_slice_ext_equal().",
      "source": "vstd"
    },
    {
      "name": "proof",
      "file_path": "prelude.rs",
      "line_number": null,
      "documentation": "Add a verus proof block.",
      "signature": "pub fn proof(input: proc_macro::TokenStream) -> proc_macro::TokenStream",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo verus_builtin_macros 0.0.0-2025-11-30-0053 proof().",
      "source": "vstd"
    },
    {
      "name": "proof_decl",
      "file_path": "prelude.rs",
      "line_number": null,
      "documentation": "proof_decl add extra stmts that are used only\nfor verification.\nFor example, declare a ghost/tracked variable.\nTo avoid confusion, let stmts without ghost/tracked is not supported.\nNon-local stmts inside proof_decl! are treated similar to those in proof!",
      "signature": "pub fn proof_decl(input: proc_macro::TokenStream) -> proc_macro::TokenStream",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo verus_builtin_macros 0.0.0-2025-11-30-0053 proof_decl().",
      "source": "vstd"
    },
    {
      "name": "proof_with",
      "file_path": "prelude.rs",
      "line_number": null,
      "documentation": "proof_with add ghost input/output to the next function call.\nIn stable rust, we cannot add attribute-based macro to expr/statement.\nUsing proof_with! to tell #[verus_spec] to add ghost input/output.\nUsing proof_with outside of #[verus_spec] does not have any side effects.",
      "signature": "pub fn proof_with(_: proc_macro::TokenStream) -> proc_macro::TokenStream",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo verus_builtin_macros 0.0.0-2025-11-30-0053 proof_with().",
      "source": "vstd"
    },
    {
      "name": "verus_proof_expr",
      "file_path": "prelude.rs",
      "line_number": null,
      "documentation": "",
      "signature": "pub fn verus_proof_expr(input: proc_macro::TokenStream) -> proc_macro::TokenStream",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo verus_builtin_macros 0.0.0-2025-11-30-0053 verus_proof_expr().",
      "source": "vstd"
    },
    {
      "name": "verus_proof_macro_explicit_exprs",
      "file_path": "prelude.rs",
      "line_number": null,
      "documentation": "`verus_proof_macro_explicit_exprs!(f!(tts))` applies verus syntax to transform `tts` into\n`tts'`, then returns `f!(tts')`, only applying the transform to any of the exprs within it that\nare explicitly prefixed with `@@`, leaving the rest as-is. Contrast this to\n[`verus_proof_macro_exprs`] which is likely what you want to try first to see if it satisfies\nyour needs.",
      "signature": "pub fn verus_proof_macro_explicit_exprs(input: proc_macro::TokenStream) -> proc_macro::TokenStream",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo verus_builtin_macros 0.0.0-2025-11-30-0053 verus_proof_macro_explicit_exprs().",
      "source": "vstd"
    },
    {
      "name": "verus_proof_macro_exprs",
      "file_path": "prelude.rs",
      "line_number": null,
      "documentation": "verus_proof_macro_exprs!(f!(exprs)) applies verus syntax to transform exprs into exprs',\nthen returns f!(exprs'),\nwhere exprs is a sequence of expressions separated by \",\", \";\", and/or \"=>\".",
      "signature": "pub fn verus_proof_macro_exprs(input: proc_macro::TokenStream) -> proc_macro::TokenStream",
      "requires_clauses": [],
      "ensures_clauses": [],
      "symbol_id": "rust-analyzer cargo verus_builtin_macros 0.0.0-2025-11-30-0053 verus_proof_macro_exprs().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_index_decreases",
      "file_path": "seq.rs",
      "line_number": 250,
      "documentation": "",
      "signature": "pub fn axiom_seq_index_decreases<A>(s: Seq<A>, i: int)",
      "requires_clauses": [
        "0 <= i < s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] (decreases_to ! (s => s [i]))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_index_decreases().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_len_decreases",
      "file_path": "seq.rs",
      "line_number": 257,
      "documentation": "",
      "signature": "pub fn axiom_seq_len_decreases<A>(s1: Seq<A>, s2: Seq<A>)",
      "requires_clauses": [
        "s2 . len () < s1 . len ()",
        "forall | i2 : int | 0 <= i2 < s2 . len () && # [trigger] trigger (s2 [i2]) ==> exists | i1 : int | 0 <= i1 < s1 . len () && s1 [i1] == s2 [i2]"
      ],
      "ensures_clauses": [
        "decreases_to ! (s1 => s2)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_len_decreases().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_subrange_decreases",
      "file_path": "seq.rs",
      "line_number": 267,
      "documentation": "",
      "signature": "pub fn axiom_seq_subrange_decreases<A>(s: Seq<A>, i: int, j: int)",
      "requires_clauses": [
        "0 <= i <= j <= s . len ()",
        "s . subrange (i , j) . len () < s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] (decreases_to ! (s => s . subrange (i , j)))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_subrange_decreases().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_subrange_len",
      "file_path": "seq.rs",
      "line_number": 359,
      "documentation": "",
      "signature": "pub fn axiom_seq_subrange_len<A>(s: Seq<A>, j: int, k: int)",
      "requires_clauses": [
        "0 <= j <= k <= s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . subrange (j , k) . len () == k - j"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_subrange_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_subrange_index",
      "file_path": "seq.rs",
      "line_number": 366,
      "documentation": "",
      "signature": "pub fn axiom_seq_subrange_index<A>(s: Seq<A>, j: int, k: int, i: int)",
      "requires_clauses": [
        "0 <= j <= k <= s . len ()",
        "0 <= i < k - j"
      ],
      "ensures_clauses": [
        "# [trigger] s . subrange (j , k) [i] == s [i + j]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_subrange_index().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_empty",
      "file_path": "seq.rs",
      "line_number": 284,
      "documentation": "",
      "signature": "pub fn axiom_seq_empty<A>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Seq :: < A > :: empty () . len () == 0"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_empty().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_new_len",
      "file_path": "seq.rs",
      "line_number": 289,
      "documentation": "",
      "signature": "pub fn axiom_seq_new_len<A>(len: nat, f: spec_fn(int) -> A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Seq :: new (len , f) . len () == len"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_new_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_new_index",
      "file_path": "seq.rs",
      "line_number": 294,
      "documentation": "",
      "signature": "pub fn axiom_seq_new_index<A>(len: nat, f: spec_fn(int) -> A, i: int)",
      "requires_clauses": [
        "0 <= i < len"
      ],
      "ensures_clauses": [
        "# [trigger] Seq :: new (len , f) [i] == f (i)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_new_index().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_push_len",
      "file_path": "seq.rs",
      "line_number": 301,
      "documentation": "",
      "signature": "pub fn axiom_seq_push_len<A>(s: Seq<A>, a: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . push (a) . len () == s . len () + 1"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_push_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_push_index_same",
      "file_path": "seq.rs",
      "line_number": 306,
      "documentation": "",
      "signature": "pub fn axiom_seq_push_index_same<A>(s: Seq<A>, a: A, i: int)",
      "requires_clauses": [
        "i == s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . push (a) [i] == a"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_push_index_same().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_push_index_different",
      "file_path": "seq.rs",
      "line_number": 313,
      "documentation": "",
      "signature": "pub fn axiom_seq_push_index_different<A>(s: Seq<A>, a: A, i: int)",
      "requires_clauses": [
        "0 <= i < s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . push (a) [i] == s [i]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_push_index_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_update_len",
      "file_path": "seq.rs",
      "line_number": 320,
      "documentation": "",
      "signature": "pub fn axiom_seq_update_len<A>(s: Seq<A>, i: int, a: A)",
      "requires_clauses": [
        "0 <= i < s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . update (i , a) . len () == s . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_update_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_update_same",
      "file_path": "seq.rs",
      "line_number": 327,
      "documentation": "",
      "signature": "pub fn axiom_seq_update_same<A>(s: Seq<A>, i: int, a: A)",
      "requires_clauses": [
        "0 <= i < s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . update (i , a) [i] == a"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_update_same().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_update_different",
      "file_path": "seq.rs",
      "line_number": 334,
      "documentation": "",
      "signature": "pub fn axiom_seq_update_different<A>(s: Seq<A>, i1: int, i2: int, a: A)",
      "requires_clauses": [
        "0 <= i1 < s . len ()",
        "0 <= i2 < s . len ()",
        "i1 != i2"
      ],
      "ensures_clauses": [
        "# [trigger] s . update (i2 , a) [i1] == s [i1]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_update_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_ext_equal",
      "file_path": "seq.rs",
      "line_number": 343,
      "documentation": "",
      "signature": "pub fn axiom_seq_ext_equal<A>(s1: Seq<A>, s2: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (s1 =~= s2) <==> { &&& s1 . len () == s2 . len () &&& forall | i : int | 0 <= i < s1 . len () ==> s1 [i] == s2 [i] }"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_ext_equal().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_ext_equal_deep",
      "file_path": "seq.rs",
      "line_number": 351,
      "documentation": "",
      "signature": "pub fn axiom_seq_ext_equal_deep<A>(s1: Seq<A>, s2: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (s1 =~~= s2) <==> { &&& s1 . len () == s2 . len () &&& forall | i : int | 0 <= i < s1 . len () ==> s1 [i] =~~= s2 [i] }"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_ext_equal_deep().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_add_len",
      "file_path": "seq.rs",
      "line_number": 374,
      "documentation": "",
      "signature": "pub fn axiom_seq_add_len<A>(s1: Seq<A>, s2: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s1 . add (s2) . len () == s1 . len () + s2 . len ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_add_len().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_add_index1",
      "file_path": "seq.rs",
      "line_number": 379,
      "documentation": "",
      "signature": "pub fn axiom_seq_add_index1<A>(s1: Seq<A>, s2: Seq<A>, i: int)",
      "requires_clauses": [
        "0 <= i < s1 . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s1 . add (s2) [i] == s1 [i]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_add_index1().",
      "source": "vstd"
    },
    {
      "name": "axiom_seq_add_index2",
      "file_path": "seq.rs",
      "line_number": 386,
      "documentation": "",
      "signature": "pub fn axiom_seq_add_index2<A>(s1: Seq<A>, s2: Seq<A>, i: int)",
      "requires_clauses": [
        "s1 . len () <= i < s1 . len () + s2 . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s1 . add (s2) [i] == s2 [i - s1 . len ()]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq/axiom_seq_add_index2().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_index_decreases_finite",
      "file_path": "map.rs",
      "line_number": 183,
      "documentation": "",
      "signature": "pub fn axiom_map_index_decreases_finite<K, V>(m: Map<K, V>, key: K)",
      "requires_clauses": [
        "m . dom () . finite ()",
        "m . dom () . contains (key)"
      ],
      "ensures_clauses": [
        "# [trigger] (decreases_to ! (m => m [key]))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_index_decreases_finite().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_index_decreases_infinite",
      "file_path": "map.rs",
      "line_number": 193,
      "documentation": "",
      "signature": "pub fn axiom_map_index_decreases_infinite<K, V>(m: Map<K, V>, key: K)",
      "requires_clauses": [
        "m . dom () . contains (key)"
      ],
      "ensures_clauses": [
        "# [trigger] is_smaller_than_recursive_function_field (m [key] , m)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_index_decreases_infinite().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_empty",
      "file_path": "map.rs",
      "line_number": 201,
      "documentation": "The domain of the empty map is the empty set",
      "signature": "pub fn axiom_map_empty<K, V>()",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] Map :: < K , V > :: empty () . dom () == Set :: < K > :: empty ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_empty().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_insert_domain",
      "file_path": "map.rs",
      "line_number": 212,
      "documentation": "The domain of a map after inserting a key-value pair is equivalent to inserting the key into\nthe original map's domain set.",
      "signature": "pub fn axiom_map_insert_domain<K, V>(m: Map<K, V>, key: K, value: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . insert (key , value) . dom () == m . dom () . insert (key)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_insert_domain().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_insert_same",
      "file_path": "map.rs",
      "line_number": 222,
      "documentation": "Inserting `value` at `key` in `m` results in a map that maps `key` to `value`",
      "signature": "pub fn axiom_map_insert_same<K, V>(m: Map<K, V>, key: K, value: V)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . insert (key , value) [key] == value"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_insert_same().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_insert_different",
      "file_path": "map.rs",
      "line_number": 229,
      "documentation": "Inserting `value` at `key2` does not change the value mapped to by any other keys in `m`",
      "signature": "pub fn axiom_map_insert_different<K, V>(m: Map<K, V>, key1: K, key2: K, value: V)",
      "requires_clauses": [
        "key1 != key2"
      ],
      "ensures_clauses": [
        "# [trigger] m . insert (key2 , value) [key1] == m [key1]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_insert_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_remove_domain",
      "file_path": "map.rs",
      "line_number": 239,
      "documentation": "The domain of a map after removing a key-value pair is equivalent to removing the key from\nthe original map's domain set.",
      "signature": "pub fn axiom_map_remove_domain<K, V>(m: Map<K, V>, key: K)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] m . remove (key) . dom () == m . dom () . remove (key)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_remove_domain().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_remove_different",
      "file_path": "map.rs",
      "line_number": 250,
      "documentation": "Removing a key-value pair from a map does not change the value mapped to by\nany other keys in the map.",
      "signature": "pub fn axiom_map_remove_different<K, V>(m: Map<K, V>, key1: K, key2: K)",
      "requires_clauses": [
        "key1 != key2"
      ],
      "ensures_clauses": [
        "# [trigger] m . remove (key2) [key1] == m [key1]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_remove_different().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_ext_equal",
      "file_path": "map.rs",
      "line_number": 259,
      "documentation": "Two maps are equivalent if their domains are equivalent and every key in their domains map to the same value.",
      "signature": "pub fn axiom_map_ext_equal<K, V>(m1: Map<K, V>, m2: Map<K, V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (m1 =~= m2) <==> { &&& m1 . dom () =~= m2 . dom () &&& forall | k : K | # ! [auto] m1 . dom () . contains (k) ==> m1 [k] == m2 [k] }"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_ext_equal().",
      "source": "vstd"
    },
    {
      "name": "axiom_map_ext_equal_deep",
      "file_path": "map.rs",
      "line_number": 288,
      "documentation": "",
      "signature": "pub fn axiom_map_ext_equal_deep<K, V>(m1: Map<K, V>, m2: Map<K, V>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (m1 =~~= m2) <==> { &&& m1 . dom () =~~= m2 . dom () &&& forall | k : K | # ! [auto] m1 . dom () . contains (k) ==> m1 [k] =~~= m2 [k] }"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 map/axiom_map_ext_equal_deep().",
      "source": "vstd"
    },
    {
      "name": "lemma_pcm_properties",
      "file_path": "pcm_lib.rs",
      "line_number": 27,
      "documentation": "Provides four quantified facts about a partially commutative\nmonoid: that it's closed under inclusion, that it's commutative,\nthat it's a monoid, and that its unit element is valid. Note that,\nto avoid trigger loops, it doesn't provide associativity.",
      "signature": "pub fn lemma_pcm_properties<P>()\nwhere\n    P: PCM,",
      "requires_clauses": [],
      "ensures_clauses": [
        "forall | a : P , b : P | (# [trigger] P :: op (a , b)) . valid () ==> a . valid ()",
        "forall | a : P , b : P | (# [trigger] P :: op (a , b)) == P :: op (b , a)",
        "forall | a : P | (# [trigger] P :: op (a , P :: unit ())) == a",
        "P :: valid (P :: unit ())"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 pcm_lib/lemma_pcm_properties().",
      "source": "vstd"
    },
    {
      "name": "lemma_merge_sorted_with_ensures",
      "file_path": "seq_lib.rs",
      "line_number": 2678,
      "documentation": "",
      "signature": "fn lemma_merge_sorted_with_ensures<A>(left: Seq<A>, right: Seq<A>, leq: spec_fn(A, A) -> bool)",
      "requires_clauses": [
        "sorted_by (left , leq)",
        "sorted_by (right , leq)",
        "total_ordering (leq)"
      ],
      "ensures_clauses": [
        "(left + right) . to_multiset () =~= merge_sorted_with (left , right , leq) . to_multiset ()",
        "sorted_by (merge_sorted_with (left , right , leq) , leq)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_merge_sorted_with_ensures().",
      "source": "vstd"
    },
    {
      "name": "lemma_multiset_commutative",
      "file_path": "seq_lib.rs",
      "line_number": 3142,
      "documentation": "The multiset of a concatenated sequence `a + b` is equivalent to the multiset of just\nsequence `a` added to the multiset of just sequence `b`.",
      "signature": "pub fn lemma_multiset_commutative<A>(a: Seq<A>, b: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (a + b) . to_multiset () =~= a . to_multiset () . add (b . to_multiset ())"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_multiset_commutative().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_concat_contains_all_elements",
      "file_path": "seq_lib.rs",
      "line_number": 3215,
      "documentation": "The concatenation of two sequences contains only the elements\nof the two sequences",
      "signature": "pub fn lemma_seq_concat_contains_all_elements<A>(x: Seq<A>, y: Seq<A>, elt: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (x + y) . contains (elt) <==> x . contains (elt) || y . contains (elt)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_concat_contains_all_elements().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_empty_contains_nothing",
      "file_path": "seq_lib.rs",
      "line_number": 3197,
      "documentation": "The empty sequence contains nothing",
      "signature": "pub fn lemma_seq_empty_contains_nothing<A>(x: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "! (# [trigger] Seq :: < A > :: empty () . contains (x))"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_empty_contains_nothing().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_contains_after_push",
      "file_path": "seq_lib.rs",
      "line_number": 3240,
      "documentation": "After pushing an element onto a sequence, the sequence contains that element",
      "signature": "pub fn lemma_seq_contains_after_push<A>(s: Seq<A>, v: A, x: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . push (v) . contains (x) <==> v == x || s . contains (x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_contains_after_push().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_of_skip",
      "file_path": "seq_lib.rs",
      "line_number": 3534,
      "documentation": "If `m + n` is less than or equal to the length of sequence `s`, then skipping the first `m` elements\nand then skipping the first `n` elements of the resulting sequence is equivalent to just skipping\nthe first `m + n` elements.",
      "signature": "pub fn lemma_seq_skip_of_skip<A>(s: Seq<A>, m: int, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(0 <= m && 0 <= n && m + n <= s . len ()) ==> # [trigger] s . skip (m) . skip (n) =~= s . skip (m + n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_of_skip().",
      "source": "vstd"
    },
    {
      "name": "lemma_filter_view_commute",
      "file_path": "seq_lib.rs",
      "line_number": 2296,
      "documentation": "Filtering a sequence and then viewing its elements produces the same result as\nviewing the elements first and then filtering with the corresponding predicate.\nThe predicates p and sp must be equivalent under view.\n\n# Example\n```rust\nproof fn example() {\n    let s = seq![\"hello\".to_string(), \"world\".to_string()];\n    let p = |x: String| x.len() > 4;\n    let sp = |x: Seq<char>| x.len() > 4;\n\n    let way1 = s.filter(p).map_values(|x| x.view());\n    let way2 = s.map_values(|x| x.view()).filter(sp);\n    assert(way1 == way2);\n}\n```",
      "signature": "pub fn lemma_filter_view_commute<S>(s: Seq<S>, p: spec_fn(S) -> bool, sp: spec_fn(S::V) -> bool)\nwhere\n    S: View,",
      "requires_clauses": [
        "forall | s : S | p (s) <==> sp (s . view ())"
      ],
      "ensures_clauses": [
        "s . filter (p) . map_values (| x : S | x . view ()) == s . map_values (| x : S | x . view ()) . filter (sp)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_filter_view_commute().",
      "source": "vstd"
    },
    {
      "name": "lemma_exactly_one_view",
      "file_path": "seq_lib.rs",
      "line_number": 2336,
      "documentation": "A sequence has exactly one element satisfying a predicate iff\nviewing all elements and filtering with the corresponding predicate\nproduces a sequence with exactly one element.\n\n# Example\n```rust\nproof fn example() {\n    let s = seq![\"hello\".to_string(), \"world\".to_string()];\n    let p = |x: String| x.len() == 5;\n    let sp = |x: Seq<char>| x.len() == 5;\n\n    assert(s.exactly_one(p) <==> s.map_values(|x| x.view()).exactly_one(sp));\n}\n```",
      "signature": "pub fn lemma_exactly_one_view<S>(s: Seq<S>, p: spec_fn(S) -> bool, sp: spec_fn(S::V) -> bool)\nwhere\n    S: View,",
      "requires_clauses": [
        "forall | s : S | p (s) <==> sp (s . view ())",
        "injective (| x : S | x . view ())"
      ],
      "ensures_clauses": [
        "s . exactly_one (p) <==> s . map_values (| x : S | x . view ()) . exactly_one (sp)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_exactly_one_view().",
      "source": "vstd"
    },
    {
      "name": "lemma_flatten_concat",
      "file_path": "seq_lib.rs",
      "line_number": 3092,
      "documentation": "Flattening sequences of sequences is distributive over concatenation. That is, concatenating\nthe flattening of two sequences of sequences is the same as flattening the\nconcatenation of two sequences of sequences.",
      "signature": "pub fn lemma_flatten_concat<A>(x: Seq<Seq<A>>, y: Seq<Seq<A>>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(x + y) . flatten () =~= x . flatten () + y . flatten ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_flatten_concat().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_union_to_multiset_commutative",
      "file_path": "seq_lib.rs",
      "line_number": 3130,
      "documentation": "The multiset of a concatenated sequence `a + b` is equivalent to the multiset of the\nconcatenated sequence `b + a`.",
      "signature": "pub fn lemma_seq_union_to_multiset_commutative<A>(a: Seq<A>, b: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] (a + b) . to_multiset () =~= (b + a) . to_multiset ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_union_to_multiset_commutative().",
      "source": "vstd"
    },
    {
      "name": "lemma_max_of_concat",
      "file_path": "seq_lib.rs",
      "line_number": 2755,
      "documentation": "The maximum of the concatenation of two non-empty sequences is greater than or\nequal to the maxima of its two non-empty subsequences.",
      "signature": "pub fn lemma_max_of_concat(x: Seq<int>, y: Seq<int>)",
      "requires_clauses": [
        "0 < x . len () && 0 < y . len ()"
      ],
      "ensures_clauses": [
        "x . max () <= (x + y) . max ()",
        "y . max () <= (x + y) . max ()",
        "forall | elt : int | (x + y) . contains (elt) ==> elt <= (x + y) . max ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_max_of_concat().",
      "source": "vstd"
    },
    {
      "name": "lemma_min_of_concat",
      "file_path": "seq_lib.rs",
      "line_number": 2786,
      "documentation": "The minimum of the concatenation of two non-empty sequences is less than or\nequal to the minimum of its two non-empty subsequences.",
      "signature": "pub fn lemma_min_of_concat(x: Seq<int>, y: Seq<int>)",
      "requires_clauses": [
        "0 < x . len () && 0 < y . len ()"
      ],
      "ensures_clauses": [
        "(x + y) . min () <= x . min ()",
        "(x + y) . min () <= y . min ()",
        "forall | elt : int | (x + y) . contains (elt) ==> (x + y) . min () <= elt"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_min_of_concat().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_contains",
      "file_path": "seq_lib.rs",
      "line_number": 3416,
      "documentation": "The resulting sequence after skipping the first `n` elements from sequence `s` contains\nelement `x` if and only if `x` is contained in `s` before index `n`.",
      "signature": "pub fn lemma_seq_skip_contains<A>(s: Seq<A>, n: int, x: A)",
      "requires_clauses": [
        "0 <= n <= s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . skip (n) . contains (x) <==> (exists | i : int | 0 <= n <= i < s . len () && # [trigger] s [i] == x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_contains().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_take_len",
      "file_path": "seq_lib.rs",
      "line_number": 3352,
      "documentation": "Taking the first `n` elements of a sequence results in a sequence of length `n`,\nas long as `n` is within the bounds of the original sequence.",
      "signature": "pub fn lemma_seq_take_len<A>(s: Seq<A>, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n <= s . len () ==> # [trigger] s . take (n) . len () == n"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_take_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_update_is_remove_insert",
      "file_path": "seq_lib.rs",
      "line_number": 2959,
      "documentation": "Lemma showing that update is equivalent to a remove followed by an insertae",
      "signature": "pub fn lemma_update_is_remove_insert<A>(s: Seq<A>, i: int, a: A)",
      "requires_clauses": [
        "0 <= i < s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . update (i , a) =~= s . remove (i) . insert (i , a)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_update_is_remove_insert().",
      "source": "vstd"
    },
    {
      "name": "lemma_append_last",
      "file_path": "seq_lib.rs",
      "line_number": 2970,
      "documentation": "The last element of two concatenated sequences, the second one being non-empty, will be the\nlast element of the latter sequence.",
      "signature": "pub fn lemma_append_last<A>(s1: Seq<A>, s2: Seq<A>)",
      "requires_clauses": [
        "0 < s2 . len ()"
      ],
      "ensures_clauses": [
        "(s1 + s2) . last () == s2 . last ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_append_last().",
      "source": "vstd"
    },
    {
      "name": "lemma_concat_associative",
      "file_path": "seq_lib.rs",
      "line_number": 2979,
      "documentation": "The concatenation of sequences is associative",
      "signature": "pub fn lemma_concat_associative<A>(s1: Seq<A>, s2: Seq<A>, s3: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "s1 . add (s2 . add (s3)) =~= s1 . add (s2) . add (s3)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_concat_associative().",
      "source": "vstd"
    },
    {
      "name": "lemma_no_dup_in_concat",
      "file_path": "seq_lib.rs",
      "line_number": 3079,
      "documentation": "If sequences a and b don't have duplicates, and there are no\nelements in common between them, then the concatenated sequence\na + b will not contain duplicates either.",
      "signature": "pub fn lemma_no_dup_in_concat<A>(a: Seq<A>, b: Seq<A>)",
      "requires_clauses": [
        "a . no_duplicates ()",
        "b . no_duplicates ()",
        "forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () ==> a [i] != b [j]"
      ],
      "ensures_clauses": [
        "# [trigger] (a + b) . no_duplicates ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_no_dup_in_concat().",
      "source": "vstd"
    },
    {
      "name": "lemma_flatten_alt_concat",
      "file_path": "seq_lib.rs",
      "line_number": 3112,
      "documentation": "Flattening sequences of sequences in reverse order is distributive over concatentation.\nThat is, concatenating the flattening of two sequences of sequences in reverse\norder is the same as flattening the concatenation of two sequences of sequences\nin reverse order.",
      "signature": "pub fn lemma_flatten_alt_concat<A>(x: Seq<Seq<A>>, y: Seq<Seq<A>>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "(x + y) . flatten_alt () =~= x . flatten_alt () + y . flatten_alt ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_flatten_alt_concat().",
      "source": "vstd"
    },
    {
      "name": "lemma_sorted_unique",
      "file_path": "seq_lib.rs",
      "line_number": 3158,
      "documentation": "Any two sequences that are sorted by a total order and that have the same elements are equal.",
      "signature": "pub fn lemma_sorted_unique<A>(x: Seq<A>, y: Seq<A>, leq: spec_fn(A, A) -> bool)",
      "requires_clauses": [
        "sorted_by (x , leq)",
        "sorted_by (y , leq)",
        "total_ordering (leq)",
        "x . to_multiset () == y . to_multiset ()"
      ],
      "ensures_clauses": [
        "x =~= y"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_sorted_unique().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_contains",
      "file_path": "seq_lib.rs",
      "line_number": 3189,
      "documentation": "",
      "signature": "pub fn lemma_seq_contains<A>(s: Seq<A>, x: A)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . contains (x) <==> exists | i : int | 0 <= i < s . len () && # [trigger] s [i] == x"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_contains().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_empty_equality",
      "file_path": "seq_lib.rs",
      "line_number": 3206,
      "documentation": "A sequence with length 0 is equivalent to the empty sequence",
      "signature": "pub fn lemma_seq_empty_equality<A>(s: Seq<A>)",
      "requires_clauses": [],
      "ensures_clauses": [
        "# [trigger] s . len () == 0 ==> s =~= Seq :: < A > :: empty ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_empty_equality().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_subrange_elements",
      "file_path": "seq_lib.rs",
      "line_number": 3254,
      "documentation": "The subrange of a sequence contains only the elements within the indices `start` and `stop`\nof the original sequence.",
      "signature": "pub fn lemma_seq_subrange_elements<A>(s: Seq<A>, start: int, stop: int, x: A)",
      "requires_clauses": [
        "0 <= start <= stop <= s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . subrange (start , stop) . contains (x) <==> (exists | i : int | 0 <= start <= i < stop <= s . len () && # [trigger] s [i] == x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_subrange_elements().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_right_permutation",
      "file_path": "seq_lib.rs",
      "line_number": 3284,
      "documentation": "",
      "signature": "pub fn lemma_fold_right_permutation<A, B>(l1: Seq<A>, l2: Seq<A>, f: spec_fn(A, B) -> B, v: B)",
      "requires_clauses": [
        "commutative_foldr (f)",
        "l1 . to_multiset () == l2 . to_multiset ()"
      ],
      "ensures_clauses": [
        "l1 . fold_right (f , v) == l2 . fold_right (f , v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_fold_right_permutation().",
      "source": "vstd"
    },
    {
      "name": "lemma_fold_left_permutation",
      "file_path": "seq_lib.rs",
      "line_number": 3323,
      "documentation": "",
      "signature": "pub fn lemma_fold_left_permutation<A, B>(l1: Seq<A>, l2: Seq<A>, f: spec_fn(B, A) -> B, v: B)",
      "requires_clauses": [
        "commutative_foldl (f)",
        "l1 . to_multiset () == l2 . to_multiset ()"
      ],
      "ensures_clauses": [
        "l1 . fold_left (v , f) == l2 . fold_left (v , f)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_fold_left_permutation().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_take_contains",
      "file_path": "seq_lib.rs",
      "line_number": 3361,
      "documentation": "The resulting sequence after taking the first `n` elements from sequence `s` contains\nelement `x` if and only if `x` is contained in the first `n` elements of `s`.",
      "signature": "pub fn lemma_seq_take_contains<A>(s: Seq<A>, n: int, x: A)",
      "requires_clauses": [
        "0 <= n <= s . len ()"
      ],
      "ensures_clauses": [
        "# [trigger] s . take (n) . contains (x) <==> (exists | i : int | 0 <= i < n <= s . len () && # [trigger] s [i] == x)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_take_contains().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_take_index",
      "file_path": "seq_lib.rs",
      "line_number": 3380,
      "documentation": "If `j` is a valid index less than `n`, then the `j`th element of the sequence `s`\nis the same as `j`th element of the sequence after taking the first `n` elements of `s`.",
      "signature": "pub fn lemma_seq_take_index<A>(s: Seq<A>, n: int, j: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= j < n <= s . len () ==> # [trigger] s . take (n) [j] == s [j]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_take_index().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_len",
      "file_path": "seq_lib.rs",
      "line_number": 3407,
      "documentation": "Skipping the first `n` elements of a sequence gives a sequence of length `n` less than\nthe original sequence's length.",
      "signature": "pub fn lemma_seq_skip_len<A>(s: Seq<A>, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n <= s . len () ==> # [trigger] s . skip (n) . len () == s . len () - n"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_len().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_index",
      "file_path": "seq_lib.rs",
      "line_number": 3433,
      "documentation": "If `j` is a valid index less than `s.len() - n`, then the `j`th element of the sequence\n`s.skip(n)` is the same as the `j+n`th element of the sequence `s`.",
      "signature": "pub fn lemma_seq_skip_index<A>(s: Seq<A>, n: int, j: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n && 0 <= j < (s . len () - n) ==> # [trigger] s . skip (n) [j] == s [j + n]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_index().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_index2",
      "file_path": "seq_lib.rs",
      "line_number": 3443,
      "documentation": "If `k` is a valid index between `n` (inclusive) and the length of sequence `s` (exclusive),\nthen the `k-n`th element of the sequence `s.skip(n)` is the same as the `k`th element of the\noriginal sequence `s`.",
      "signature": "pub fn lemma_seq_skip_index2<A>(s: Seq<A>, n: int, k: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n <= k < s . len () ==> (# [trigger] s . skip (n)) [k - n] == # [trigger] s [k]"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_index2().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_append_take_skip",
      "file_path": "seq_lib.rs",
      "line_number": 3453,
      "documentation": "If `n` is the length of sequence `a`, then taking the first `n` elements of the concatenation\n`a + b` is equivalent to the sequence `a` and skipping the first `n` elements of the concatenation\n`a + b` is equivalent to the sequence `b`.",
      "signature": "pub fn lemma_seq_append_take_skip<A>(a: Seq<A>, b: Seq<A>, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n == a . len () ==> ((a + b) . take (n) =~= a && (a + b) . skip (n) =~= b)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_append_take_skip().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_take_update_commut1",
      "file_path": "seq_lib.rs",
      "line_number": 3467,
      "documentation": "If `i` is in the first `n` indices of sequence `s`, updating sequence `s` at index `i` with\nvalue `v` and then taking the first `n` elements is equivalent to first taking the first `n`\nelements of `s` and then updating index `i` to value `v`.",
      "signature": "pub fn lemma_seq_take_update_commut1<A>(s: Seq<A>, i: int, v: A, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= i < n <= s . len () ==> # [trigger] s . update (i , v) . take (n) =~= s . take (n) . update (i , v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_take_update_commut1().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_take_update_commut2",
      "file_path": "seq_lib.rs",
      "line_number": 3478,
      "documentation": "If `i` is a valid index after the first `n` indices of sequence `s`, updating sequence `s` at\nindex `i` with value `v` and then taking the first `n` elements is equivalent to just taking the first `n`\nelements of `s` without the update.",
      "signature": "pub fn lemma_seq_take_update_commut2<A>(s: Seq<A>, i: int, v: A, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n <= i < s . len () ==> # [trigger] s . update (i , v) . take (n) =~= s . take (n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_take_update_commut2().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_update_commut1",
      "file_path": "seq_lib.rs",
      "line_number": 3488,
      "documentation": "If `i` is a valid index after the first `n` indices of sequence `s`, updating sequence `s` at\nindex `i` with value `v` and then skipping the first `n` elements is equivalent to skipping the first `n`\nelements of `s` and then updating index `i-n` to value `v`.",
      "signature": "pub fn lemma_seq_skip_update_commut1<A>(s: Seq<A>, i: int, v: A, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n <= i < s . len () ==> # [trigger] s . update (i , v) . skip (n) =~= s . skip (n) . update (i - n , v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_update_commut1().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_update_commut2",
      "file_path": "seq_lib.rs",
      "line_number": 3498,
      "documentation": "If `i` is a valid index in the first `n` indices of sequence `s`, updating sequence `s` at\nindex `i` with value `v` and then skipping the first `n` elements is equivalent to just skipping\nthe first `n` elements without the update.",
      "signature": "pub fn lemma_seq_skip_update_commut2<A>(s: Seq<A>, i: int, v: A, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= i < n <= s . len () ==> # [trigger] s . update (i , v) . skip (n) =~= s . skip (n)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_update_commut2().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_build_commut",
      "file_path": "seq_lib.rs",
      "line_number": 3507,
      "documentation": "Pushing element `v` onto the end of sequence `s` and then skipping the first `n` elements is\nequivalent to skipping the first `n` elements of `s` and then pushing `v` onto the end.",
      "signature": "pub fn lemma_seq_skip_build_commut<A>(s: Seq<A>, v: A, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "0 <= n <= s . len () ==> s . push (v) . skip (n) =~= s . skip (n) . push (v)"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_build_commut().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_skip_nothing",
      "file_path": "seq_lib.rs",
      "line_number": 3516,
      "documentation": "`s.skip(0)` is equivalent to `s`.",
      "signature": "pub fn lemma_seq_skip_nothing<A>(s: Seq<A>, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n == 0 ==> # [trigger] s . skip (n) =~= s"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_skip_nothing().",
      "source": "vstd"
    },
    {
      "name": "lemma_seq_take_nothing",
      "file_path": "seq_lib.rs",
      "line_number": 3524,
      "documentation": "`s.take(0)` is equivalent to the empty sequence.",
      "signature": "pub fn lemma_seq_take_nothing<A>(s: Seq<A>, n: int)",
      "requires_clauses": [],
      "ensures_clauses": [
        "n == 0 ==> # [trigger] s . take (n) =~= Seq :: < A > :: empty ()"
      ],
      "symbol_id": "rust-analyzer cargo vstd 0.0.0-2025-11-30-0053 seq_lib/lemma_seq_take_nothing().",
      "source": "vstd"
    }
  ],
  "has_embeddings": true
}